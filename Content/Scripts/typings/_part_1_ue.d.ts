declare type EBTDecoratorLogic = 'Invalid' | 'Test' | 'And' | 'Or' | 'Not' | 'EBTDecoratorLogic_MAX';
declare var EBTDecoratorLogic : { Invalid:'Invalid',Test:'Test',And:'And',Or:'Or',Not:'Not',EBTDecoratorLogic_MAX:'EBTDecoratorLogic_MAX', };
declare class BTDecoratorLogic { 
	Operation: EBTDecoratorLogic;
	Number: number;
	clone() : BTDecoratorLogic;
	static C(Other: UObject | any): BTDecoratorLogic;
}

declare class BTCompositeChild { 
	ChildComposite: BTCompositeNode;
	ChildTask: BTTaskNode;
	Decorators: BTDecorator[];
	DecoratorOps: BTDecoratorLogic[];
	clone() : BTCompositeChild;
	static C(Other: UObject | any): BTCompositeChild;
}

declare class BTCompositeNode extends BTNode { 
	Children: BTCompositeChild[];
	Services: BTService[];
	bApplyDecoratorScope: boolean;
	static Load(ResourceName: string): BTCompositeNode;
	static Find(Outer: UObject, ResourceName: string): BTCompositeNode;
	static GetDefaultObject(): BTCompositeNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTCompositeNode;
	static C(Other: UObject | any): BTCompositeNode;
}

declare class EditedDocumentInfo { 
	EditedObjectPath: SoftObjectPath;
	SavedViewOffset: Vector2D;
	SavedZoomAmount: number;
	EditedObject: UObject;
	clone() : EditedDocumentInfo;
	static C(Other: UObject | any): EditedDocumentInfo;
}

declare class BehaviorTree extends UObject { 
	RootNode: BTCompositeNode;
	BTGraph: EdGraph;
	LastEditedDocuments: EditedDocumentInfo[];
	BlackboardAsset: BlackboardData;
	RootDecorators: BTDecorator[];
	RootDecoratorOps: BTDecoratorLogic[];
	static Load(ResourceName: string): BehaviorTree;
	static Find(Outer: UObject, ResourceName: string): BehaviorTree;
	static GetDefaultObject(): BehaviorTree;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTree;
	static C(Other: UObject | any): BehaviorTree;
}

declare type ETransformConstraintType = 'Translation' | 'Rotation' | 'Scale' | 'Parent' | 'LookAt' | 'ETransformConstraintType_MAX';
declare var ETransformConstraintType : { Translation:'Translation',Rotation:'Rotation',Scale:'Scale',Parent:'Parent',LookAt:'LookAt',ETransformConstraintType_MAX:'ETransformConstraintType_MAX', };
declare class TickableTransformConstraint extends TickableConstraint { 
	ParentTRSHandle: TransformableHandle;
	ChildTRSHandle: TransformableHandle;
	bMaintainOffset: boolean;
	Weight: number;
	bDynamicOffset: boolean;
	Type: ETransformConstraintType;
	static Load(ResourceName: string): TickableTransformConstraint;
	static Find(Outer: UObject, ResourceName: string): TickableTransformConstraint;
	static GetDefaultObject(): TickableTransformConstraint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TickableTransformConstraint;
	static C(Other: UObject | any): TickableTransformConstraint;
}

declare class TransformableComponentHandle extends TransformableHandle { 
	Component: SceneComponent;
	SocketName: string;
	static Load(ResourceName: string): TransformableComponentHandle;
	static Find(Outer: UObject, ResourceName: string): TransformableComponentHandle;
	static GetDefaultObject(): TransformableComponentHandle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TransformableComponentHandle;
	static C(Other: UObject | any): TransformableComponentHandle;
}

declare class ConstraintsManager extends UObject { 
	OnConstraintAdded_BP: UnrealEngineMulticastDelegate<(Mananger: ConstraintsManager, Constraint: TickableConstraint) => void>;
	OnConstraintRemoved_BP: UnrealEngineMulticastDelegate<(Mananger: ConstraintsManager, Constraint: TickableConstraint, bDoNotCompensate: boolean) => void>;
	Constraints: TickableConstraint[];
	static Load(ResourceName: string): ConstraintsManager;
	static Find(Outer: UObject, ResourceName: string): ConstraintsManager;
	static GetDefaultObject(): ConstraintsManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ConstraintsManager;
	static C(Other: UObject | any): ConstraintsManager;
}

declare type EAudioMixerStreamDataFormatType = 'Unknown' | 'Float' | 'Int16' | 'Unsupported' | 'EAudioMixerStreamDataFormatType_MAX';
declare var EAudioMixerStreamDataFormatType : { Unknown:'Unknown',Float:'Float',Int16:'Int16',Unsupported:'Unsupported',EAudioMixerStreamDataFormatType_MAX:'EAudioMixerStreamDataFormatType_MAX', };
declare type EAudioMixerChannelType = 'FrontLeft' | 'FrontRight' | 'FrontCenter' | 'LowFrequency' | 'BackLeft' | 'BackRight' | 'FrontLeftOfCenter' | 'FrontRightOfCenter' | 'BackCenter' | 'SideLeft' | 'SideRight' | 'TopCenter' | 'TopFrontLeft' | 'TopFrontCenter' | 'TopFrontRight' | 'TopBackLeft' | 'TopBackCenter' | 'TopBackRight' | 'Unknown' | 'ChannelTypeCount' | 'DefaultChannel' | 'EAudioMixerChannelType_MAX';
declare var EAudioMixerChannelType : { FrontLeft:'FrontLeft',FrontRight:'FrontRight',FrontCenter:'FrontCenter',LowFrequency:'LowFrequency',BackLeft:'BackLeft',BackRight:'BackRight',FrontLeftOfCenter:'FrontLeftOfCenter',FrontRightOfCenter:'FrontRightOfCenter',BackCenter:'BackCenter',SideLeft:'SideLeft',SideRight:'SideRight',TopCenter:'TopCenter',TopFrontLeft:'TopFrontLeft',TopFrontCenter:'TopFrontCenter',TopFrontRight:'TopFrontRight',TopBackLeft:'TopBackLeft',TopBackCenter:'TopBackCenter',TopBackRight:'TopBackRight',Unknown:'Unknown',ChannelTypeCount:'ChannelTypeCount',DefaultChannel:'DefaultChannel',EAudioMixerChannelType_MAX:'EAudioMixerChannelType_MAX', };
declare class AudioOutputDeviceInfo { 
	Name: string;
	DeviceID: string;
	NumChannels: number;
	SampleRate: number;
	Format: EAudioMixerStreamDataFormatType;
	OutputChannelArray: EAudioMixerChannelType[];
	bIsSystemDefault: boolean;
	bIsCurrentDevice: boolean;
	clone() : AudioOutputDeviceInfo;
	static C(Other: UObject | any): AudioOutputDeviceInfo;
	Conv_AudioOutputDeviceInfoToString(): string;
	static Conv_AudioOutputDeviceInfoToString(Info: AudioOutputDeviceInfo): string;
}

declare type ESwapAudioOutputDeviceResultState = 'Failure' | 'Success' | 'None' | 'ESwapAudioOutputDeviceResultState_MAX';
declare var ESwapAudioOutputDeviceResultState : { Failure:'Failure',Success:'Success',None:'None',ESwapAudioOutputDeviceResultState_MAX:'ESwapAudioOutputDeviceResultState_MAX', };
declare class SwapAudioOutputResult { 
	CurrentDeviceId: string;
	RequestedDeviceId: string;
	result: ESwapAudioOutputDeviceResultState;
	clone() : SwapAudioOutputResult;
	static C(Other: UObject | any): SwapAudioOutputResult;
}

declare class XRDeviceId { 
	SystemName: string;
	DeviceID: number;
	clone() : XRDeviceId;
	static C(Other: UObject | any): XRDeviceId;
	GetDevicePose(bIsTracked?: boolean,Orientation?: Rotator,bHasPositionalTracking?: boolean,Position?: Vector): {bIsTracked: boolean, Orientation: Rotator, bHasPositionalTracking: boolean, Position: Vector};
	IsDeviceTracking(): boolean;
	static GetDevicePose(XRDeviceId: XRDeviceId,bIsTracked?: boolean,Orientation?: Rotator,bHasPositionalTracking?: boolean,Position?: Vector): {bIsTracked: boolean, Orientation: Rotator, bHasPositionalTracking: boolean, Position: Vector};
	static IsDeviceTracking(XRDeviceId: XRDeviceId): boolean;
}

declare type ETrackingStatus = 'NotTracked' | 'InertialOnly' | 'Tracked' | 'ETrackingStatus_MAX';
declare var ETrackingStatus : { NotTracked:'NotTracked',InertialOnly:'InertialOnly',Tracked:'Tracked',ETrackingStatus_MAX:'ETrackingStatus_MAX', };
declare class XRHMDData { 
	bValid: boolean;
	DeviceName: string;
	ApplicationInstanceID: Guid;
	TrackingStatus: ETrackingStatus;
	Position: Vector;
	Rotation: Quat;
	clone() : XRHMDData;
	static C(Other: UObject | any): XRHMDData;
}

declare type EXRVisualType = 'Controller' | 'Hand' | 'EXRVisualType_MAX';
declare var EXRVisualType : { Controller:'Controller',Hand:'Hand',EXRVisualType_MAX:'EXRVisualType_MAX', };
declare class XRMotionControllerData { 
	bValid: boolean;
	DeviceName: string;
	ApplicationInstanceID: Guid;
	DeviceVisualType: EXRVisualType;
	HandIndex: EControllerHand;
	TrackingStatus: ETrackingStatus;
	GripPosition: Vector;
	GripRotation: Quat;
	AimPosition: Vector;
	AimRotation: Quat;
	HandKeyPositions: Vector[];
	HandKeyRotations: Quat[];
	HandKeyRadii: number[];
	bIsGrasped: boolean;
	clone() : XRMotionControllerData;
	static C(Other: UObject | any): XRMotionControllerData;
}

declare class World extends UObject { 
	Layers: Layer[];
	ActiveGroupActors: Actor[];
	ThumbnailInfo: ThumbnailInfo;
	PersistentLevel: Level;
	NetDriver: NetDriver;
	LineBatcher: LineBatchComponent;
	PersistentLineBatcher: LineBatchComponent;
	ForegroundLineBatcher: LineBatchComponent;
	NetworkManager: GameNetworkManager;
	PhysicsCollisionHandler: PhysicsCollisionHandler;
	ExtraReferencedObjects: UObject[];
	PerModuleDataObjects: UObject[];
	StreamingLevels: LevelStreaming[];
	StreamingLevelsToConsider: StreamingLevelsToConsider;
	ServerStreamingLevelsVisibility: ServerStreamingLevelsVisibility;
	StreamingLevelsPrefix: string;
	CurrentLevelPendingVisibility: Level;
	CurrentLevelPendingInvisibility: Level;
	DemoNetDriver: DemoNetDriver;
	MyParticleEventManager: ParticleEventManager;
	DefaultPhysicsVolume: PhysicsVolume;
	bAreConstraintsDirty: boolean;
	NavigationSystem: NavigationSystemBase;
	AuthorityGameMode: GameModeBase;
	GameState: GameStateBase;
	AISystem: AISystemBase;
	AvoidanceManager: AvoidanceManager;
	Levels: Level[];
	LevelCollections: LevelCollection[];
	CurrentLevel: Level;
	OwningGameInstance: GameInstance;
	ParameterCollectionInstances: MaterialParameterCollectionInstance[];
	CanvasForRenderingToTarget: Canvas;
	CanvasForDrawMaterialToRenderTarget: Canvas;
	EditorViews: LevelViewportInfo[];
	PhysicsField: PhysicsFieldComponent;
	LWILastAssignedUID: number;
	ComponentsThatNeedPreEndOfFrameSync: Set<ActorComponent>;
	ComponentsThatNeedEndOfFrameUpdate: ActorComponent[];
	ComponentsThatNeedEndOfFrameUpdate_OnGameThread: ActorComponent[];
	SelectedLevels: Level[];
	WorldComposition: WorldComposition;
	ContentBundleManager: ContentBundleManager;
	PSCPool: WorldPSCPool;
	static Load(ResourceName: string): World;
	static Find(Outer: UObject, ResourceName: string): World;
	static GetDefaultObject(): World;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): World;
	K2_GetWorldSettings(): WorldSettings;
	HandleTimelineScrubbed(): void;
	static C(Other: UObject | any): World;
	EditorDestroyActor(Actor: Actor,bShouldModifyLevel: boolean): boolean;
	EditorExec(Cmd: string): boolean;
	ExportNavigation(Path: string): string;
	GetDefaultBrush(): Brush;
	InvalidateModelGeometry(InLevel: Level): void;
	RemoveLevelInstance(): void;
	BakeConstraint(Constraint: TickableConstraint,Frames: FrameNumber[],TimeUnit: ESequenceTimeUnit): boolean;
	BakeToControlRig(LevelSequence: LevelSequence,ControlRigClass: UnrealEngineClass,ExportOptions: AnimSeqExportOption,bReduceKeys: boolean,Tolerance: number,Binding: MovieSceneBindingProxy): boolean;
	FindOrCreateControlRigComponentTrack(LevelSequence: LevelSequence,InBinding: MovieSceneBindingProxy): MovieSceneTrack[];
	FindOrCreateControlRigTrack(LevelSequence: LevelSequence,ControlRigClass: UnrealEngineClass,InBinding: MovieSceneBindingProxy): MovieSceneTrack;
	ImportFBXToControlRigTrack(InSequence: LevelSequence,InTrack: MovieSceneControlRigParameterTrack,InSection: MovieSceneControlRigParameterSection,SelectedControlRigNames: string[],ImportFBXControlRigSettings: MovieSceneUserImportFBXControlRigSettings,ImportFilename: string): boolean;
	GetAvailableAudioInputDevices(OnObtainDevicesEvent: UnrealEngineDelegate<(AvailableDevices: AudioInputDeviceInfo[]) => void>): void;
	GetActors(ActorLayer: ActorLayer): Actor[];
	ExportAnimSequence(Sequence: LevelSequence,AnimSequence: AnimSequence,ExportOption: AnimSeqExportOption,Binding: MovieSceneBindingProxy,bCreateLink: boolean): boolean;
	GetBoundObjects(InSequence: LevelSequence,InBindings: MovieSceneBindingProxy[],InRange: SequencerScriptingRange): SequencerBoundObjects[];
	GetObjectBindings(InSequence: LevelSequence,InObject: UObject[],InRange: SequencerScriptingRange): SequencerBoundObjects[];
	ImportFBXToControlRig(InSequence: LevelSequence,ActorWithControlRigTrack: string,SelectedControlRigNames: string[],ImportFBXControlRigSettings: MovieSceneUserImportFBXControlRigSettings,ImportFilename: string): boolean;
	ImportLevelSequenceFBX(InSequence: LevelSequence,InBindings: MovieSceneBindingProxy[],InImportFBXSettings: MovieSceneUserImportFBXSettings,InImportFilename: string): boolean;
	CreateNiagaraSimCache(): NiagaraSimCache;
	AcquireNiagaraGPURayTracedCollisionGroup(): number;
	GetNiagaraParameterCollection(Collection: NiagaraParameterCollection): NiagaraParameterCollectionInstance;
	ReleaseNiagaraGPURayTracedCollisionGroup(CollisionGroup: number): void;
	SetActorNiagaraGPURayTracedCollisionGroup(Actor: Actor,CollisionGroup: number): void;
	SetComponentNiagaraGPURayTracedCollisionGroup(Primitive: PrimitiveComponent,CollisionGroup: number): void;
	SpawnSystemAtLocation(SystemTemplate: NiagaraSystem,Location: Vector,Rotation: Rotator,Scale: Vector,bAutoDestroy: boolean,bAutoActivate: boolean,PoolingMethod: ENCPoolMethod,bPreCullCheck: boolean): NiagaraComponent;
	BeginPlay(): void;
	DestroyWorld(): void;
	InitializeActorsForPlay(URL: URL): void;
	GenerateNavigation(NavData: RecastNavMesh): void;
	GetAllActorsOfClassAndTags(ActorClass: UnrealEngineClass,Tags_Accept: string[],Tags_Deny: string[],OutActors?: Actor[]): {OutActors: Actor[]};
	GetAllActorsOfClassAndTagsInCurrentLevel(ActorClass: UnrealEngineClass,Tags_Accept: string[],Tags_Deny: string[],OutActors?: Actor[]): {OutActors: Actor[]};
	GetLevels(): Level[];
	GetModel(): Model;
	GetWorldBounds(): Box;
	IsGameWorld(): boolean;
	IsPlayInEditor(): boolean;
	IsPlayInPreview(): boolean;
	GetIsMyTurn(PlayerController: PlayerController,MatchID: string,bIsMyTurn?: boolean): {bIsMyTurn: boolean};
	GetMyPlayerIndex(PlayerController: PlayerController,MatchID: string,PlayerIndex?: number): {PlayerIndex: number};
	GetPlayerDisplayName(PlayerController: PlayerController,MatchID: string,PlayerIndex: number,PlayerDisplayName?: string): {PlayerDisplayName: string};
	RegisterTurnBasedMatchInterfaceObject(PlayerController: PlayerController,UObject: UObject): void;
	GetCachedAchievementDescription(PlayerController: PlayerController,AchievementID: string,bFoundID?: boolean,Title?: string,LockedDescription?: string,UnlockedDescription?: string,bHidden?: boolean): {bFoundID: boolean, Title: string, LockedDescription: string, UnlockedDescription: string, bHidden: boolean};
	GetCachedAchievementProgress(PlayerController: PlayerController,AchievementID: string,bFoundID?: boolean,Progress?: number): {bFoundID: boolean, Progress: number};
	LogBox(BoxShape: Box,Text: string,ObjectColor: LinearColor,LogCategory: string,bAddToMessageLog: boolean): void;
	LogLocation(Location: Vector,Text: string,ObjectColor: LinearColor,Radius: number,LogCategory: string,bAddToMessageLog: boolean): void;
	LogSegment(SegmentStart: Vector,SegmentEnd: Vector,Text: string,ObjectColor: LinearColor,Thickness: number,CategoryName: string,bAddToMessageLog: boolean): void;
	LogText(Text: string,LogCategory: string,bAddToMessageLog: boolean): void;
	EvalPhysicsIntegerField(WorldPosition: Vector,IntegerType: EFieldIntegerType): number;
	EvalPhysicsScalarField(WorldPosition: Vector,ScalarType: EFieldScalarType): number;
	EvalPhysicsVectorField(WorldPosition: Vector,VectorType: EFieldVectorType): Vector;
	BoxOverlapActors(BoxPos: Vector,BoxExtent: Vector,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	BoxOverlapComponents(BoxPos: Vector,Extent: Vector,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	BoxTraceMulti(Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	BoxTraceMultiByProfile(Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	BoxTraceMultiForObjects(Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	BoxTraceSingle(Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	BoxTraceSingleByProfile(Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	BoxTraceSingleForObjects(Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	CapsuleOverlapActors(CapsulePos: Vector,Radius: number,HalfHeight: number,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	CapsuleOverlapComponents(CapsulePos: Vector,Radius: number,HalfHeight: number,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	CapsuleTraceMulti(Start: Vector,End: Vector,Radius: number,HalfHeight: number,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	CapsuleTraceMultiByProfile(Start: Vector,End: Vector,Radius: number,HalfHeight: number,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	CapsuleTraceMultiForObjects(Start: Vector,End: Vector,Radius: number,HalfHeight: number,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	CapsuleTraceSingle(Start: Vector,End: Vector,Radius: number,HalfHeight: number,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	CapsuleTraceSingleByProfile(Start: Vector,End: Vector,Radius: number,HalfHeight: number,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	CapsuleTraceSingleForObjects(Start: Vector,End: Vector,Radius: number,HalfHeight: number,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	Delay(Duration: number,LatentInfo: LatentActionInfo): void;
	DelayUntilNextTick(LatentInfo: LatentActionInfo): void;
	DrawDebugArrow(LineStart: Vector,LineEnd: Vector,ArrowSize: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	DrawDebugBox(Center: Vector,Extent: Vector,LineColor: LinearColor,Rotation: Rotator,Duration: number,Thickness: number): void;
	DrawDebugCapsule(Center: Vector,HalfHeight: number,Radius: number,Rotation: Rotator,LineColor: LinearColor,Duration: number,Thickness: number): void;
	DrawDebugCircle(Center: Vector,Radius: number,NumSegments: number,LineColor: LinearColor,Duration: number,Thickness: number,YAxis: Vector,ZAxis: Vector,bDrawAxis: boolean): void;
	DrawDebugCone(Origin: Vector,Direction: Vector,Length: number,AngleWidth: number,AngleHeight: number,NumSides: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	DrawDebugConeInDegrees(Origin: Vector,Direction: Vector,Length: number,AngleWidth: number,AngleHeight: number,NumSides: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	DrawDebugCoordinateSystem(AxisLoc: Vector,AxisRot: Rotator,Scale: number,Duration: number,Thickness: number): void;
	DrawDebugCylinder(Start: Vector,End: Vector,Radius: number,Segments: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	DrawDebugFloatHistoryLocation(FloatHistory: DebugFloatHistory,DrawLocation: Vector,DrawSize: Vector2D,DrawColor: LinearColor,Duration: number): void;
	DrawDebugFloatHistoryTransform(FloatHistory: DebugFloatHistory,DrawTransform: Transform,DrawSize: Vector2D,DrawColor: LinearColor,Duration: number): void;
	DrawDebugFrustum(FrustumTransform: Transform,FrustumColor: LinearColor,Duration: number,Thickness: number): void;
	DrawDebugLine(LineStart: Vector,LineEnd: Vector,LineColor: LinearColor,Duration: number,Thickness: number): void;
	DrawDebugPlane(PlaneCoordinates: Plane,Location: Vector,Size: number,PlaneColor: LinearColor,Duration: number): void;
	DrawDebugPoint(Position: Vector,Size: number,PointColor: LinearColor,Duration: number): void;
	DrawDebugSphere(Center: Vector,Radius: number,Segments: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	DrawDebugString(TextLocation: Vector,Text: string,TestBaseActor: Actor,TextColor: LinearColor,Duration: number): void;
	ExecuteConsoleCommand(Command: string,SpecificPlayer: PlayerController): void;
	FlushDebugStrings(): void;
	FlushPersistentDebugLines(): void;
	GetGameTimeInSeconds(): number;
	HasMultipleLocalPlayers(): boolean;
	IsDedicatedServer(): boolean;
	IsServer(): boolean;
	IsSplitScreen(): boolean;
	IsStandalone(): boolean;
	K2_ClearAndInvalidateTimerHandle(Handle?: TimerHandle): {Handle: TimerHandle};
	K2_ClearTimerHandle(Handle: TimerHandle): void;
	K2_GetTimerElapsedTimeHandle(Handle: TimerHandle): number;
	K2_GetTimerRemainingTimeHandle(Handle: TimerHandle): number;
	K2_IsTimerActiveHandle(Handle: TimerHandle): boolean;
	K2_IsTimerPausedHandle(Handle: TimerHandle): boolean;
	K2_PauseTimerHandle(Handle: TimerHandle): void;
	K2_TimerExistsHandle(Handle: TimerHandle): boolean;
	K2_UnPauseTimerHandle(Handle: TimerHandle): void;
	LineTraceMulti(Start: Vector,End: Vector,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	LineTraceMultiByProfile(Start: Vector,End: Vector,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	LineTraceMultiForObjects(Start: Vector,End: Vector,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	LineTraceSingle(Start: Vector,End: Vector,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	LineTraceSingleByProfile(Start: Vector,End: Vector,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	LineTraceSingleForObjects(Start: Vector,End: Vector,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	LoadAsset(Asset: UObject,OnLoaded: UnrealEngineDelegate<(Loaded: UObject) => void>,LatentInfo: LatentActionInfo): void;
	LoadAssetClass(AssetClass: Class,OnLoaded: UnrealEngineDelegate<(Loaded: UnrealEngineClass) => void>,LatentInfo: LatentActionInfo): void;
	PrintString(InString: string,bPrintToScreen: boolean,bPrintToLog: boolean,TextColor: LinearColor,Duration: number,Key: string): void;
	PrintText(InText: string,bPrintToScreen: boolean,bPrintToLog: boolean,TextColor: LinearColor,Duration: number,Key: string): void;
	QuitGame(SpecificPlayer: PlayerController,QuitPreference: EQuitPreference,bIgnorePlatformRestrictions: boolean): void;
	RetriggerableDelay(Duration: number,LatentInfo: LatentActionInfo): void;
	SetSuppressViewportTransitionMessage(bState: boolean): void;
	SphereOverlapActors(SpherePos: Vector,SphereRadius: number,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	SphereOverlapComponents(SpherePos: Vector,SphereRadius: number,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	SphereTraceMulti(Start: Vector,End: Vector,Radius: number,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	SphereTraceMultiByProfile(Start: Vector,End: Vector,Radius: number,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	SphereTraceMultiForObjects(Start: Vector,End: Vector,Radius: number,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	SphereTraceSingle(Start: Vector,End: Vector,Radius: number,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	SphereTraceSingleByProfile(Start: Vector,End: Vector,Radius: number,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	SphereTraceSingleForObjects(Start: Vector,End: Vector,Radius: number,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	BeginDrawCanvasToRenderTarget(TextureRenderTarget: TextureRenderTarget2D,Canvas?: Canvas,Size?: Vector2D,Context?: DrawToRenderTargetContext): {Canvas: Canvas, Size: Vector2D, Context: DrawToRenderTargetContext};
	ClearRenderTarget2D(TextureRenderTarget: TextureRenderTarget2D,ClearColor: LinearColor): void;
	ConvertRenderTargetToTexture2DEditorOnly(RenderTarget: TextureRenderTarget2D,Texture: Texture2D): void;
	CreateRenderTarget2D(Width: number,Height: number,Format: ETextureRenderTargetFormat,ClearColor: LinearColor,bAutoGenerateMipMaps: boolean): TextureRenderTarget2D;
	CreateRenderTarget2DArray(Width: number,Height: number,Slices: number,Format: ETextureRenderTargetFormat,ClearColor: LinearColor,bAutoGenerateMipMaps: boolean): TextureRenderTarget2DArray;
	CreateRenderTargetVolume(Width: number,Height: number,Depth: number,Format: ETextureRenderTargetFormat,ClearColor: LinearColor,bAutoGenerateMipMaps: boolean): TextureRenderTargetVolume;
	DrawMaterialToRenderTarget(TextureRenderTarget: TextureRenderTarget2D,Material: MaterialInterface): void;
	EndDrawCanvasToRenderTarget(Context: DrawToRenderTargetContext): void;
	ExportRenderTarget(TextureRenderTarget: TextureRenderTarget2D,FilePath: string,Filename: string): void;
	ExportTexture2D(Texture: Texture2D,FilePath: string,Filename: string): void;
	ImportBufferAsTexture2D(Buffer: number[]): Texture2D;
	ImportFileAsTexture2D(Filename: string): Texture2D;
	ReadRenderTarget(TextureRenderTarget: TextureRenderTarget2D,OutSamples?: Color[],bNormalize?: boolean): {OutSamples: Color[], $: boolean};
	ReadRenderTargetPixel(TextureRenderTarget: TextureRenderTarget2D,X: number,Y: number): Color;
	ReadRenderTargetRaw(TextureRenderTarget: TextureRenderTarget2D,OutLinearSamples?: LinearColor[],bNormalize?: boolean): {OutLinearSamples: LinearColor[], $: boolean};
	ReadRenderTargetRawPixel(TextureRenderTarget: TextureRenderTarget2D,X: number,Y: number,bNormalize: boolean): LinearColor;
	ReadRenderTargetRawPixelArea(TextureRenderTarget: TextureRenderTarget2D,MinX: number,MinY: number,MaxX: number,MaxY: number,bNormalize: boolean): LinearColor[];
	ReadRenderTargetRawUV(TextureRenderTarget: TextureRenderTarget2D,U: number,V: number,bNormalize: boolean): LinearColor;
	ReadRenderTargetRawUVArea(TextureRenderTarget: TextureRenderTarget2D,Area: Box2D,bNormalize: boolean): LinearColor[];
	ReadRenderTargetUV(TextureRenderTarget: TextureRenderTarget2D,U: number,V: number): Color;
	MinAreaRectangle(InPoints: Vector[],SampleSurfaceNormal: Vector,OutRectCenter?: Vector,OutRectRotation?: Rotator,OutRectLengthX?: number,OutRectLengthY?: number,bDebugDraw?: boolean): {OutRectCenter: Vector, OutRectRotation: Rotator, OutRectLengthX: number, OutRectLengthY: number};
	MinimumAreaRectangle(InVerts: Vector[],SampleSurfaceNormal: Vector,OutRectCenter?: Vector,OutRectRotation?: Rotator,OutSideLengthX?: number,OutSideLengthY?: number,bDebugDraw?: boolean): {OutRectCenter: Vector, OutRectRotation: Rotator, OutSideLengthX: number, OutSideLengthY: number};
	CreateDynamicMaterialInstance(Parent: MaterialInterface,OptionalName: string,CreationFlags: EMIDCreationFlags): MaterialInstanceDynamic;
	GetScalarParameterValue(Collection: MaterialParameterCollection,ParameterName: string): number;
	GetVectorParameterValue(Collection: MaterialParameterCollection,ParameterName: string): LinearColor;
	SetScalarParameterValue(Collection: MaterialParameterCollection,ParameterName: string,ParameterValue: number): void;
	SetVectorParameterValue(Collection: MaterialParameterCollection,ParameterName: string,ParameterValue: LinearColor): void;
	ActivateReverbEffect(ReverbEffect: ReverbEffect,TagName: string,Priority: number,Volume: number,FadeTime: number): void;
	ApplyRadialDamage(BaseDamage: number,Origin: Vector,DamageRadius: number,DamageTypeClass: UnrealEngineClass,IgnoreActors: Actor[],DamageCauser: Actor,InstigatedByController: Controller,bDoFullDamage: boolean,DamagePreventionChannel: ECollisionChannel): boolean;
	ApplyRadialDamageWithFalloff(BaseDamage: number,MinimumDamage: number,Origin: Vector,DamageInnerRadius: number,DamageOuterRadius: number,DamageFalloff: number,DamageTypeClass: UnrealEngineClass,IgnoreActors: Actor[],DamageCauser: Actor,InstigatedByController: Controller,DamagePreventionChannel: ECollisionChannel): boolean;
	AreAnyListenersWithinRange(Location: Vector,MaximumRange: number): boolean;
	BeginDeferredActorSpawnFromClass(ActorClass: UnrealEngineClass,SpawnTransform: Transform,CollisionHandlingOverride: ESpawnActorCollisionHandlingMethod,Owner: Actor): Actor;
	BeginSpawningActorFromBlueprint(Blueprint: Blueprint,SpawnTransform: Transform,bNoCollisionFail: boolean): Actor;
	Blueprint_PredictProjectilePath_Advanced(PredictParams: PredictProjectilePathParams,PredictResult?: PredictProjectilePathResult): {PredictResult: PredictProjectilePathResult, $: boolean};
	Blueprint_PredictProjectilePath_ByObjectType(OutHit?: HitResult,OutPathPositions?: Vector[],OutLastTraceDestination?: Vector,StartPos?: Vector,LaunchVelocity?: Vector,bTracePath?: boolean,ProjectileRadius?: number,ObjectTypes?: EObjectTypeQuery[],bTraceComplex?: boolean,ActorsToIgnore?: Actor[],DrawDebugType?: EDrawDebugTrace,DrawDebugTime?: number,SimFrequency?: number,MaxSimTime?: number,OverrideGravityZ?: number): {OutHit: HitResult, OutPathPositions: Vector[], OutLastTraceDestination: Vector, $: boolean};
	Blueprint_PredictProjectilePath_ByTraceChannel(OutHit?: HitResult,OutPathPositions?: Vector[],OutLastTraceDestination?: Vector,StartPos?: Vector,LaunchVelocity?: Vector,bTracePath?: boolean,ProjectileRadius?: number,TraceChannel?: ECollisionChannel,bTraceComplex?: boolean,ActorsToIgnore?: Actor[],DrawDebugType?: EDrawDebugTrace,DrawDebugTime?: number,SimFrequency?: number,MaxSimTime?: number,OverrideGravityZ?: number): {OutHit: HitResult, OutPathPositions: Vector[], OutLastTraceDestination: Vector, $: boolean};
	BlueprintSuggestProjectileVelocity(TossVelocity?: Vector,StartLocation?: Vector,EndLocation?: Vector,LaunchSpeed?: number,OverrideGravityZ?: number,TraceOption?: ESuggestProjVelocityTraceOption,CollisionRadius?: number,bFavorHighArc?: boolean,bDrawDebug?: boolean): {TossVelocity: Vector, $: boolean};
	ClearSoundMixClassOverride(InSoundMixModifier: SoundMix,InSoundClass: SoundClass,FadeOutTime: number): void;
	ClearSoundMixModifiers(): void;
	CreatePlayer(ControllerId: number,bSpawnPlayerController: boolean): PlayerController;
	CreatePlayerFromPlatformUser(UserId: PlatformUserId,bSpawnPlayerController: boolean): PlayerController;
	CreateSound2D(Sound: SoundBase,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,ConcurrencySettings: SoundConcurrency,bPersistAcrossLevelTransition: boolean,bAutoDestroy: boolean): AudioComponent;
	DeactivateReverbEffect(TagName: string): void;
	FlushLevelStreaming(): void;
	GetActiveSpatialPluginName(): string;
	GetActorOfClass(ActorClass: UnrealEngineClass): Actor;
	GetAllActorsOfClass(ActorClass: UnrealEngineClass,OutActors?: Actor[]): {OutActors: Actor[]};
	GetAllActorsOfClassWithTag(ActorClass: UnrealEngineClass,Tag: string,OutActors?: Actor[]): {OutActors: Actor[]};
	GetAllActorsWithInterface(Interface: UnrealEngineClass,OutActors?: Actor[]): {OutActors: Actor[]};
	GetAllActorsWithTag(Tag: string,OutActors?: Actor[]): {OutActors: Actor[]};
	GetAudioTimeSeconds(): number;
	GetAvailableSpatialPluginNames(): string[];
	GetClosestListenerLocation(Location: Vector,MaximumRange: number,bAllowAttenuationOverride: boolean,ListenerPosition?: Vector): {ListenerPosition: Vector, $: boolean};
	GetCurrentLevelName(bRemovePrefixString: boolean): string;
	GetCurrentReverbEffect(): ReverbEffect;
	GetEnableWorldRendering(): boolean;
	GetGameInstance(): GameInstance;
	GetGameMode(): GameModeBase;
	GetGameState(): GameStateBase;
	GetGlobalTimeDilation(): number;
	GetMaxAudioChannelCount(): number;
	GetNumLocalPlayerControllers(): number;
	GetNumPlayerControllers(): number;
	GetNumPlayerStates(): number;
	GetPlayerCameraManager(PlayerIndex: number): PlayerCameraManager;
	GetPlayerCharacter(PlayerIndex: number): Character;
	GetPlayerController(PlayerIndex: number): PlayerController;
	GetPlayerControllerFromID(ControllerId: number): PlayerController;
	GetPlayerControllerFromPlatformUser(UserId: PlatformUserId): PlayerController;
	GetPlayerPawn(PlayerIndex: number): Pawn;
	GetPlayerState(PlayerStateIndex: number): PlayerState;
	GetPlayerStateFromUniqueNetId(UniqueId: UniqueNetIdRepl): PlayerState;
	GetRealTimeSeconds(): number;
	GetStreamingLevel(PackageName: string): LevelStreaming;
	GetTimeSeconds(): number;
	GetUnpausedTimeSeconds(): number;
	GetViewportMouseCaptureMode(): EMouseCaptureMode;
	GetWorldDeltaSeconds(): number;
	GetWorldOriginLocation(): IntVector;
	GrassOverlappingSphereCount(StaticMesh: StaticMesh,CenterPosition: Vector,Radius: number): number;
	IsGamePaused(): boolean;
	IsSplitscreenForceDisabled(): boolean;
	LoadStreamLevel(LevelName: string,bMakeVisibleAfterLoad: boolean,bShouldBlockOnLoad: boolean,LatentInfo: LatentActionInfo): void;
	LoadStreamLevelBySoftObjectPtr(Level: World,bMakeVisibleAfterLoad: boolean,bShouldBlockOnLoad: boolean,LatentInfo: LatentActionInfo): void;
	OpenLevel(LevelName: string,bAbsolute: boolean,Options: string): void;
	OpenLevelBySoftObjectPtr(Level: World,bAbsolute: boolean,Options: string): void;
	PlayDialogue2D(Dialogue: DialogueWave,Context: DialogueContext,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number): void;
	PlayDialogueAtLocation(Dialogue: DialogueWave,Context: DialogueContext,Location: Vector,Rotation: Rotator,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation): void;
	PlaySound2D(Sound: SoundBase,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,ConcurrencySettings: SoundConcurrency,OwningActor: Actor,bIsUISound: boolean): void;
	PlaySoundAtLocation(Sound: SoundBase,Location: Vector,Rotation: Rotator,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation,ConcurrencySettings: SoundConcurrency,OwningActor: Actor,InitialParams: InitialActiveSoundParams): void;
	PlayWorldCameraShake(Shake: UnrealEngineClass,Epicenter: Vector,InnerRadius: number,OuterRadius: number,Falloff: number,bOrientShakeTowardsEpicenter: boolean): void;
	PopSoundMixModifier(InSoundMixModifier: SoundMix): void;
	PushSoundMixModifier(InSoundMixModifier: SoundMix): void;
	RebaseLocalOriginOntoZero(WorldLocation: Vector): Vector;
	RebaseZeroOriginOntoLocal(WorldLocation: Vector): Vector;
	SetActiveSpatialPluginByName(InPluginName: string): boolean;
	SetBaseSoundMix(InSoundMix: SoundMix): void;
	SetEnableWorldRendering(bEnable: boolean): void;
	SetForceDisableSplitscreen(bDisable: boolean): void;
	SetGamePaused(bPaused: boolean): boolean;
	SetGlobalListenerFocusParameters(FocusAzimuthScale: number,NonFocusAzimuthScale: number,FocusDistanceScale: number,NonFocusDistanceScale: number,FocusVolumeScale: number,NonFocusVolumeScale: number,FocusPriorityScale: number,NonFocusPriorityScale: number): void;
	SetGlobalPitchModulation(PitchModulation: number,TimeSec: number): void;
	SetGlobalTimeDilation(TimeDilation: number): void;
	SetMaxAudioChannelsScaled(MaxChannelCountScale: number): void;
	SetSoundClassDistanceScale(SoundClass: SoundClass,DistanceAttenuationScale: number,TimeSec: number): void;
	SetSoundMixClassOverride(InSoundMixModifier: SoundMix,InSoundClass: SoundClass,Volume: number,Pitch: number,FadeInTime: number,bApplyToChildren: boolean): void;
	SetViewportMouseCaptureMode(MouseCaptureMode: EMouseCaptureMode): void;
	SetWorldOriginLocation(NewLocation: IntVector): void;
	SpawnDecalAtLocation(DecalMaterial: MaterialInterface,DecalSize: Vector,Location: Vector,Rotation: Rotator,LifeSpan: number): DecalComponent;
	SpawnDialogue2D(Dialogue: DialogueWave,Context: DialogueContext,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,bAutoDestroy: boolean): AudioComponent;
	SpawnDialogueAtLocation(Dialogue: DialogueWave,Context: DialogueContext,Location: Vector,Rotation: Rotator,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation,bAutoDestroy: boolean): AudioComponent;
	SpawnEmitterAtLocation(EmitterTemplate: ParticleSystem,Location: Vector,Rotation: Rotator,Scale: Vector,bAutoDestroy: boolean,PoolingMethod: EPSCPoolMethod,bAutoActivateSystem: boolean): ParticleSystemComponent;
	SpawnForceFeedbackAtLocation(ForceFeedbackEffect: ForceFeedbackEffect,Location: Vector,Rotation: Rotator,bLooping: boolean,IntensityMultiplier: number,StartTime: number,AttenuationSettings: ForceFeedbackAttenuation,bAutoDestroy: boolean): ForceFeedbackComponent;
	SpawnSound2D(Sound: SoundBase,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,ConcurrencySettings: SoundConcurrency,bPersistAcrossLevelTransition: boolean,bAutoDestroy: boolean): AudioComponent;
	SpawnSoundAtLocation(Sound: SoundBase,Location: Vector,Rotation: Rotator,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation,ConcurrencySettings: SoundConcurrency,bAutoDestroy: boolean): AudioComponent;
	SuggestProjectileVelocity_CustomArc(OutLaunchVelocity?: Vector,StartPos?: Vector,EndPos?: Vector,OverrideGravityZ?: number,ArcParam?: number): {OutLaunchVelocity: Vector, $: boolean};
	UnloadStreamLevel(LevelName: string,LatentInfo: LatentActionInfo,bShouldBlockOnUnload: boolean): void;
	UnloadStreamLevelBySoftObjectPtr(Level: World,LatentInfo: LatentActionInfo,bShouldBlockOnUnload: boolean): void;
	TraceChannelTestUtil(BatchOptions: TraceChannelTestBatchOptions,Start: Vector,End: Vector,SphereCapsuleRadius: number,CapsuleHalfHeight: number,BoxHalfSize: Vector,Orientation: Rotator,TraceChannel: ETraceTypeQuery,ObjectTypes: EObjectTypeQuery[],ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],bIgnoreSelf: boolean,DrawDebugType: EDrawDebugTrace,TraceColor: LinearColor,TraceHitColor: LinearColor,DrawTime: number): TraceQueryTestResults;
	RunAllFunctionalTests(bNewLog: boolean,bRunLooped: boolean,FailedTestsReproString: string): boolean;
	AutomationWaitForLoading(LatentInfo: LatentActionInfo,Options: AutomationWaitForLoadingOptions): void;
	DisableStatGroup(GroupName: string): void;
	EnableStatGroup(GroupName: string): void;
	SetScalabilityQualityLevelRelativeToMax(Value: number): void;
	SetScalabilityQualityToEpic(): void;
	SetScalabilityQualityToLow(): void;
	TakeAutomationScreenshot(LatentInfo: LatentActionInfo,Name: string,Notes: string,Options: AutomationScreenshotOptions): void;
	TakeAutomationScreenshotAtCamera(LatentInfo: LatentActionInfo,Camera: CameraActor,NameOverride: string,Notes: string,Options: AutomationScreenshotOptions): void;
	TakeAutomationScreenshotOfUI(LatentInfo: LatentActionInfo,Name: string,Options: AutomationScreenshotOptions): void;
	CreateMoveToProxyObject(Pawn: Pawn,Destination: Vector,TargetActor: Actor,AcceptanceRadius: number,bStopOnOverlap: boolean): AIAsyncTaskBlueprintProxy;
	SpawnAIFromClass(PawnClass: UnrealEngineClass,BehaviorTree: BehaviorTree,Location: Vector,Rotation: Rotator,bNoCollisionFail: boolean,Owner: Actor): Pawn;
	GetAllActorsOfClassMatchingTagQuery(ActorClass: UnrealEngineClass,GameplayTagQuery: GameplayTagQuery,OutActors?: Actor[]): {OutActors: Actor[]};
	GetMousePositionOnViewport(): Vector2D;
	GetViewportScale(): number;
	GetViewportSize(): Vector2D;
	GetViewportWidgetGeometry(): Geometry;
	RemoveAllWidgets(): void;
	Create(WidgetType: UnrealEngineClass,OwningPlayer: PlayerController): UserWidget;
	GetAllWidgetsOfClass(FoundWidgets?: UserWidget[],WidgetClass?: UnrealEngineClass,TopLevelOnly?: boolean): {FoundWidgets: UserWidget[]};
	GetAllWidgetsWithInterface(FoundWidgets?: UserWidget[],Interface?: UnrealEngineClass,TopLevelOnly?: boolean): {FoundWidgets: UserWidget[]};
	GetSafeZonePadding(SafePadding?: Vector4,SafePaddingScale?: Vector2D,SpillOverPadding?: Vector4): {SafePadding: Vector4, SafePaddingScale: Vector2D, SpillOverPadding: Vector4};
	SetHardwareCursor(CursorShape: EMouseCursor,CursorName: string,Hotspot: Vector2D): boolean;
	AbsoluteToViewport(AbsoluteDesktopCoordinate: Vector2D,PixelPosition?: Vector2D,ViewportPosition?: Vector2D): {PixelPosition: Vector2D, ViewportPosition: Vector2D};
	LocalToViewport(Geometry: Geometry,LocalCoordinate: Vector2D,PixelPosition?: Vector2D,ViewportPosition?: Vector2D): {PixelPosition: Vector2D, ViewportPosition: Vector2D};
	ScreenToViewport(ScreenPosition: Vector2D,ViewportPosition?: Vector2D): {ViewportPosition: Vector2D};
	ScreenToWidgetAbsolute(ScreenPosition: Vector2D,AbsoluteCoordinate?: Vector2D,bIncludeWindowPosition?: boolean): {AbsoluteCoordinate: Vector2D};
	ScreenToWidgetLocal(Geometry: Geometry,ScreenPosition: Vector2D,LocalCoordinate?: Vector2D,bIncludeWindowPosition?: boolean): {LocalCoordinate: Vector2D};
	AddConstraint(InParentHandle: TransformableHandle,InChildHandle: TransformableHandle,InConstraint: TickableTransformConstraint,bMaintainOffset: boolean): boolean;
	CreateFromType(InType: ETransformConstraintType): TickableTransformConstraint;
	CreateTransformableComponentHandle(InSceneComponent: SceneComponent,InSocketName: string): TransformableComponentHandle;
	GetManager(): ConstraintsManager;
	RemoveConstraint(InIndex: number): boolean;
	FoliageOverlappingBoxCount(StaticMesh: StaticMesh,Box: Box): number;
	FoliageOverlappingBoxTransforms(StaticMesh: StaticMesh,Box: Box,OutTransforms?: Transform[]): {OutTransforms: Transform[]};
	FoliageOverlappingSphereCount(StaticMesh: StaticMesh,CenterPosition: Vector,Radius: number): number;
	AddMasterSubmixEffect(SubmixEffectPreset: SoundEffectSubmixPreset): void;
	AddSourceEffectToPresetChain(PresetChain: SoundEffectSourcePresetChain,Entry: SourceEffectChainEntry): void;
	AddSubmixEffect(SoundSubmix: SoundSubmix,SubmixEffectPreset: SoundEffectSubmixPreset): number;
	ClearMasterSubmixEffects(): void;
	ClearSubmixEffectChainOverride(SoundSubmix: SoundSubmix,FadeTimeSec: number): void;
	ClearSubmixEffects(SoundSubmix: SoundSubmix): void;
	GetAvailableAudioOutputDevices(OnObtainDevicesEvent: UnrealEngineDelegate<(AvailableDevices: AudioOutputDeviceInfo[]) => void>): void;
	GetCurrentAudioOutputDeviceName(OnObtainCurrentDeviceEvent: UnrealEngineDelegate<(CurrentDevice: string) => void>): void;
	GetMagnitudeForFrequencies(Frequencies: number[],Magnitudes?: number[],SubmixToAnalyze?: SoundSubmix): {Magnitudes: number[]};
	GetNumberOfEntriesInSourceEffectChain(PresetChain: SoundEffectSourcePresetChain): number;
	GetPhaseForFrequencies(Frequencies: number[],Phases?: number[],SubmixToAnalyze?: SoundSubmix): {Phases: number[]};
	IsAudioBusActive(AudioBus: AudioBus): boolean;
	PauseRecordingOutput(SubmixToPause: SoundSubmix): void;
	RemoveMasterSubmixEffect(SubmixEffectPreset: SoundEffectSubmixPreset): void;
	RemoveSourceEffectFromPresetChain(PresetChain: SoundEffectSourcePresetChain,EntryIndex: number): void;
	RemoveSubmixEffect(SoundSubmix: SoundSubmix,SubmixEffectPreset: SoundEffectSubmixPreset): void;
	RemoveSubmixEffectAtIndex(SoundSubmix: SoundSubmix,SubmixChainIndex: number): void;
	RemoveSubmixEffectPreset(SoundSubmix: SoundSubmix,SubmixEffectPreset: SoundEffectSubmixPreset): void;
	RemoveSubmixEffectPresetAtIndex(SoundSubmix: SoundSubmix,SubmixChainIndex: number): void;
	ReplaceSoundEffectSubmix(InSoundSubmix: SoundSubmix,SubmixChainIndex: number,SubmixEffectPreset: SoundEffectSubmixPreset): void;
	ReplaceSubmixEffect(InSoundSubmix: SoundSubmix,SubmixChainIndex: number,SubmixEffectPreset: SoundEffectSubmixPreset): void;
	ResumeRecordingOutput(SubmixToPause: SoundSubmix): void;
	SetBypassSourceEffectChainEntry(PresetChain: SoundEffectSourcePresetChain,EntryIndex: number,bBypassed: boolean): void;
	SetSubmixEffectChainOverride(SoundSubmix: SoundSubmix,SubmixEffectPresetChain: SoundEffectSubmixPreset[],FadeTimeSec: number): void;
	StartAnalyzingOutput(SubmixToAnalyze: SoundSubmix,FFTSize: EFFTSize,InterpolationMethod: EFFTPeakInterpolationMethod,WindowType: EFFTWindowType,HopSize: number,SpectrumType: EAudioSpectrumType): void;
	StartAudioBus(AudioBus: AudioBus): void;
	StartRecordingOutput(ExpectedDuration: number,SubmixToRecord: SoundSubmix): void;
	StopAnalyzingOutput(SubmixToStopAnalyzing: SoundSubmix): void;
	StopAudioBus(AudioBus: AudioBus): void;
	StopRecordingOutput(ExportType: EAudioRecordingExportType,Name: string,Path: string,SubmixToRecord: SoundSubmix,ExistingSoundWaveToOverwrite: SoundWave): SoundWave;
	SwapAudioOutputDevice(NewDeviceId: string,OnCompletedDeviceSwap: UnrealEngineDelegate<(SwapResult: SwapAudioOutputResult) => void>): void;
	GetControllerTransformForTime(ControllerIndex: number,MotionSource: string,Time: Timespan,bTimeWasUsed?: boolean,Orientation?: Rotator,Position?: Vector,bProvidedLinearVelocity?: boolean,LinearVelocity?: Vector,bProvidedAngularVelocity?: boolean,AngularVelocityRadPerSec?: Vector,bProvidedLinearAcceleration?: boolean,LinearAcceleration?: Vector): {bTimeWasUsed: boolean, Orientation: Rotator, Position: Vector, bProvidedLinearVelocity: boolean, LinearVelocity: Vector, bProvidedAngularVelocity: boolean, AngularVelocityRadPerSec: Vector, bProvidedLinearAcceleration: boolean, LinearAcceleration: Vector, $: boolean};
	GetDeviceWorldPose(XRDeviceId: XRDeviceId,bIsTracked?: boolean,Orientation?: Rotator,bHasPositionalTracking?: boolean,Position?: Vector): {bIsTracked: boolean, Orientation: Rotator, bHasPositionalTracking: boolean, Position: Vector};
	GetHMDData(HMDData?: XRHMDData): {HMDData: XRHMDData};
	GetMotionControllerData(Hand: EControllerHand,MotionControllerData?: XRMotionControllerData): {MotionControllerData: XRMotionControllerData};
	GetTrackingToWorldTransform(): Transform;
	GetWorldToMetersScale(): number;
	SetWorldToMetersScale(NewScale: number): void;
	static EditorDestroyActor(World: World,Actor: Actor,bShouldModifyLevel: boolean): boolean;
	static EditorExec(World: World,Cmd: string): boolean;
	static ExportNavigation(InWorld: World,Path: string): string;
	static GetDefaultBrush(World: World): Brush;
	static InvalidateModelGeometry(World: World,InLevel: Level): void;
	static RemoveLevelInstance(World: World): void;
	static BakeConstraint(World: World,Constraint: TickableConstraint,Frames: FrameNumber[],TimeUnit: ESequenceTimeUnit): boolean;
	static BakeToControlRig(World: World,LevelSequence: LevelSequence,ControlRigClass: UnrealEngineClass,ExportOptions: AnimSeqExportOption,bReduceKeys: boolean,Tolerance: number,Binding: MovieSceneBindingProxy): boolean;
	static FindOrCreateControlRigComponentTrack(World: World,LevelSequence: LevelSequence,InBinding: MovieSceneBindingProxy): MovieSceneTrack[];
	static FindOrCreateControlRigTrack(World: World,LevelSequence: LevelSequence,ControlRigClass: UnrealEngineClass,InBinding: MovieSceneBindingProxy): MovieSceneTrack;
	static ImportFBXToControlRigTrack(World: World,InSequence: LevelSequence,InTrack: MovieSceneControlRigParameterTrack,InSection: MovieSceneControlRigParameterSection,SelectedControlRigNames: string[],ImportFBXControlRigSettings: MovieSceneUserImportFBXControlRigSettings,ImportFilename: string): boolean;
	static GetAvailableAudioInputDevices(WorldContextObject: UObject,OnObtainDevicesEvent: UnrealEngineDelegate<(AvailableDevices: AudioInputDeviceInfo[]) => void>): void;
	static GetActors(WorldContextObject: UObject,ActorLayer: ActorLayer): Actor[];
	static ExportAnimSequence(World: World,Sequence: LevelSequence,AnimSequence: AnimSequence,ExportOption: AnimSeqExportOption,Binding: MovieSceneBindingProxy,bCreateLink: boolean): boolean;
	static GetBoundObjects(InWorld: World,InSequence: LevelSequence,InBindings: MovieSceneBindingProxy[],InRange: SequencerScriptingRange): SequencerBoundObjects[];
	static GetObjectBindings(InWorld: World,InSequence: LevelSequence,InObject: UObject[],InRange: SequencerScriptingRange): SequencerBoundObjects[];
	static ImportFBXToControlRig(World: World,InSequence: LevelSequence,ActorWithControlRigTrack: string,SelectedControlRigNames: string[],ImportFBXControlRigSettings: MovieSceneUserImportFBXControlRigSettings,ImportFilename: string): boolean;
	static ImportLevelSequenceFBX(InWorld: World,InSequence: LevelSequence,InBindings: MovieSceneBindingProxy[],InImportFBXSettings: MovieSceneUserImportFBXSettings,InImportFilename: string): boolean;
	static CreateNiagaraSimCache(WorldContextObject: UObject): NiagaraSimCache;
	static AcquireNiagaraGPURayTracedCollisionGroup(WorldContextObject: UObject): number;
	static GetNiagaraParameterCollection(WorldContextObject: UObject,Collection: NiagaraParameterCollection): NiagaraParameterCollectionInstance;
	static ReleaseNiagaraGPURayTracedCollisionGroup(WorldContextObject: UObject,CollisionGroup: number): void;
	static SetActorNiagaraGPURayTracedCollisionGroup(WorldContextObject: UObject,Actor: Actor,CollisionGroup: number): void;
	static SetComponentNiagaraGPURayTracedCollisionGroup(WorldContextObject: UObject,Primitive: PrimitiveComponent,CollisionGroup: number): void;
	static SpawnSystemAtLocation(WorldContextObject: UObject,SystemTemplate: NiagaraSystem,Location: Vector,Rotation: Rotator,Scale: Vector,bAutoDestroy: boolean,bAutoActivate: boolean,PoolingMethod: ENCPoolMethod,bPreCullCheck: boolean): NiagaraComponent;
	static BeginPlay(World: World): void;
	static DestroyWorld(World: World): void;
	static InitializeActorsForPlay(World: World,URL: URL): void;
	static GenerateNavigation(InWorld: World,NavData: RecastNavMesh): void;
	static GetAllActorsOfClassAndTags(WorldContextObject: UObject,ActorClass: UnrealEngineClass,Tags_Accept: string[],Tags_Deny: string[],OutActors?: Actor[]): {OutActors: Actor[]};
	static GetAllActorsOfClassAndTagsInCurrentLevel(WorldContextObject: UObject,ActorClass: UnrealEngineClass,Tags_Accept: string[],Tags_Deny: string[],OutActors?: Actor[]): {OutActors: Actor[]};
	static GetLevels(World: World): Level[];
	static GetModel(World: World): Model;
	static GetWorldBounds(InWorld: World): Box;
	static IsGameWorld(World: World): boolean;
	static IsPlayInEditor(World: World): boolean;
	static IsPlayInPreview(World: World): boolean;
	static GetIsMyTurn(WorldContextObject: UObject,PlayerController: PlayerController,MatchID: string,bIsMyTurn?: boolean): {bIsMyTurn: boolean};
	static GetMyPlayerIndex(WorldContextObject: UObject,PlayerController: PlayerController,MatchID: string,PlayerIndex?: number): {PlayerIndex: number};
	static GetPlayerDisplayName(WorldContextObject: UObject,PlayerController: PlayerController,MatchID: string,PlayerIndex: number,PlayerDisplayName?: string): {PlayerDisplayName: string};
	static RegisterTurnBasedMatchInterfaceObject(WorldContextObject: UObject,PlayerController: PlayerController,UObject: UObject): void;
	static GetCachedAchievementDescription(WorldContextObject: UObject,PlayerController: PlayerController,AchievementID: string,bFoundID?: boolean,Title?: string,LockedDescription?: string,UnlockedDescription?: string,bHidden?: boolean): {bFoundID: boolean, Title: string, LockedDescription: string, UnlockedDescription: string, bHidden: boolean};
	static GetCachedAchievementProgress(WorldContextObject: UObject,PlayerController: PlayerController,AchievementID: string,bFoundID?: boolean,Progress?: number): {bFoundID: boolean, Progress: number};
	static LogBox(WorldContextObject: UObject,BoxShape: Box,Text: string,ObjectColor: LinearColor,LogCategory: string,bAddToMessageLog: boolean): void;
	static LogLocation(WorldContextObject: UObject,Location: Vector,Text: string,ObjectColor: LinearColor,Radius: number,LogCategory: string,bAddToMessageLog: boolean): void;
	static LogSegment(WorldContextObject: UObject,SegmentStart: Vector,SegmentEnd: Vector,Text: string,ObjectColor: LinearColor,Thickness: number,CategoryName: string,bAddToMessageLog: boolean): void;
	static LogText(WorldContextObject: UObject,Text: string,LogCategory: string,bAddToMessageLog: boolean): void;
	static EvalPhysicsIntegerField(WorldContextObject: UObject,WorldPosition: Vector,IntegerType: EFieldIntegerType): number;
	static EvalPhysicsScalarField(WorldContextObject: UObject,WorldPosition: Vector,ScalarType: EFieldScalarType): number;
	static EvalPhysicsVectorField(WorldContextObject: UObject,WorldPosition: Vector,VectorType: EFieldVectorType): Vector;
	static BoxOverlapActors(WorldContextObject: UObject,BoxPos: Vector,BoxExtent: Vector,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	static BoxOverlapComponents(WorldContextObject: UObject,BoxPos: Vector,Extent: Vector,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	static BoxTraceMulti(WorldContextObject: UObject,Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static BoxTraceMultiByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static BoxTraceMultiForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static BoxTraceSingle(WorldContextObject: UObject,Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static BoxTraceSingleByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static BoxTraceSingleForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static CapsuleOverlapActors(WorldContextObject: UObject,CapsulePos: Vector,Radius: number,HalfHeight: number,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	static CapsuleOverlapComponents(WorldContextObject: UObject,CapsulePos: Vector,Radius: number,HalfHeight: number,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	static CapsuleTraceMulti(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,HalfHeight: number,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static CapsuleTraceMultiByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,HalfHeight: number,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static CapsuleTraceMultiForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,HalfHeight: number,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static CapsuleTraceSingle(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,HalfHeight: number,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static CapsuleTraceSingleByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,HalfHeight: number,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static CapsuleTraceSingleForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,HalfHeight: number,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static Delay(WorldContextObject: UObject,Duration: number,LatentInfo: LatentActionInfo): void;
	static DelayUntilNextTick(WorldContextObject: UObject,LatentInfo: LatentActionInfo): void;
	static DrawDebugArrow(WorldContextObject: UObject,LineStart: Vector,LineEnd: Vector,ArrowSize: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	static DrawDebugBox(WorldContextObject: UObject,Center: Vector,Extent: Vector,LineColor: LinearColor,Rotation: Rotator,Duration: number,Thickness: number): void;
	static DrawDebugCapsule(WorldContextObject: UObject,Center: Vector,HalfHeight: number,Radius: number,Rotation: Rotator,LineColor: LinearColor,Duration: number,Thickness: number): void;
	static DrawDebugCircle(WorldContextObject: UObject,Center: Vector,Radius: number,NumSegments: number,LineColor: LinearColor,Duration: number,Thickness: number,YAxis: Vector,ZAxis: Vector,bDrawAxis: boolean): void;
	static DrawDebugCone(WorldContextObject: UObject,Origin: Vector,Direction: Vector,Length: number,AngleWidth: number,AngleHeight: number,NumSides: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	static DrawDebugConeInDegrees(WorldContextObject: UObject,Origin: Vector,Direction: Vector,Length: number,AngleWidth: number,AngleHeight: number,NumSides: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	static DrawDebugCoordinateSystem(WorldContextObject: UObject,AxisLoc: Vector,AxisRot: Rotator,Scale: number,Duration: number,Thickness: number): void;
	static DrawDebugCylinder(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,Segments: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	static DrawDebugFloatHistoryLocation(WorldContextObject: UObject,FloatHistory: DebugFloatHistory,DrawLocation: Vector,DrawSize: Vector2D,DrawColor: LinearColor,Duration: number): void;
	static DrawDebugFloatHistoryTransform(WorldContextObject: UObject,FloatHistory: DebugFloatHistory,DrawTransform: Transform,DrawSize: Vector2D,DrawColor: LinearColor,Duration: number): void;
	static DrawDebugFrustum(WorldContextObject: UObject,FrustumTransform: Transform,FrustumColor: LinearColor,Duration: number,Thickness: number): void;
	static DrawDebugLine(WorldContextObject: UObject,LineStart: Vector,LineEnd: Vector,LineColor: LinearColor,Duration: number,Thickness: number): void;
	static DrawDebugPlane(WorldContextObject: UObject,PlaneCoordinates: Plane,Location: Vector,Size: number,PlaneColor: LinearColor,Duration: number): void;
	static DrawDebugPoint(WorldContextObject: UObject,Position: Vector,Size: number,PointColor: LinearColor,Duration: number): void;
	static DrawDebugSphere(WorldContextObject: UObject,Center: Vector,Radius: number,Segments: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	static DrawDebugString(WorldContextObject: UObject,TextLocation: Vector,Text: string,TestBaseActor: Actor,TextColor: LinearColor,Duration: number): void;
	static ExecuteConsoleCommand(WorldContextObject: UObject,Command: string,SpecificPlayer: PlayerController): void;
	static FlushDebugStrings(WorldContextObject: UObject): void;
	static FlushPersistentDebugLines(WorldContextObject: UObject): void;
	static GetGameTimeInSeconds(WorldContextObject: UObject): number;
	static HasMultipleLocalPlayers(WorldContextObject: UObject): boolean;
	static IsDedicatedServer(WorldContextObject: UObject): boolean;
	static IsServer(WorldContextObject: UObject): boolean;
	static IsSplitScreen(WorldContextObject: UObject): boolean;
	static IsStandalone(WorldContextObject: UObject): boolean;
	static K2_ClearAndInvalidateTimerHandle(WorldContextObject: UObject,Handle?: TimerHandle): {Handle: TimerHandle};
	static K2_ClearTimerHandle(WorldContextObject: UObject,Handle: TimerHandle): void;
	static K2_GetTimerElapsedTimeHandle(WorldContextObject: UObject,Handle: TimerHandle): number;
	static K2_GetTimerRemainingTimeHandle(WorldContextObject: UObject,Handle: TimerHandle): number;
	static K2_IsTimerActiveHandle(WorldContextObject: UObject,Handle: TimerHandle): boolean;
	static K2_IsTimerPausedHandle(WorldContextObject: UObject,Handle: TimerHandle): boolean;
	static K2_PauseTimerHandle(WorldContextObject: UObject,Handle: TimerHandle): void;
	static K2_TimerExistsHandle(WorldContextObject: UObject,Handle: TimerHandle): boolean;
	static K2_UnPauseTimerHandle(WorldContextObject: UObject,Handle: TimerHandle): void;
	static LineTraceMulti(WorldContextObject: UObject,Start: Vector,End: Vector,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static LineTraceMultiByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static LineTraceMultiForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static LineTraceSingle(WorldContextObject: UObject,Start: Vector,End: Vector,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static LineTraceSingleByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static LineTraceSingleForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static LoadAsset(WorldContextObject: UObject,Asset: UObject,OnLoaded: UnrealEngineDelegate<(Loaded: UObject) => void>,LatentInfo: LatentActionInfo): void;
	static LoadAssetClass(WorldContextObject: UObject,AssetClass: Class,OnLoaded: UnrealEngineDelegate<(Loaded: UnrealEngineClass) => void>,LatentInfo: LatentActionInfo): void;
	static PrintString(WorldContextObject: UObject,InString: string,bPrintToScreen: boolean,bPrintToLog: boolean,TextColor: LinearColor,Duration: number,Key: string): void;
	static PrintText(WorldContextObject: UObject,InText: string,bPrintToScreen: boolean,bPrintToLog: boolean,TextColor: LinearColor,Duration: number,Key: string): void;
	static QuitGame(WorldContextObject: UObject,SpecificPlayer: PlayerController,QuitPreference: EQuitPreference,bIgnorePlatformRestrictions: boolean): void;
	static RetriggerableDelay(WorldContextObject: UObject,Duration: number,LatentInfo: LatentActionInfo): void;
	static SetSuppressViewportTransitionMessage(WorldContextObject: UObject,bState: boolean): void;
	static SphereOverlapActors(WorldContextObject: UObject,SpherePos: Vector,SphereRadius: number,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	static SphereOverlapComponents(WorldContextObject: UObject,SpherePos: Vector,SphereRadius: number,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	static SphereTraceMulti(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static SphereTraceMultiByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static SphereTraceMultiForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static SphereTraceSingle(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static SphereTraceSingleByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static SphereTraceSingleForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static BeginDrawCanvasToRenderTarget(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,Canvas?: Canvas,Size?: Vector2D,Context?: DrawToRenderTargetContext): {Canvas: Canvas, Size: Vector2D, Context: DrawToRenderTargetContext};
	static ClearRenderTarget2D(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,ClearColor: LinearColor): void;
	static ConvertRenderTargetToTexture2DEditorOnly(WorldContextObject: UObject,RenderTarget: TextureRenderTarget2D,Texture: Texture2D): void;
	static CreateRenderTarget2D(WorldContextObject: UObject,Width: number,Height: number,Format: ETextureRenderTargetFormat,ClearColor: LinearColor,bAutoGenerateMipMaps: boolean): TextureRenderTarget2D;
	static CreateRenderTarget2DArray(WorldContextObject: UObject,Width: number,Height: number,Slices: number,Format: ETextureRenderTargetFormat,ClearColor: LinearColor,bAutoGenerateMipMaps: boolean): TextureRenderTarget2DArray;
	static CreateRenderTargetVolume(WorldContextObject: UObject,Width: number,Height: number,Depth: number,Format: ETextureRenderTargetFormat,ClearColor: LinearColor,bAutoGenerateMipMaps: boolean): TextureRenderTargetVolume;
	static DrawMaterialToRenderTarget(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,Material: MaterialInterface): void;
	static EndDrawCanvasToRenderTarget(WorldContextObject: UObject,Context: DrawToRenderTargetContext): void;
	static ExportRenderTarget(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,FilePath: string,Filename: string): void;
	static ExportTexture2D(WorldContextObject: UObject,Texture: Texture2D,FilePath: string,Filename: string): void;
	static ImportBufferAsTexture2D(WorldContextObject: UObject,Buffer: number[]): Texture2D;
	static ImportFileAsTexture2D(WorldContextObject: UObject,Filename: string): Texture2D;
	static ReadRenderTarget(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,OutSamples?: Color[],bNormalize?: boolean): {OutSamples: Color[], $: boolean};
	static ReadRenderTargetPixel(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,X: number,Y: number): Color;
	static ReadRenderTargetRaw(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,OutLinearSamples?: LinearColor[],bNormalize?: boolean): {OutLinearSamples: LinearColor[], $: boolean};
	static ReadRenderTargetRawPixel(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,X: number,Y: number,bNormalize: boolean): LinearColor;
	static ReadRenderTargetRawPixelArea(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,MinX: number,MinY: number,MaxX: number,MaxY: number,bNormalize: boolean): LinearColor[];
	static ReadRenderTargetRawUV(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,U: number,V: number,bNormalize: boolean): LinearColor;
	static ReadRenderTargetRawUVArea(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,Area: Box2D,bNormalize: boolean): LinearColor[];
	static ReadRenderTargetUV(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,U: number,V: number): Color;
	static MinAreaRectangle(WorldContextObject: UObject,InPoints: Vector[],SampleSurfaceNormal: Vector,OutRectCenter?: Vector,OutRectRotation?: Rotator,OutRectLengthX?: number,OutRectLengthY?: number,bDebugDraw?: boolean): {OutRectCenter: Vector, OutRectRotation: Rotator, OutRectLengthX: number, OutRectLengthY: number};
	static MinimumAreaRectangle(WorldContextObject: UObject,InVerts: Vector[],SampleSurfaceNormal: Vector,OutRectCenter?: Vector,OutRectRotation?: Rotator,OutSideLengthX?: number,OutSideLengthY?: number,bDebugDraw?: boolean): {OutRectCenter: Vector, OutRectRotation: Rotator, OutSideLengthX: number, OutSideLengthY: number};
	static CreateDynamicMaterialInstance(WorldContextObject: UObject,Parent: MaterialInterface,OptionalName: string,CreationFlags: EMIDCreationFlags): MaterialInstanceDynamic;
	static GetScalarParameterValue(WorldContextObject: UObject,Collection: MaterialParameterCollection,ParameterName: string): number;
	static GetVectorParameterValue(WorldContextObject: UObject,Collection: MaterialParameterCollection,ParameterName: string): LinearColor;
	static SetScalarParameterValue(WorldContextObject: UObject,Collection: MaterialParameterCollection,ParameterName: string,ParameterValue: number): void;
	static SetVectorParameterValue(WorldContextObject: UObject,Collection: MaterialParameterCollection,ParameterName: string,ParameterValue: LinearColor): void;
	static ActivateReverbEffect(WorldContextObject: UObject,ReverbEffect: ReverbEffect,TagName: string,Priority: number,Volume: number,FadeTime: number): void;
	static ApplyRadialDamage(WorldContextObject: UObject,BaseDamage: number,Origin: Vector,DamageRadius: number,DamageTypeClass: UnrealEngineClass,IgnoreActors: Actor[],DamageCauser: Actor,InstigatedByController: Controller,bDoFullDamage: boolean,DamagePreventionChannel: ECollisionChannel): boolean;
	static ApplyRadialDamageWithFalloff(WorldContextObject: UObject,BaseDamage: number,MinimumDamage: number,Origin: Vector,DamageInnerRadius: number,DamageOuterRadius: number,DamageFalloff: number,DamageTypeClass: UnrealEngineClass,IgnoreActors: Actor[],DamageCauser: Actor,InstigatedByController: Controller,DamagePreventionChannel: ECollisionChannel): boolean;
	static AreAnyListenersWithinRange(WorldContextObject: UObject,Location: Vector,MaximumRange: number): boolean;
	static BeginDeferredActorSpawnFromClass(WorldContextObject: UObject,ActorClass: UnrealEngineClass,SpawnTransform: Transform,CollisionHandlingOverride: ESpawnActorCollisionHandlingMethod,Owner: Actor): Actor;
	static BeginSpawningActorFromBlueprint(WorldContextObject: UObject,Blueprint: Blueprint,SpawnTransform: Transform,bNoCollisionFail: boolean): Actor;
	static Blueprint_PredictProjectilePath_Advanced(WorldContextObject: UObject,PredictParams: PredictProjectilePathParams,PredictResult?: PredictProjectilePathResult): {PredictResult: PredictProjectilePathResult, $: boolean};
	static Blueprint_PredictProjectilePath_ByObjectType(WorldContextObject: UObject,OutHit?: HitResult,OutPathPositions?: Vector[],OutLastTraceDestination?: Vector,StartPos?: Vector,LaunchVelocity?: Vector,bTracePath?: boolean,ProjectileRadius?: number,ObjectTypes?: EObjectTypeQuery[],bTraceComplex?: boolean,ActorsToIgnore?: Actor[],DrawDebugType?: EDrawDebugTrace,DrawDebugTime?: number,SimFrequency?: number,MaxSimTime?: number,OverrideGravityZ?: number): {OutHit: HitResult, OutPathPositions: Vector[], OutLastTraceDestination: Vector, $: boolean};
	static Blueprint_PredictProjectilePath_ByTraceChannel(WorldContextObject: UObject,OutHit?: HitResult,OutPathPositions?: Vector[],OutLastTraceDestination?: Vector,StartPos?: Vector,LaunchVelocity?: Vector,bTracePath?: boolean,ProjectileRadius?: number,TraceChannel?: ECollisionChannel,bTraceComplex?: boolean,ActorsToIgnore?: Actor[],DrawDebugType?: EDrawDebugTrace,DrawDebugTime?: number,SimFrequency?: number,MaxSimTime?: number,OverrideGravityZ?: number): {OutHit: HitResult, OutPathPositions: Vector[], OutLastTraceDestination: Vector, $: boolean};
	static BlueprintSuggestProjectileVelocity(WorldContextObject: UObject,TossVelocity?: Vector,StartLocation?: Vector,EndLocation?: Vector,LaunchSpeed?: number,OverrideGravityZ?: number,TraceOption?: ESuggestProjVelocityTraceOption,CollisionRadius?: number,bFavorHighArc?: boolean,bDrawDebug?: boolean): {TossVelocity: Vector, $: boolean};
	static ClearSoundMixClassOverride(WorldContextObject: UObject,InSoundMixModifier: SoundMix,InSoundClass: SoundClass,FadeOutTime: number): void;
	static ClearSoundMixModifiers(WorldContextObject: UObject): void;
	static CreatePlayer(WorldContextObject: UObject,ControllerId: number,bSpawnPlayerController: boolean): PlayerController;
	static CreatePlayerFromPlatformUser(WorldContextObject: UObject,UserId: PlatformUserId,bSpawnPlayerController: boolean): PlayerController;
	static CreateSound2D(WorldContextObject: UObject,Sound: SoundBase,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,ConcurrencySettings: SoundConcurrency,bPersistAcrossLevelTransition: boolean,bAutoDestroy: boolean): AudioComponent;
	static DeactivateReverbEffect(WorldContextObject: UObject,TagName: string): void;
	static FlushLevelStreaming(WorldContextObject: UObject): void;
	static GetActiveSpatialPluginName(WorldContextObject: UObject): string;
	static GetActorOfClass(WorldContextObject: UObject,ActorClass: UnrealEngineClass): Actor;
	static GetAllActorsOfClass(WorldContextObject: UObject,ActorClass: UnrealEngineClass,OutActors?: Actor[]): {OutActors: Actor[]};
	static GetAllActorsOfClassWithTag(WorldContextObject: UObject,ActorClass: UnrealEngineClass,Tag: string,OutActors?: Actor[]): {OutActors: Actor[]};
	static GetAllActorsWithInterface(WorldContextObject: UObject,Interface: UnrealEngineClass,OutActors?: Actor[]): {OutActors: Actor[]};
	static GetAllActorsWithTag(WorldContextObject: UObject,Tag: string,OutActors?: Actor[]): {OutActors: Actor[]};
	static GetAudioTimeSeconds(WorldContextObject: UObject): number;
	static GetAvailableSpatialPluginNames(WorldContextObject: UObject): string[];
	static GetClosestListenerLocation(WorldContextObject: UObject,Location: Vector,MaximumRange: number,bAllowAttenuationOverride: boolean,ListenerPosition?: Vector): {ListenerPosition: Vector, $: boolean};
	static GetCurrentLevelName(WorldContextObject: UObject,bRemovePrefixString: boolean): string;
	static GetCurrentReverbEffect(WorldContextObject: UObject): ReverbEffect;
	static GetEnableWorldRendering(WorldContextObject: UObject): boolean;
	static GetGameInstance(WorldContextObject: UObject): GameInstance;
	static GetGameMode(WorldContextObject: UObject): GameModeBase;
	static GetGameState(WorldContextObject: UObject): GameStateBase;
	static GetGlobalTimeDilation(WorldContextObject: UObject): number;
	static GetMaxAudioChannelCount(WorldContextObject: UObject): number;
	static GetNumLocalPlayerControllers(WorldContextObject: UObject): number;
	static GetNumPlayerControllers(WorldContextObject: UObject): number;
	static GetNumPlayerStates(WorldContextObject: UObject): number;
	static GetPlayerCameraManager(WorldContextObject: UObject,PlayerIndex: number): PlayerCameraManager;
	static GetPlayerCharacter(WorldContextObject: UObject,PlayerIndex: number): Character;
	static GetPlayerController(WorldContextObject: UObject,PlayerIndex: number): PlayerController;
	static GetPlayerControllerFromID(WorldContextObject: UObject,ControllerId: number): PlayerController;
	static GetPlayerControllerFromPlatformUser(WorldContextObject: UObject,UserId: PlatformUserId): PlayerController;
	static GetPlayerPawn(WorldContextObject: UObject,PlayerIndex: number): Pawn;
	static GetPlayerState(WorldContextObject: UObject,PlayerStateIndex: number): PlayerState;
	static GetPlayerStateFromUniqueNetId(WorldContextObject: UObject,UniqueId: UniqueNetIdRepl): PlayerState;
	static GetRealTimeSeconds(WorldContextObject: UObject): number;
	static GetStreamingLevel(WorldContextObject: UObject,PackageName: string): LevelStreaming;
	static GetTimeSeconds(WorldContextObject: UObject): number;
	static GetUnpausedTimeSeconds(WorldContextObject: UObject): number;
	static GetViewportMouseCaptureMode(WorldContextObject: UObject): EMouseCaptureMode;
	static GetWorldDeltaSeconds(WorldContextObject: UObject): number;
	static GetWorldOriginLocation(WorldContextObject: UObject): IntVector;
	static GrassOverlappingSphereCount(WorldContextObject: UObject,StaticMesh: StaticMesh,CenterPosition: Vector,Radius: number): number;
	static IsGamePaused(WorldContextObject: UObject): boolean;
	static IsSplitscreenForceDisabled(WorldContextObject: UObject): boolean;
	static LoadStreamLevel(WorldContextObject: UObject,LevelName: string,bMakeVisibleAfterLoad: boolean,bShouldBlockOnLoad: boolean,LatentInfo: LatentActionInfo): void;
	static LoadStreamLevelBySoftObjectPtr(WorldContextObject: UObject,Level: World,bMakeVisibleAfterLoad: boolean,bShouldBlockOnLoad: boolean,LatentInfo: LatentActionInfo): void;
	static OpenLevel(WorldContextObject: UObject,LevelName: string,bAbsolute: boolean,Options: string): void;
	static OpenLevelBySoftObjectPtr(WorldContextObject: UObject,Level: World,bAbsolute: boolean,Options: string): void;
	static PlayDialogue2D(WorldContextObject: UObject,Dialogue: DialogueWave,Context: DialogueContext,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number): void;
	static PlayDialogueAtLocation(WorldContextObject: UObject,Dialogue: DialogueWave,Context: DialogueContext,Location: Vector,Rotation: Rotator,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation): void;
	static PlaySound2D(WorldContextObject: UObject,Sound: SoundBase,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,ConcurrencySettings: SoundConcurrency,OwningActor: Actor,bIsUISound: boolean): void;
	static PlaySoundAtLocation(WorldContextObject: UObject,Sound: SoundBase,Location: Vector,Rotation: Rotator,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation,ConcurrencySettings: SoundConcurrency,OwningActor: Actor,InitialParams: InitialActiveSoundParams): void;
	static PlayWorldCameraShake(WorldContextObject: UObject,Shake: UnrealEngineClass,Epicenter: Vector,InnerRadius: number,OuterRadius: number,Falloff: number,bOrientShakeTowardsEpicenter: boolean): void;
	static PopSoundMixModifier(WorldContextObject: UObject,InSoundMixModifier: SoundMix): void;
	static PushSoundMixModifier(WorldContextObject: UObject,InSoundMixModifier: SoundMix): void;
	static RebaseLocalOriginOntoZero(WorldContextObject: UObject,WorldLocation: Vector): Vector;
	static RebaseZeroOriginOntoLocal(WorldContextObject: UObject,WorldLocation: Vector): Vector;
	static SetActiveSpatialPluginByName(WorldContextObject: UObject,InPluginName: string): boolean;
	static SetBaseSoundMix(WorldContextObject: UObject,InSoundMix: SoundMix): void;
	static SetEnableWorldRendering(WorldContextObject: UObject,bEnable: boolean): void;
	static SetForceDisableSplitscreen(WorldContextObject: UObject,bDisable: boolean): void;
	static SetGamePaused(WorldContextObject: UObject,bPaused: boolean): boolean;
	static SetGlobalListenerFocusParameters(WorldContextObject: UObject,FocusAzimuthScale: number,NonFocusAzimuthScale: number,FocusDistanceScale: number,NonFocusDistanceScale: number,FocusVolumeScale: number,NonFocusVolumeScale: number,FocusPriorityScale: number,NonFocusPriorityScale: number): void;
	static SetGlobalPitchModulation(WorldContextObject: UObject,PitchModulation: number,TimeSec: number): void;
	static SetGlobalTimeDilation(WorldContextObject: UObject,TimeDilation: number): void;
	static SetMaxAudioChannelsScaled(WorldContextObject: UObject,MaxChannelCountScale: number): void;
	static SetSoundClassDistanceScale(WorldContextObject: UObject,SoundClass: SoundClass,DistanceAttenuationScale: number,TimeSec: number): void;
	static SetSoundMixClassOverride(WorldContextObject: UObject,InSoundMixModifier: SoundMix,InSoundClass: SoundClass,Volume: number,Pitch: number,FadeInTime: number,bApplyToChildren: boolean): void;
	static SetViewportMouseCaptureMode(WorldContextObject: UObject,MouseCaptureMode: EMouseCaptureMode): void;
	static SetWorldOriginLocation(WorldContextObject: UObject,NewLocation: IntVector): void;
	static SpawnDecalAtLocation(WorldContextObject: UObject,DecalMaterial: MaterialInterface,DecalSize: Vector,Location: Vector,Rotation: Rotator,LifeSpan: number): DecalComponent;
	static SpawnDialogue2D(WorldContextObject: UObject,Dialogue: DialogueWave,Context: DialogueContext,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,bAutoDestroy: boolean): AudioComponent;
	static SpawnDialogueAtLocation(WorldContextObject: UObject,Dialogue: DialogueWave,Context: DialogueContext,Location: Vector,Rotation: Rotator,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation,bAutoDestroy: boolean): AudioComponent;
	static SpawnEmitterAtLocation(WorldContextObject: UObject,EmitterTemplate: ParticleSystem,Location: Vector,Rotation: Rotator,Scale: Vector,bAutoDestroy: boolean,PoolingMethod: EPSCPoolMethod,bAutoActivateSystem: boolean): ParticleSystemComponent;
	static SpawnForceFeedbackAtLocation(WorldContextObject: UObject,ForceFeedbackEffect: ForceFeedbackEffect,Location: Vector,Rotation: Rotator,bLooping: boolean,IntensityMultiplier: number,StartTime: number,AttenuationSettings: ForceFeedbackAttenuation,bAutoDestroy: boolean): ForceFeedbackComponent;
	static SpawnSound2D(WorldContextObject: UObject,Sound: SoundBase,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,ConcurrencySettings: SoundConcurrency,bPersistAcrossLevelTransition: boolean,bAutoDestroy: boolean): AudioComponent;
	static SpawnSoundAtLocation(WorldContextObject: UObject,Sound: SoundBase,Location: Vector,Rotation: Rotator,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation,ConcurrencySettings: SoundConcurrency,bAutoDestroy: boolean): AudioComponent;
	static SuggestProjectileVelocity_CustomArc(WorldContextObject: UObject,OutLaunchVelocity?: Vector,StartPos?: Vector,EndPos?: Vector,OverrideGravityZ?: number,ArcParam?: number): {OutLaunchVelocity: Vector, $: boolean};
	static UnloadStreamLevel(WorldContextObject: UObject,LevelName: string,LatentInfo: LatentActionInfo,bShouldBlockOnUnload: boolean): void;
	static UnloadStreamLevelBySoftObjectPtr(WorldContextObject: UObject,Level: World,LatentInfo: LatentActionInfo,bShouldBlockOnUnload: boolean): void;
	static TraceChannelTestUtil(WorldContextObject: UObject,BatchOptions: TraceChannelTestBatchOptions,Start: Vector,End: Vector,SphereCapsuleRadius: number,CapsuleHalfHeight: number,BoxHalfSize: Vector,Orientation: Rotator,TraceChannel: ETraceTypeQuery,ObjectTypes: EObjectTypeQuery[],ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],bIgnoreSelf: boolean,DrawDebugType: EDrawDebugTrace,TraceColor: LinearColor,TraceHitColor: LinearColor,DrawTime: number): TraceQueryTestResults;
	static RunAllFunctionalTests(WorldContextObject: UObject,bNewLog: boolean,bRunLooped: boolean,FailedTestsReproString: string): boolean;
	static AutomationWaitForLoading(WorldContextObject: UObject,LatentInfo: LatentActionInfo,Options: AutomationWaitForLoadingOptions): void;
	static DisableStatGroup(WorldContextObject: UObject,GroupName: string): void;
	static EnableStatGroup(WorldContextObject: UObject,GroupName: string): void;
	static SetScalabilityQualityLevelRelativeToMax(WorldContextObject: UObject,Value: number): void;
	static SetScalabilityQualityToEpic(WorldContextObject: UObject): void;
	static SetScalabilityQualityToLow(WorldContextObject: UObject): void;
	static TakeAutomationScreenshot(WorldContextObject: UObject,LatentInfo: LatentActionInfo,Name: string,Notes: string,Options: AutomationScreenshotOptions): void;
	static TakeAutomationScreenshotAtCamera(WorldContextObject: UObject,LatentInfo: LatentActionInfo,Camera: CameraActor,NameOverride: string,Notes: string,Options: AutomationScreenshotOptions): void;
	static TakeAutomationScreenshotOfUI(WorldContextObject: UObject,LatentInfo: LatentActionInfo,Name: string,Options: AutomationScreenshotOptions): void;
	static CreateMoveToProxyObject(WorldContextObject: UObject,Pawn: Pawn,Destination: Vector,TargetActor: Actor,AcceptanceRadius: number,bStopOnOverlap: boolean): AIAsyncTaskBlueprintProxy;
	static SpawnAIFromClass(WorldContextObject: UObject,PawnClass: UnrealEngineClass,BehaviorTree: BehaviorTree,Location: Vector,Rotation: Rotator,bNoCollisionFail: boolean,Owner: Actor): Pawn;
	static GetAllActorsOfClassMatchingTagQuery(WorldContextObject: UObject,ActorClass: UnrealEngineClass,GameplayTagQuery: GameplayTagQuery,OutActors?: Actor[]): {OutActors: Actor[]};
	static GetMousePositionOnViewport(WorldContextObject: UObject): Vector2D;
	static GetViewportScale(WorldContextObject: UObject): number;
	static GetViewportSize(WorldContextObject: UObject): Vector2D;
	static GetViewportWidgetGeometry(WorldContextObject: UObject): Geometry;
	static RemoveAllWidgets(WorldContextObject: UObject): void;
	static Create(WorldContextObject: UObject,WidgetType: UnrealEngineClass,OwningPlayer: PlayerController): UserWidget;
	static GetAllWidgetsOfClass(WorldContextObject: UObject,FoundWidgets?: UserWidget[],WidgetClass?: UnrealEngineClass,TopLevelOnly?: boolean): {FoundWidgets: UserWidget[]};
	static GetAllWidgetsWithInterface(WorldContextObject: UObject,FoundWidgets?: UserWidget[],Interface?: UnrealEngineClass,TopLevelOnly?: boolean): {FoundWidgets: UserWidget[]};
	static GetSafeZonePadding(WorldContextObject: UObject,SafePadding?: Vector4,SafePaddingScale?: Vector2D,SpillOverPadding?: Vector4): {SafePadding: Vector4, SafePaddingScale: Vector2D, SpillOverPadding: Vector4};
	static SetHardwareCursor(WorldContextObject: UObject,CursorShape: EMouseCursor,CursorName: string,Hotspot: Vector2D): boolean;
	static AbsoluteToViewport(WorldContextObject: UObject,AbsoluteDesktopCoordinate: Vector2D,PixelPosition?: Vector2D,ViewportPosition?: Vector2D): {PixelPosition: Vector2D, ViewportPosition: Vector2D};
	static LocalToViewport(WorldContextObject: UObject,Geometry: Geometry,LocalCoordinate: Vector2D,PixelPosition?: Vector2D,ViewportPosition?: Vector2D): {PixelPosition: Vector2D, ViewportPosition: Vector2D};
	static ScreenToViewport(WorldContextObject: UObject,ScreenPosition: Vector2D,ViewportPosition?: Vector2D): {ViewportPosition: Vector2D};
	static ScreenToWidgetAbsolute(WorldContextObject: UObject,ScreenPosition: Vector2D,AbsoluteCoordinate?: Vector2D,bIncludeWindowPosition?: boolean): {AbsoluteCoordinate: Vector2D};
	static ScreenToWidgetLocal(WorldContextObject: UObject,Geometry: Geometry,ScreenPosition: Vector2D,LocalCoordinate?: Vector2D,bIncludeWindowPosition?: boolean): {LocalCoordinate: Vector2D};
	static AddConstraint(InWorld: World,InParentHandle: TransformableHandle,InChildHandle: TransformableHandle,InConstraint: TickableTransformConstraint,bMaintainOffset: boolean): boolean;
	static CreateFromType(InWorld: World,InType: ETransformConstraintType): TickableTransformConstraint;
	static CreateTransformableComponentHandle(InWorld: World,InSceneComponent: SceneComponent,InSocketName: string): TransformableComponentHandle;
	static GetManager(InWorld: World): ConstraintsManager;
	static RemoveConstraint(InWorld: World,InIndex: number): boolean;
	static FoliageOverlappingBoxCount(WorldContextObject: UObject,StaticMesh: StaticMesh,Box: Box): number;
	static FoliageOverlappingBoxTransforms(WorldContextObject: UObject,StaticMesh: StaticMesh,Box: Box,OutTransforms?: Transform[]): {OutTransforms: Transform[]};
	static FoliageOverlappingSphereCount(WorldContextObject: UObject,StaticMesh: StaticMesh,CenterPosition: Vector,Radius: number): number;
	static AddMasterSubmixEffect(WorldContextObject: UObject,SubmixEffectPreset: SoundEffectSubmixPreset): void;
	static AddSourceEffectToPresetChain(WorldContextObject: UObject,PresetChain: SoundEffectSourcePresetChain,Entry: SourceEffectChainEntry): void;
	static AddSubmixEffect(WorldContextObject: UObject,SoundSubmix: SoundSubmix,SubmixEffectPreset: SoundEffectSubmixPreset): number;
	static ClearMasterSubmixEffects(WorldContextObject: UObject): void;
	static ClearSubmixEffectChainOverride(WorldContextObject: UObject,SoundSubmix: SoundSubmix,FadeTimeSec: number): void;
	static ClearSubmixEffects(WorldContextObject: UObject,SoundSubmix: SoundSubmix): void;
	static GetAvailableAudioOutputDevices(WorldContextObject: UObject,OnObtainDevicesEvent: UnrealEngineDelegate<(AvailableDevices: AudioOutputDeviceInfo[]) => void>): void;
	static GetCurrentAudioOutputDeviceName(WorldContextObject: UObject,OnObtainCurrentDeviceEvent: UnrealEngineDelegate<(CurrentDevice: string) => void>): void;
	static GetMagnitudeForFrequencies(WorldContextObject: UObject,Frequencies: number[],Magnitudes?: number[],SubmixToAnalyze?: SoundSubmix): {Magnitudes: number[]};
	static GetNumberOfEntriesInSourceEffectChain(WorldContextObject: UObject,PresetChain: SoundEffectSourcePresetChain): number;
	static GetPhaseForFrequencies(WorldContextObject: UObject,Frequencies: number[],Phases?: number[],SubmixToAnalyze?: SoundSubmix): {Phases: number[]};
	static IsAudioBusActive(WorldContextObject: UObject,AudioBus: AudioBus): boolean;
	static PauseRecordingOutput(WorldContextObject: UObject,SubmixToPause: SoundSubmix): void;
	static RemoveMasterSubmixEffect(WorldContextObject: UObject,SubmixEffectPreset: SoundEffectSubmixPreset): void;
	static RemoveSourceEffectFromPresetChain(WorldContextObject: UObject,PresetChain: SoundEffectSourcePresetChain,EntryIndex: number): void;
	static RemoveSubmixEffect(WorldContextObject: UObject,SoundSubmix: SoundSubmix,SubmixEffectPreset: SoundEffectSubmixPreset): void;
	static RemoveSubmixEffectAtIndex(WorldContextObject: UObject,SoundSubmix: SoundSubmix,SubmixChainIndex: number): void;
	static RemoveSubmixEffectPreset(WorldContextObject: UObject,SoundSubmix: SoundSubmix,SubmixEffectPreset: SoundEffectSubmixPreset): void;
	static RemoveSubmixEffectPresetAtIndex(WorldContextObject: UObject,SoundSubmix: SoundSubmix,SubmixChainIndex: number): void;
	static ReplaceSoundEffectSubmix(WorldContextObject: UObject,InSoundSubmix: SoundSubmix,SubmixChainIndex: number,SubmixEffectPreset: SoundEffectSubmixPreset): void;
	static ReplaceSubmixEffect(WorldContextObject: UObject,InSoundSubmix: SoundSubmix,SubmixChainIndex: number,SubmixEffectPreset: SoundEffectSubmixPreset): void;
	static ResumeRecordingOutput(WorldContextObject: UObject,SubmixToPause: SoundSubmix): void;
	static SetBypassSourceEffectChainEntry(WorldContextObject: UObject,PresetChain: SoundEffectSourcePresetChain,EntryIndex: number,bBypassed: boolean): void;
	static SetSubmixEffectChainOverride(WorldContextObject: UObject,SoundSubmix: SoundSubmix,SubmixEffectPresetChain: SoundEffectSubmixPreset[],FadeTimeSec: number): void;
	static StartAnalyzingOutput(WorldContextObject: UObject,SubmixToAnalyze: SoundSubmix,FFTSize: EFFTSize,InterpolationMethod: EFFTPeakInterpolationMethod,WindowType: EFFTWindowType,HopSize: number,SpectrumType: EAudioSpectrumType): void;
	static StartAudioBus(WorldContextObject: UObject,AudioBus: AudioBus): void;
	static StartRecordingOutput(WorldContextObject: UObject,ExpectedDuration: number,SubmixToRecord: SoundSubmix): void;
	static StopAnalyzingOutput(WorldContextObject: UObject,SubmixToStopAnalyzing: SoundSubmix): void;
	static StopAudioBus(WorldContextObject: UObject,AudioBus: AudioBus): void;
	static StopRecordingOutput(WorldContextObject: UObject,ExportType: EAudioRecordingExportType,Name: string,Path: string,SubmixToRecord: SoundSubmix,ExistingSoundWaveToOverwrite: SoundWave): SoundWave;
	static SwapAudioOutputDevice(WorldContextObject: UObject,NewDeviceId: string,OnCompletedDeviceSwap: UnrealEngineDelegate<(SwapResult: SwapAudioOutputResult) => void>): void;
	static GetControllerTransformForTime(WorldContext: UObject,ControllerIndex: number,MotionSource: string,Time: Timespan,bTimeWasUsed?: boolean,Orientation?: Rotator,Position?: Vector,bProvidedLinearVelocity?: boolean,LinearVelocity?: Vector,bProvidedAngularVelocity?: boolean,AngularVelocityRadPerSec?: Vector,bProvidedLinearAcceleration?: boolean,LinearAcceleration?: Vector): {bTimeWasUsed: boolean, Orientation: Rotator, Position: Vector, bProvidedLinearVelocity: boolean, LinearVelocity: Vector, bProvidedAngularVelocity: boolean, AngularVelocityRadPerSec: Vector, bProvidedLinearAcceleration: boolean, LinearAcceleration: Vector, $: boolean};
	static GetDeviceWorldPose(WorldContext: UObject,XRDeviceId: XRDeviceId,bIsTracked?: boolean,Orientation?: Rotator,bHasPositionalTracking?: boolean,Position?: Vector): {bIsTracked: boolean, Orientation: Rotator, bHasPositionalTracking: boolean, Position: Vector};
	static GetHMDData(WorldContext: UObject,HMDData?: XRHMDData): {HMDData: XRHMDData};
	static GetMotionControllerData(WorldContext: UObject,Hand: EControllerHand,MotionControllerData?: XRMotionControllerData): {MotionControllerData: XRMotionControllerData};
	static GetTrackingToWorldTransform(WorldContext: UObject): Transform;
	static GetWorldToMetersScale(WorldContext: UObject): number;
	static SetWorldToMetersScale(WorldContext: UObject,NewScale: number): void;
}

declare class BrushBuilder extends UObject { 
	BitmapFilename: string;
	Tooltip: string;
	NotifyBadParams: boolean;
	Vertices: Vector[];
	Polys: BuilderPoly[];
	Layer: string;
	MergeCoplanars: boolean;
	static Load(ResourceName: string): BrushBuilder;
	static Find(Outer: UObject, ResourceName: string): BrushBuilder;
	static GetDefaultObject(): BrushBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BrushBuilder;
	static C(Other: UObject | any): BrushBuilder;
	Build(InWorld: World,InBrush: Brush): boolean;
	static Build(Builder: BrushBuilder,InWorld: World,InBrush: Brush): boolean;
}

declare class GeomSelection { 
	Type: number;
	Index: number;
	SelectionIndex: number;
	clone() : GeomSelection;
	static C(Other: UObject | any): GeomSelection;
}

declare class Brush extends Actor { 
	BrushType: EBrushType;
	BrushColor: Color;
	PolyFlags: number;
	bColored: boolean;
	bSolidWhenSelected: boolean;
	bPlaceableFromClassBrowser: boolean;
	bNotForClientOrServer: boolean;
	Brush: Model;
	BrushComponent: BrushComponent;
	BrushBuilder: BrushBuilder;
	bDisplayShadedVolume: boolean;
	ShadedVolumeOpacityValue: number;
	bInManipulation: boolean;
	SavedSelections: GeomSelection[];
	static GetDefaultObject(): Brush;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Brush;
	static C(Other: UObject | any): Brush;
	csgAdd(PolyFlags: number,BrushType: EBrushType): Brush;
	GetSurfaces(Surfaces?: number[]): {Surfaces: number[]};
	static csgAdd(DefaultBrush: Brush,PolyFlags: number,BrushType: EBrushType): Brush;
	static GetSurfaces(Brush: Brush,Surfaces?: number[]): {Surfaces: number[]};
}

declare class Volume extends Brush { 
	static GetDefaultObject(): Volume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Volume;
	static C(Other: UObject | any): Volume;
	CreateBrushForVolumeActor(BrushBuilder: BrushBuilder): void;
	static CreateBrushForVolumeActor(NewActor: Volume,BrushBuilder: BrushBuilder): void;
}

declare class PhysicsVolume extends Volume { 
	TerminalVelocity: number;
	Priority: number;
	FluidFriction: number;
	bWaterVolume: boolean;
	bPhysicsOnContact: boolean;
	static GetDefaultObject(): PhysicsVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsVolume;
	static C(Other: UObject | any): PhysicsVolume;
}

declare type EComponentMobility = 'Static' | 'Stationary' | 'Movable' | 'EComponentMobility_MAX';
declare var EComponentMobility : { Static:'Static',Stationary:'Stationary',Movable:'Movable',EComponentMobility_MAX:'EComponentMobility_MAX', };
declare type EDetachmentRule = 'KeepRelative' | 'KeepWorld' | 'EDetachmentRule_MAX';
declare var EDetachmentRule : { KeepRelative:'KeepRelative',KeepWorld:'KeepWorld',EDetachmentRule_MAX:'EDetachmentRule_MAX', };
declare type EMoveComponentAction = 'Move' | 'Stop' | 'Return' | 'EMoveComponentAction_MAX';
declare var EMoveComponentAction : { Move:'Move',Stop:'Stop',Return:'Return',EMoveComponentAction_MAX:'EMoveComponentAction_MAX', };
declare class ARPin extends UObject { 
	TrackedGeometry: ARTrackedGeometry;
	PinnedComponent: SceneComponent;
	LocalToTrackingTransform: Transform;
	LocalToAlignedTrackingTransform: Transform;
	TrackingState: EARTrackingState;
	OnARTrackingStateChanged: UnrealEngineMulticastDelegate<(NewTrackingState: EARTrackingState) => void>;
	OnARTransformUpdated: UnrealEngineMulticastDelegate<(OldToNewTransform: Transform) => void>;
	static Load(ResourceName: string): ARPin;
	static Find(Outer: UObject, ResourceName: string): ARPin;
	static GetDefaultObject(): ARPin;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARPin;
	GetTrackingState(): EARTrackingState;
	GetTrackedGeometry(): ARTrackedGeometry;
	GetPinnedComponent(): SceneComponent;
	GetLocalToWorldTransform(): Transform;
	GetLocalToTrackingTransform(): Transform;
	GetDebugName(): string;
	DebugDraw(World: World,Color: LinearColor,Scale: number,PersistForSeconds: number): void;
	static C(Other: UObject | any): ARPin;
	DebugDrawPin(WorldContextObject: UObject,Color: LinearColor,Scale: number,PersistForSeconds: number): void;
	RemovePin(): void;
	static DebugDrawPin(ARPin: ARPin,WorldContextObject: UObject,Color: LinearColor,Scale: number,PersistForSeconds: number): void;
	static RemovePin(PinToRemove: ARPin): void;
}

declare class SceneComponent extends ActorComponent { 
	PhysicsVolume: PhysicsVolume;
	AttachParent: SceneComponent;
	AttachSocketName: string;
	AttachChildren: SceneComponent[];
	ClientAttachedChildren: SceneComponent[];
	RelativeLocation: Vector;
	RelativeRotation: Rotator;
	RelativeScale3D: Vector;
	ComponentVelocity: Vector;
	bComponentToWorldUpdated: boolean;
	bAbsoluteLocation: boolean;
	bAbsoluteRotation: boolean;
	bAbsoluteScale: boolean;
	bVisible: boolean;
	bShouldBeAttached: boolean;
	bShouldSnapLocationWhenAttached: boolean;
	bShouldSnapRotationWhenAttached: boolean;
	bShouldSnapScaleWhenAttached: boolean;
	bShouldUpdatePhysicsVolume: boolean;
	bHiddenInGame: boolean;
	bBoundsChangeTriggersStreamingDataRebuild: boolean;
	bUseAttachParentBound: boolean;
	bComputeFastLocalBounds: boolean;
	bComputeBoundsOnceForGame: boolean;
	bComputedBoundsOnceForGame: boolean;
	bIsNotRenderAttachmentRoot: boolean;
	bVisualizeComponent: boolean;
	Mobility: EComponentMobility;
	DetailMode: EDetailMode;
	PhysicsVolumeChangedDelegate: UnrealEngineMulticastDelegate<(NewVolume: PhysicsVolume) => void>;
	ReplacementSceneComponent: SceneComponent;
	static Load(ResourceName: string): SceneComponent;
	static Find(Outer: UObject, ResourceName: string): SceneComponent;
	static GetDefaultObject(): SceneComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SceneComponent;
	ToggleVisibility(bPropagateToChildren: boolean): void;
	SetWorldScale3D(NewScale: Vector): void;
	SetVisibility(bNewVisibility: boolean,bPropagateToChildren: boolean): void;
	SetShouldUpdatePhysicsVolume(bInShouldUpdatePhysicsVolume: boolean): void;
	SetRelativeScale3D(NewScale3D: Vector): void;
	SetMobility(NewMobility: EComponentMobility): void;
	SetHiddenInGame(NewHidden: boolean,bPropagateToChildren: boolean): void;
	SetAbsolute(bNewAbsoluteLocation: boolean,bNewAbsoluteRotation: boolean,bNewAbsoluteScale: boolean): void;
	ResetRelativeTransform(): void;
	OnRep_Visibility(OldValue: boolean): void;
	OnRep_Transform(): void;
	OnRep_AttachSocketName(): void;
	OnRep_AttachParent(): void;
	OnRep_AttachChildren(): void;
	K2_SetWorldTransform(NewTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetWorldRotation(NewRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetWorldLocationAndRotation(NewLocation: Vector,NewRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetWorldLocation(NewLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetRelativeTransform(NewTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetRelativeRotation(NewRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetRelativeLocationAndRotation(NewLocation: Vector,NewRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetRelativeLocation(NewLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_GetComponentToWorld(): Transform;
	K2_GetComponentScale(): Vector;
	K2_GetComponentRotation(): Rotator;
	K2_GetComponentLocation(): Vector;
	K2_DetachFromComponent(LocationRule: EDetachmentRule,RotationRule: EDetachmentRule,ScaleRule: EDetachmentRule,bCallModify: boolean): void;
	K2_AttachToComponent(Parent: SceneComponent,SocketName: string,LocationRule: EAttachmentRule,RotationRule: EAttachmentRule,ScaleRule: EAttachmentRule,bWeldSimulatedBodies: boolean): boolean;
	K2_AttachTo(InParent: SceneComponent,InSocketName: string,AttachType: EAttachLocation,bWeldSimulatedBodies: boolean): boolean;
	K2_AddWorldTransformKeepScale(DeltaTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddWorldTransform(DeltaTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddWorldRotation(DeltaRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddWorldOffset(DeltaLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddRelativeRotation(DeltaRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddRelativeLocation(DeltaLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddLocalTransform(DeltaTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddLocalRotation(DeltaRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddLocalOffset(DeltaLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	IsVisible(): boolean;
	IsSimulatingPhysics(BoneName: string): boolean;
	IsAnySimulatingPhysics(): boolean;
	GetUpVector(): Vector;
	GetSocketTransform(InSocketName: string,TransformSpace: ERelativeTransformSpace): Transform;
	GetSocketRotation(InSocketName: string): Rotator;
	GetSocketQuaternion(InSocketName: string): Quat;
	GetSocketLocation(InSocketName: string): Vector;
	GetShouldUpdatePhysicsVolume(): boolean;
	GetRightVector(): Vector;
	GetRelativeTransform(): Transform;
	GetPhysicsVolume(): PhysicsVolume;
	GetParentComponents(Parents?: SceneComponent[]): {Parents: SceneComponent[]};
	GetNumChildrenComponents(): number;
	GetForwardVector(): Vector;
	GetComponentVelocity(): Vector;
	GetChildrenComponents(bIncludeAllDescendants: boolean,Children?: SceneComponent[]): {Children: SceneComponent[]};
	GetChildComponent(ChildIndex: number): SceneComponent;
	GetAttachSocketName(): string;
	GetAttachParent(): SceneComponent;
	GetAllSocketNames(): string[];
	DoesSocketExist(InSocketName: string): boolean;
	DetachFromParent(bMaintainWorldPosition: boolean,bCallModify: boolean): void;
	static C(Other: UObject | any): SceneComponent;
	SetMobile(): void;
	SetMobility(Type: EComponentMobility): void;
	GetComponentBounds(Origin?: Vector,BoxExtent?: Vector,SphereRadius?: number): {Origin: Vector, BoxExtent: Vector, SphereRadius: number};
	MoveComponentTo(TargetRelativeLocation: Vector,TargetRelativeRotation: Rotator,bEaseOut: boolean,bEaseIn: boolean,OverTime: number,bForceShortestRotationPath: boolean,MoveAction: EMoveComponentAction,LatentInfo: LatentActionInfo): void;
	PinComponent(PinToWorldTransform: Transform,TrackedGeometry: ARTrackedGeometry,DebugName: string): ARPin;
	PinComponentToARPin(Pin: ARPin): boolean;
	PinComponentToTraceResult(TraceResult: ARTraceResult,DebugName: string): ARPin;
	UnpinComponent(): void;
	static SetMobile(SceneComponent: SceneComponent): void;
	static SetMobility(SceneComponent: SceneComponent,Type: EComponentMobility): void;
	static GetComponentBounds(Component: SceneComponent,Origin?: Vector,BoxExtent?: Vector,SphereRadius?: number): {Origin: Vector, BoxExtent: Vector, SphereRadius: number};
	static MoveComponentTo(Component: SceneComponent,TargetRelativeLocation: Vector,TargetRelativeRotation: Rotator,bEaseOut: boolean,bEaseIn: boolean,OverTime: number,bForceShortestRotationPath: boolean,MoveAction: EMoveComponentAction,LatentInfo: LatentActionInfo): void;
	static PinComponent(ComponentToPin: SceneComponent,PinToWorldTransform: Transform,TrackedGeometry: ARTrackedGeometry,DebugName: string): ARPin;
	static PinComponentToARPin(ComponentToPin: SceneComponent,Pin: ARPin): boolean;
	static PinComponentToTraceResult(ComponentToPin: SceneComponent,TraceResult: ARTraceResult,DebugName: string): ARPin;
	static UnpinComponent(ComponentToUnpin: SceneComponent): void;
}

declare type ESceneDepthPriorityGroup = 'SDPG_World' | 'SDPG_Foreground' | 'SDPG_MAX';
declare var ESceneDepthPriorityGroup : { SDPG_World:'SDPG_World',SDPG_Foreground:'SDPG_Foreground',SDPG_MAX:'SDPG_MAX', };
declare type EIndirectLightingCacheQuality = 'ILCQ_Off' | 'ILCQ_Point' | 'ILCQ_Volume' | 'ILCQ_MAX';
declare var EIndirectLightingCacheQuality : { ILCQ_Off:'ILCQ_Off',ILCQ_Point:'ILCQ_Point',ILCQ_Volume:'ILCQ_Volume',ILCQ_MAX:'ILCQ_MAX', };
declare type ELightmapType = 'Default' | 'ForceSurface' | 'ForceVolumetric' | 'ELightmapType_MAX';
declare var ELightmapType : { Default:'Default',ForceSurface:'ForceSurface',ForceVolumetric:'ForceVolumetric',ELightmapType_MAX:'ELightmapType_MAX', };
declare type EHLODBatchingPolicy = 'None' | 'MeshSection' | 'Instancing' | 'EHLODBatchingPolicy_MAX';
declare var EHLODBatchingPolicy : { None:'None',MeshSection:'MeshSection',Instancing:'Instancing',EHLODBatchingPolicy_MAX:'EHLODBatchingPolicy_MAX', };
declare type EHasCustomNavigableGeometry = 'No' | 'Yes' | 'EvenIfNotCollidable' | 'DontExport' | 'EHasCustomNavigableGeometry_MAX';
declare var EHasCustomNavigableGeometry : { No:'No',Yes:'Yes',EvenIfNotCollidable:'EvenIfNotCollidable',DontExport:'DontExport',EHasCustomNavigableGeometry_MAX:'EHasCustomNavigableGeometry_MAX', };
declare type EHitProxyPriority = 'HPP_World' | 'HPP_Wireframe' | 'HPP_Foreground' | 'HPP_UI' | 'HPP_MAX';
declare var EHitProxyPriority : { HPP_World:'HPP_World',HPP_Wireframe:'HPP_Wireframe',HPP_Foreground:'HPP_Foreground',HPP_UI:'HPP_UI',HPP_MAX:'HPP_MAX', };
declare type ECanBeCharacterBase = 'ECB_No' | 'ECB_Yes' | 'ECB_Owner' | 'ECB_MAX';
declare var ECanBeCharacterBase : { ECB_No:'ECB_No',ECB_Yes:'ECB_Yes',ECB_Owner:'ECB_Owner',ECB_MAX:'ECB_MAX', };
declare class LightingChannels { 
	bChannel0: boolean;
	bChannel1: boolean;
	bChannel2: boolean;
	clone() : LightingChannels;
	static C(Other: UObject | any): LightingChannels;
}

declare class CustomPrimitiveData { 
	Data: number[];
	clone() : CustomPrimitiveData;
	static C(Other: UObject | any): CustomPrimitiveData;
}

declare type ERuntimeVirtualTextureMainPassType = 'Never' | 'Exclusive' | 'Always' | 'ERuntimeVirtualTextureMainPassType_MAX';
declare var ERuntimeVirtualTextureMainPassType : { Never:'Never',Exclusive:'Exclusive',Always:'Always',ERuntimeVirtualTextureMainPassType_MAX:'ERuntimeVirtualTextureMainPassType_MAX', };
declare type EComponentPhysicsStateChange = 'Created' | 'Destroyed' | 'EComponentPhysicsStateChange_MAX';
declare var EComponentPhysicsStateChange : { Created:'Created',Destroyed:'Destroyed',EComponentPhysicsStateChange_MAX:'EComponentPhysicsStateChange_MAX', };
declare type ERayTracingGroupCullingPriority = 'CP_0_NEVER_CULL' | 'CP_1' | 'CP_2' | 'CP_3' | 'CP_4_DEFAULT' | 'CP_5' | 'CP_6' | 'CP_7' | 'CP_8_QUICKLY_CULL' | 'CP_MAX';
declare var ERayTracingGroupCullingPriority : { CP_0_NEVER_CULL:'CP_0_NEVER_CULL',CP_1:'CP_1',CP_2:'CP_2',CP_3:'CP_3',CP_4_DEFAULT:'CP_4_DEFAULT',CP_5:'CP_5',CP_6:'CP_6',CP_7:'CP_7',CP_8_QUICKLY_CULL:'CP_8_QUICKLY_CULL',CP_MAX:'CP_MAX', };
declare class BodyInstanceAsyncPhysicsTickHandle { 
	clone() : BodyInstanceAsyncPhysicsTickHandle;
	static C(Other: UObject | any): BodyInstanceAsyncPhysicsTickHandle;
	AddForce(Force: Vector,bAccelChange: boolean): void;
	static AddForce(Handle: BodyInstanceAsyncPhysicsTickHandle,Force: Vector,bAccelChange: boolean): void;
}

declare type ERadialImpulseFalloff = 'RIF_Constant' | 'RIF_Linear' | 'RIF_MAX';
declare var ERadialImpulseFalloff : { RIF_Constant:'RIF_Constant',RIF_Linear:'RIF_Linear',RIF_MAX:'RIF_MAX', };
declare class PrimitiveComponent extends SceneComponent { 
	MinDrawDistance: number;
	LDMaxDrawDistance: number;
	CachedMaxDrawDistance: number;
	DepthPriorityGroup: ESceneDepthPriorityGroup;
	ViewOwnerDepthPriorityGroup: ESceneDepthPriorityGroup;
	IndirectLightingCacheQuality: EIndirectLightingCacheQuality;
	LightmapType: ELightmapType;
	bEnableAutoLODGeneration: boolean;
	ExcludeForSpecificHLODLevels: number[];
	HLODBatchingPolicy: EHLODBatchingPolicy;
	bIsActorTextureStreamingBuiltData: boolean;
	bIsValidTextureStreamingBuiltData: boolean;
	bNeverDistanceCull: boolean;
	bAlwaysCreatePhysicsState: boolean;
	bGenerateOverlapEvents: boolean;
	bMultiBodyOverlap: boolean;
	bTraceComplexOnMove: boolean;
	bReturnMaterialOnMove: boolean;
	bUseViewOwnerDepthPriorityGroup: boolean;
	bAllowCullDistanceVolume: boolean;
	bVisibleInReflectionCaptures: boolean;
	bVisibleInRealTimeSkyCaptures: boolean;
	bVisibleInRayTracing: boolean;
	bRenderInMainPass: boolean;
	bRenderInDepthPass: boolean;
	bReceivesDecals: boolean;
	bOwnerNoSee: boolean;
	bOnlyOwnerSee: boolean;
	bTreatAsBackgroundForOcclusion: boolean;
	bUseAsOccluder: boolean;
	bSelectable: boolean;
	bConsiderForActorPlacementWhenHidden: boolean;
	bForceMipStreaming: boolean;
	bHasPerInstanceHitProxies: boolean;
	CastShadow: boolean;
	bEmissiveLightSource: boolean;
	bAffectDynamicIndirectLighting: boolean;
	bAffectIndirectLightingWhileHidden: boolean;
	bAffectDistanceFieldLighting: boolean;
	bCastDynamicShadow: boolean;
	bCastStaticShadow: boolean;
	bCastVolumetricTranslucentShadow: boolean;
	bCastContactShadow: boolean;
	bSelfShadowOnly: boolean;
	bCastFarShadow: boolean;
	bCastInsetShadow: boolean;
	bCastCinematicShadow: boolean;
	bCastHiddenShadow: boolean;
	bCastShadowAsTwoSided: boolean;
	bLightAsIfStatic: boolean;
	bLightAttachmentsAsGroup: boolean;
	bExcludeFromLightAttachmentGroup: boolean;
	bReceiveMobileCSMShadows: boolean;
	bSingleSampleShadowFromStationaryLights: boolean;
	bIgnoreRadialImpulse: boolean;
	bIgnoreRadialForce: boolean;
	bApplyImpulseOnDamage: boolean;
	bReplicatePhysicsToAutonomousProxy: boolean;
	bFillCollisionUnderneathForNavmesh: boolean;
	AlwaysLoadOnClient: boolean;
	AlwaysLoadOnServer: boolean;
	bUseEditorCompositing: boolean;
	bIsBeingMovedByEditor: boolean;
	bRenderCustomDepth: boolean;
	bVisibleInSceneCaptureOnly: boolean;
	bHiddenInSceneCapture: boolean;
	bRayTracingFarField: boolean;
	bHasNoStreamableTextures: boolean;
	bHasCustomNavigableGeometry: EHasCustomNavigableGeometry;
	HitProxyPriority: EHitProxyPriority;
	CanBeCharacterBase: ECanBeCharacterBase;
	bUseMaxLODAsImposter: boolean;
	bBatchImpostersAsInstances: boolean;
	CanCharacterStepUpOn: ECanBeCharacterBase;
	LightingChannels: LightingChannels;
	RayTracingGroupId: number;
	VisibilityId: number;
	CustomDepthStencilValue: number;
	CustomPrimitiveData: CustomPrimitiveData;
	CustomPrimitiveDataInternal: CustomPrimitiveData;
	TranslucencySortPriority: number;
	TranslucencySortDistanceOffset: number;
	RuntimeVirtualTextures: RuntimeVirtualTexture[];
	VirtualTextureLodBias: number;
	VirtualTextureCullMips: number;
	VirtualTextureMinCoverage: number;
	VirtualTextureRenderPassType: ERuntimeVirtualTextureMainPassType;
	BoundsScale: number;
	MoveIgnoreActors: Actor[];
	MoveIgnoreComponents: PrimitiveComponent[];
	BodyInstance: BodyInstance;
	OnComponentHit: UnrealEngineMulticastDelegate<(HitComponent: PrimitiveComponent, OtherActor: Actor, OtherComp: PrimitiveComponent, NormalImpulse: Vector, Hit: HitResult) => void>;
	OnComponentBeginOverlap: UnrealEngineMulticastDelegate<(OverlappedComponent: PrimitiveComponent, OtherActor: Actor, OtherComp: PrimitiveComponent, OtherBodyIndex: number, bFromSweep: boolean, SweepResult: HitResult) => void>;
	OnComponentEndOverlap: UnrealEngineMulticastDelegate<(OverlappedComponent: PrimitiveComponent, OtherActor: Actor, OtherComp: PrimitiveComponent, OtherBodyIndex: number) => void>;
	OnComponentWake: UnrealEngineMulticastDelegate<(WakingComponent: PrimitiveComponent, BoneName: string) => void>;
	OnComponentSleep: UnrealEngineMulticastDelegate<(SleepingComponent: PrimitiveComponent, BoneName: string) => void>;
	OnComponentPhysicsStateChanged: UnrealEngineMulticastDelegate<(ChangedComponent: PrimitiveComponent, StateChange: EComponentPhysicsStateChange) => void>;
	OnBeginCursorOver: UnrealEngineMulticastDelegate<(TouchedComponent: PrimitiveComponent) => void>;
	OnEndCursorOver: UnrealEngineMulticastDelegate<(TouchedComponent: PrimitiveComponent) => void>;
	OnClicked: UnrealEngineMulticastDelegate<(TouchedComponent: PrimitiveComponent, ButtonPressed: Key) => void>;
	OnReleased: UnrealEngineMulticastDelegate<(TouchedComponent: PrimitiveComponent, ButtonReleased: Key) => void>;
	OnInputTouchBegin: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedComponent: PrimitiveComponent) => void>;
	OnInputTouchEnd: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedComponent: PrimitiveComponent) => void>;
	OnInputTouchEnter: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedComponent: PrimitiveComponent) => void>;
	OnInputTouchLeave: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedComponent: PrimitiveComponent) => void>;
	RayTracingGroupCullingPriority: ERayTracingGroupCullingPriority;
	CustomDepthStencilWriteMask: ERendererStencilMask;
	LODParentPrimitive: PrimitiveComponent;
	static Load(ResourceName: string): PrimitiveComponent;
	static Find(Outer: UObject, ResourceName: string): PrimitiveComponent;
	static GetDefaultObject(): PrimitiveComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PrimitiveComponent;
	WasRecentlyRendered(Tolerance: number): boolean;
	WakeRigidBody(BoneName: string): void;
	WakeAllRigidBodies(): void;
	SetWalkableSlopeOverride(NewOverride: WalkableSlopeOverride): void;
	SetVisibleInSceneCaptureOnly(bValue: boolean): void;
	SetVisibleInRayTracing(bNewVisibleInRayTracing: boolean): void;
	SetVectorParameterForDefaultCustomPrimitiveData(ParameterName: string,Value: Vector4): void;
	SetVectorParameterForCustomPrimitiveData(ParameterName: string,Value: Vector4): void;
	SetUseCCD(InUseCCD: boolean,BoneName: string): void;
	SetTranslucentSortPriority(NewTranslucentSortPriority: number): void;
	SetTranslucencySortDistanceOffset(NewTranslucencySortDistanceOffset: number): void;
	SetSingleSampleShadowFromStationaryLights(bNewSingleSampleShadowFromStationaryLights: boolean): void;
	SetSimulatePhysics(bSimulate: boolean): void;
	SetScalarParameterForDefaultCustomPrimitiveData(ParameterName: string,Value: number): void;
	SetScalarParameterForCustomPrimitiveData(ParameterName: string,Value: number): void;
	SetRenderInMainPass(bValue: boolean): void;
	SetRenderInDepthPass(bValue: boolean): void;
	SetRenderCustomDepth(bValue: boolean): void;
	SetReceivesDecals(bNewReceivesDecals: boolean): void;
	SetPhysMaterialOverride(NewPhysMaterial: PhysicalMaterial): void;
	SetPhysicsMaxAngularVelocityInRadians(NewMaxAngVel: number,bAddToCurrent: boolean,BoneName: string): void;
	SetPhysicsMaxAngularVelocityInDegrees(NewMaxAngVel: number,bAddToCurrent: boolean,BoneName: string): void;
	SetPhysicsLinearVelocity(NewVel: Vector,bAddToCurrent: boolean,BoneName: string): void;
	SetPhysicsAngularVelocityInRadians(NewAngVel: Vector,bAddToCurrent: boolean,BoneName: string): void;
	SetPhysicsAngularVelocityInDegrees(NewAngVel: Vector,bAddToCurrent: boolean,BoneName: string): void;
	SetOwnerNoSee(bNewOwnerNoSee: boolean): void;
	SetOnlyOwnerSee(bNewOnlyOwnerSee: boolean): void;
	SetNotifyRigidBodyCollision(bNewNotifyRigidBodyCollision: boolean): void;
	SetMaterialByName(MaterialSlotName: string,Material: MaterialInterface): void;
	SetMaterial(ElementIndex: number,Material: MaterialInterface): void;
	SetMassScale(BoneName: string,InMassScale: number): void;
	SetMassOverrideInKg(BoneName: string,MassInKg: number,bOverrideMass: boolean): void;
	SetLinearDamping(InDamping: number): void;
	SetLightingChannels(bChannel0: boolean,bChannel1: boolean,bChannel2: boolean): void;
	SetLightAttachmentsAsGroup(bInLightAttachmentsAsGroup: boolean): void;
	SetHiddenInSceneCapture(bValue: boolean): void;
	SetGenerateOverlapEvents(bInGenerateOverlapEvents: boolean): void;
	SetExcludeFromLightAttachmentGroup(bInExcludeFromLightAttachmentGroup: boolean): void;
	SetEnableGravity(bGravityEnabled: boolean): void;
	SetEmissiveLightSource(NewEmissiveLightSource: boolean): void;
	SetDefaultCustomPrimitiveDataVector4(DataIndex: number,Value: Vector4): void;
	SetDefaultCustomPrimitiveDataVector3(DataIndex: number,Value: Vector): void;
	SetDefaultCustomPrimitiveDataVector2(DataIndex: number,Value: Vector2D): void;
	SetDefaultCustomPrimitiveDataFloat(DataIndex: number,Value: number): void;
	SetCustomPrimitiveDataVector4(DataIndex: number,Value: Vector4): void;
	SetCustomPrimitiveDataVector3(DataIndex: number,Value: Vector): void;
	SetCustomPrimitiveDataVector2(DataIndex: number,Value: Vector2D): void;
	SetCustomPrimitiveDataFloat(DataIndex: number,Value: number): void;
	SetCustomDepthStencilWriteMask(WriteMaskBit: ERendererStencilMask): void;
	SetCustomDepthStencilValue(Value: number): void;
	SetCullDistance(NewCullDistance: number): void;
	SetConstraintMode(ConstraintMode: EDOFMode): void;
	SetCollisionResponseToChannel(Channel: ECollisionChannel,NewResponse: ECollisionResponse): void;
	SetCollisionResponseToAllChannels(NewResponse: ECollisionResponse): void;
	SetCollisionProfileName(InCollisionProfileName: string,bUpdateOverlaps: boolean): void;
	SetCollisionObjectType(Channel: ECollisionChannel): void;
	SetCollisionEnabled(NewType: ECollisionEnabled): void;
	SetCenterOfMass(CenterOfMassOffset: Vector,BoneName: string): void;
	SetCastShadow(NewCastShadow: boolean): void;
	SetCastInsetShadow(bInCastInsetShadow: boolean): void;
	SetCastHiddenShadow(NewCastHiddenShadow: boolean): void;
	SetCastContactShadow(bInCastContactShadow: boolean): void;
	SetBoundsScale(NewBoundsScale: number): void;
	SetAngularDamping(InDamping: number): void;
	SetAllUseCCD(InUseCCD: boolean): void;
	SetAllPhysicsLinearVelocity(NewVel: Vector,bAddToCurrent: boolean): void;
	SetAllPhysicsAngularVelocityInRadians(NewAngVel: Vector,bAddToCurrent: boolean): void;
	SetAllPhysicsAngularVelocityInDegrees(NewAngVel: Vector,bAddToCurrent: boolean): void;
	SetAllMassScale(InMassScale: number): void;
	ScaleByMomentOfInertia(InputVector: Vector,BoneName: string): Vector;
	PutRigidBodyToSleep(BoneName: string): void;
	K2_SphereTraceComponent(TraceStart: Vector,TraceEnd: Vector,SphereRadius: number,bTraceComplex: boolean,bShowTrace: boolean,bPersistentShowTrace: boolean,HitLocation?: Vector,HitNormal?: Vector,BoneName?: string,OutHit?: HitResult): {HitLocation: Vector, HitNormal: Vector, BoneName: string, OutHit: HitResult, $: boolean};
	K2_SphereOverlapComponent(InSphereCentre: Vector,InSphereRadius: number,bTraceComplex: boolean,bShowTrace: boolean,bPersistentShowTrace: boolean,HitLocation?: Vector,HitNormal?: Vector,BoneName?: string,OutHit?: HitResult): {HitLocation: Vector, HitNormal: Vector, BoneName: string, OutHit: HitResult, $: boolean};
	K2_LineTraceComponent(TraceStart: Vector,TraceEnd: Vector,bTraceComplex: boolean,bShowTrace: boolean,bPersistentShowTrace: boolean,HitLocation?: Vector,HitNormal?: Vector,BoneName?: string,OutHit?: HitResult): {HitLocation: Vector, HitNormal: Vector, BoneName: string, OutHit: HitResult, $: boolean};
	K2_IsQueryCollisionEnabled(): boolean;
	K2_IsPhysicsCollisionEnabled(): boolean;
	K2_IsCollisionEnabled(): boolean;
	K2_BoxOverlapComponent(InBoxCentre: Vector,InBox: Box,bTraceComplex: boolean,bShowTrace: boolean,bPersistentShowTrace: boolean,HitLocation?: Vector,HitNormal?: Vector,BoneName?: string,OutHit?: HitResult): {HitLocation: Vector, HitNormal: Vector, BoneName: string, OutHit: HitResult, $: boolean};
	IsOverlappingComponent(OtherComp: PrimitiveComponent): boolean;
	IsOverlappingActor(Other: Actor): boolean;
	IsGravityEnabled(): boolean;
	IsAnyRigidBodyAwake(): boolean;
	InvalidateLumenSurfaceCache(): void;
	IgnoreComponentWhenMoving(Component: PrimitiveComponent,bShouldIgnore: boolean): void;
	IgnoreActorWhenMoving(Actor: Actor,bShouldIgnore: boolean): void;
	GetWalkableSlopeOverride(): WalkableSlopeOverride;
	GetPhysicsLinearVelocityAtPoint(Point: Vector,BoneName: string): Vector;
	GetPhysicsLinearVelocity(BoneName: string): Vector;
	GetPhysicsAngularVelocityInRadians(BoneName: string): Vector;
	GetPhysicsAngularVelocityInDegrees(BoneName: string): Vector;
	GetOverlappingComponents(OutOverlappingComponents?: PrimitiveComponent[]): {OutOverlappingComponents: PrimitiveComponent[]};
	GetOverlappingActors(OverlappingActors?: Actor[],ClassFilter?: UnrealEngineClass): {OverlappingActors: Actor[]};
	GetNumMaterials(): number;
	GetMaterialFromCollisionFaceIndex(FaceIndex: number,SectionIndex?: number): {SectionIndex: number, $: MaterialInterface};
	GetMaterial(ElementIndex: number): MaterialInterface;
	GetMassScale(BoneName: string): number;
	GetMass(): number;
	GetLinearDamping(): number;
	GetInertiaTensor(BoneName: string): Vector;
	GetGenerateOverlapEvents(): boolean;
	GetCustomPrimitiveDataIndexForVectorParameter(ParameterName: string): number;
	GetCustomPrimitiveDataIndexForScalarParameter(ParameterName: string): number;
	GetCollisionResponseToChannel(Channel: ECollisionChannel): ECollisionResponse;
	GetCollisionProfileName(): string;
	GetCollisionObjectType(): ECollisionChannel;
	GetCollisionEnabled(): ECollisionEnabled;
	GetClosestPointOnCollision(Point: Vector,OutPointOnBody?: Vector,BoneName?: string): {OutPointOnBody: Vector, $: number};
	GetCenterOfMass(BoneName: string): Vector;
	GetBodyInstanceAsyncPhysicsTickHandle(BoneName: string,bGetWelded: boolean,Index: number): BodyInstanceAsyncPhysicsTickHandle;
	GetAngularDamping(): number;
	CreateDynamicMaterialInstance(ElementIndex: number,SourceMaterial: MaterialInterface,OptionalName: string): MaterialInstanceDynamic;
	CreateAndSetMaterialInstanceDynamicFromMaterial(ElementIndex: number,Parent: MaterialInterface): MaterialInstanceDynamic;
	CreateAndSetMaterialInstanceDynamic(ElementIndex: number): MaterialInstanceDynamic;
	CopyArrayOfMoveIgnoreComponents(): PrimitiveComponent[];
	CopyArrayOfMoveIgnoreActors(): Actor[];
	ClearMoveIgnoreComponents(): void;
	ClearMoveIgnoreActors(): void;
	CanCharacterStepUp(Pawn: Pawn): boolean;
	AddVelocityChangeImpulseAtLocation(Impulse: Vector,Location: Vector,BoneName: string): void;
	AddTorqueInRadians(Torque: Vector,BoneName: string,bAccelChange: boolean): void;
	AddTorqueInDegrees(Torque: Vector,BoneName: string,bAccelChange: boolean): void;
	AddRadialImpulse(Origin: Vector,Radius: number,Strength: number,Falloff: ERadialImpulseFalloff,bVelChange: boolean): void;
	AddRadialForce(Origin: Vector,Radius: number,Strength: number,Falloff: ERadialImpulseFalloff,bAccelChange: boolean): void;
	AddImpulseAtLocation(Impulse: Vector,Location: Vector,BoneName: string): void;
	AddImpulse(Impulse: Vector,BoneName: string,bVelChange: boolean): void;
	AddForceAtLocationLocal(Force: Vector,Location: Vector,BoneName: string): void;
	AddForceAtLocation(Force: Vector,Location: Vector,BoneName: string): void;
	AddForce(Force: Vector,BoneName: string,bAccelChange: boolean): void;
	AddAngularImpulseInRadians(Impulse: Vector,BoneName: string,bVelChange: boolean): void;
	AddAngularImpulseInDegrees(Impulse: Vector,BoneName: string,bVelChange: boolean): void;
	static C(Other: UObject | any): PrimitiveComponent;
	ComponentOverlapActors(ComponentTransform: Transform,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	ComponentOverlapComponents(ComponentTransform: Transform,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	SetCastInsetShadowForAllAttachments(bCastInsetShadow: boolean,bLightAttachmentsAsGroup: boolean): void;
	static ComponentOverlapActors(Component: PrimitiveComponent,ComponentTransform: Transform,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	static ComponentOverlapComponents(Component: PrimitiveComponent,ComponentTransform: Transform,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	static SetCastInsetShadowForAllAttachments(PrimitiveComponent: PrimitiveComponent,bCastInsetShadow: boolean,bLightAttachmentsAsGroup: boolean): void;
}

declare class MRMeshBodyHolder extends UObject { 
	BodySetup: BodySetup;
	BodyInstance: BodyInstance;
	static Load(ResourceName: string): MRMeshBodyHolder;
	static Find(Outer: UObject, ResourceName: string): MRMeshBodyHolder;
	static GetDefaultObject(): MRMeshBodyHolder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MRMeshBodyHolder;
	static C(Other: UObject | any): MRMeshBodyHolder;
}

declare class MRMeshComponent extends PrimitiveComponent { 
	Material: MaterialInterface;
	WireframeMaterial: MaterialInterface;
	bCreateMeshProxySections: boolean;
	bUpdateNavMeshOnMeshUpdate: boolean;
	bNeverCreateCollisionMesh: boolean;
	BodyHolders: MRMeshBodyHolder[];
	static Load(ResourceName: string): MRMeshComponent;
	static Find(Outer: UObject, ResourceName: string): MRMeshComponent;
	static GetDefaultObject(): MRMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MRMeshComponent;
	SetWireframeMaterial(InMaterial: MaterialInterface): void;
	SetWireframeColor(InColor: LinearColor): void;
	SetUseWireframe(bUseWireframe: boolean): void;
	SetEnableMeshOcclusion(bEnable: boolean): void;
	RequestNavMeshUpdate(): void;
	IsConnected(): boolean;
	GetWireframeColor(): LinearColor;
	GetUseWireframe(): boolean;
	GetEnableMeshOcclusion(): boolean;
	ForceNavMeshUpdate(): void;
	Clear(): void;
	static C(Other: UObject | any): MRMeshComponent;
}

declare type EARObjectClassification = 'NotApplicable' | 'Unknown' | 'Wall' | 'Ceiling' | 'Floor' | 'Table' | 'Seat' | 'Face' | 'Image' | 'World' | 'SceneObject' | 'HandMesh' | 'Door' | 'Window' | 'EARObjectClassification_MAX';
declare var EARObjectClassification : { NotApplicable:'NotApplicable',Unknown:'Unknown',Wall:'Wall',Ceiling:'Ceiling',Floor:'Floor',Table:'Table',Seat:'Seat',Face:'Face',Image:'Image',World:'World',SceneObject:'SceneObject',HandMesh:'HandMesh',Door:'Door',Window:'Window',EARObjectClassification_MAX:'EARObjectClassification_MAX', };
declare type EARSpatialMeshUsageFlags = 'NotApplicable' | 'Visible' | 'Collision' | 'EARSpatialMeshUsageFlags_MAX';
declare var EARSpatialMeshUsageFlags : { NotApplicable:'NotApplicable',Visible:'Visible',Collision:'Collision',EARSpatialMeshUsageFlags_MAX:'EARSpatialMeshUsageFlags_MAX', };
declare class ARTrackedGeometry extends UObject { 
	UniqueId: Guid;
	LocalToTrackingTransform: Transform;
	LocalToAlignedTrackingTransform: Transform;
	TrackingState: EARTrackingState;
	UnderlyingMesh: MRMeshComponent;
	ObjectClassification: EARObjectClassification;
	SpatialMeshUsageFlags: EARSpatialMeshUsageFlags;
	LastUpdateFrameNumber: number;
	DebugName: string;
	static Load(ResourceName: string): ARTrackedGeometry;
	static Find(Outer: UObject, ResourceName: string): ARTrackedGeometry;
	static GetDefaultObject(): ARTrackedGeometry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTrackedGeometry;
	IsTracked(): boolean;
	HasSpatialMeshUsageFlag(InFlag: EARSpatialMeshUsageFlags): boolean;
	GetUnderlyingMesh(): MRMeshComponent;
	GetTrackingState(): EARTrackingState;
	GetObjectClassification(): EARObjectClassification;
	GetName(): string;
	GetLocalToWorldTransform(): Transform;
	GetLocalToTrackingTransform(): Transform;
	GetLastUpdateTimestamp(): number;
	GetLastUpdateFrameNumber(): number;
	GetDebugName(): string;
	static C(Other: UObject | any): ARTrackedGeometry;
	DebugDrawTrackedGeometry(WorldContextObject: UObject,Color: LinearColor,OutlineThickness: number,PersistForSeconds: number): void;
	static DebugDrawTrackedGeometry(TrackedGeometry: ARTrackedGeometry,WorldContextObject: UObject,Color: LinearColor,OutlineThickness: number,PersistForSeconds: number): void;
}

declare class ARTraceResult { 
	DistanceFromCamera: number;
	TraceChannel: EARLineTraceChannels;
	LocalTransform: Transform;
	TrackedGeometry: ARTrackedGeometry;
	clone() : ARTraceResult;
	static C(Other: UObject | any): ARTraceResult;
	GetDistanceFromCamera(): number;
	GetLocalToTrackingTransform(): Transform;
	GetLocalToWorldTransform(): Transform;
	GetLocalTransform(): Transform;
	GetTraceChannel(): EARLineTraceChannels;
	GetTrackedGeometry(): ARTrackedGeometry;
	static GetDistanceFromCamera(TraceResult: ARTraceResult): number;
	static GetLocalToTrackingTransform(TraceResult: ARTraceResult): Transform;
	static GetLocalToWorldTransform(TraceResult: ARTraceResult): Transform;
	static GetLocalTransform(TraceResult: ARTraceResult): Transform;
	static GetTraceChannel(TraceResult: ARTraceResult): EARLineTraceChannels;
	static GetTrackedGeometry(TraceResult: ARTraceResult): ARTrackedGeometry;
}

declare type EHMDTrackingOrigin = 'Floor' | 'Eye' | 'Stage' | 'EHMDTrackingOrigin_MAX';
declare var EHMDTrackingOrigin : { Floor:'Floor',Eye:'Eye',Stage:'Stage',EHMDTrackingOrigin_MAX:'EHMDTrackingOrigin_MAX', };
declare class Vector2D { 
	X: number;
	Y: number;
	clone() : Vector2D;
	static C(Other: UObject | any): Vector2D;
	Conv_Vector2dToString(): string;
	Add_Vector2DFloat(B: number): Vector2D;
	Add_Vector2DVector2D(B: Vector2D): Vector2D;
	BreakVector2D(X?: number,Y?: number): {X: number, Y: number};
	ClampAxes2D(MinAxisVal: number,MaxAxisVal: number): Vector2D;
	Conv_Vector2DToIntPoint(): IntPoint;
	Conv_Vector2DToVector(Z: number): Vector;
	CrossProduct2D(B: Vector2D): number;
	Distance2D(v2: Vector2D): number;
	DistanceSquared2D(v2: Vector2D): number;
	Divide_Vector2DFloat(B: number): Vector2D;
	Divide_Vector2DVector2D(B: Vector2D): Vector2D;
	DotProduct2D(B: Vector2D): number;
	EqualEqual_Vector2DVector2D(B: Vector2D,ErrorTolerance: number): boolean;
	EqualExactly_Vector2DVector2D(B: Vector2D): boolean;
	GetAbs2D(): Vector2D;
	GetAbsMax2D(): number;
	GetMax2D(): number;
	GetMin2D(): number;
	GetRotated2D(AngleDeg: number): Vector2D;
	IsNearlyZero2D(Tolerance: number): boolean;
	IsZero2D(): boolean;
	MakeBox2D(Max: Vector2D): Box2D;
	Multiply_Vector2DFloat(B: number): Vector2D;
	Multiply_Vector2DVector2D(B: Vector2D): Vector2D;
	Negated2D(): Vector2D;
	Normal2D(): Vector2D;
	Normalize2D(Tolerance?: number): {A: Vector2D};
	NormalSafe2D(Tolerance: number): Vector2D;
	NotEqual_Vector2DVector2D(B: Vector2D,ErrorTolerance: number): boolean;
	NotEqualExactly_Vector2DVector2D(B: Vector2D): boolean;
	Set2D(X?: number,Y?: number): {A: Vector2D};
	Spherical2DToUnitCartesian(): Vector;
	Subtract_Vector2DFloat(B: number): Vector2D;
	Subtract_Vector2DVector2D(B: Vector2D): Vector2D;
	ToDirectionAndLength2D(OutDir?: Vector2D,OutLength?: number): {OutDir: Vector2D, OutLength: number};
	ToRounded2D(): Vector2D;
	ToSign2D(): Vector2D;
	Vector2DInterpTo(Target: Vector2D,DeltaTime: number,InterpSpeed: number): Vector2D;
	Vector2DInterpTo_Constant(Target: Vector2D,DeltaTime: number,InterpSpeed: number): Vector2D;
	VSize2D(): number;
	VSize2DSquared(): number;
	Conv_Vector2dToText(): string;
	SetSpectatorScreenModeTexturePlusEyeLayout(EyeRectMax: Vector2D,TextureRectMin: Vector2D,TextureRectMax: Vector2D,bDrawEyeFirst: boolean,bClearBlack: boolean,bUseAlpha: boolean): void;
	LineTraceTrackedObjects(bTestFeaturePoints: boolean,bTestGroundPlane: boolean,bTestPlaneExtents: boolean,bTestPlaneBoundaryPolygon: boolean): ARTraceResult[];
	static Conv_Vector2dToString(InVec: Vector2D): string;
	static Add_Vector2DFloat(A: Vector2D,B: number): Vector2D;
	static Add_Vector2DVector2D(A: Vector2D,B: Vector2D): Vector2D;
	static BreakVector2D(InVec: Vector2D,X?: number,Y?: number): {X: number, Y: number};
	static ClampAxes2D(A: Vector2D,MinAxisVal: number,MaxAxisVal: number): Vector2D;
	static Conv_Vector2DToIntPoint(InVector2D: Vector2D): IntPoint;
	static Conv_Vector2DToVector(InVector2D: Vector2D,Z: number): Vector;
	static CrossProduct2D(A: Vector2D,B: Vector2D): number;
	static Distance2D(v1: Vector2D,v2: Vector2D): number;
	static DistanceSquared2D(v1: Vector2D,v2: Vector2D): number;
	static Divide_Vector2DFloat(A: Vector2D,B: number): Vector2D;
	static Divide_Vector2DVector2D(A: Vector2D,B: Vector2D): Vector2D;
	static DotProduct2D(A: Vector2D,B: Vector2D): number;
	static EqualEqual_Vector2DVector2D(A: Vector2D,B: Vector2D,ErrorTolerance: number): boolean;
	static EqualExactly_Vector2DVector2D(A: Vector2D,B: Vector2D): boolean;
	static GetAbs2D(A: Vector2D): Vector2D;
	static GetAbsMax2D(A: Vector2D): number;
	static GetMax2D(A: Vector2D): number;
	static GetMin2D(A: Vector2D): number;
	static GetRotated2D(A: Vector2D,AngleDeg: number): Vector2D;
	static IsNearlyZero2D(A: Vector2D,Tolerance: number): boolean;
	static IsZero2D(A: Vector2D): boolean;
	static MakeBox2D(Min: Vector2D,Max: Vector2D): Box2D;
	static Multiply_Vector2DFloat(A: Vector2D,B: number): Vector2D;
	static Multiply_Vector2DVector2D(A: Vector2D,B: Vector2D): Vector2D;
	static Negated2D(A: Vector2D): Vector2D;
	static Normal2D(A: Vector2D): Vector2D;
	static Normalize2D(A?: Vector2D,Tolerance?: number): {A: Vector2D};
	static NormalSafe2D(A: Vector2D,Tolerance: number): Vector2D;
	static NotEqual_Vector2DVector2D(A: Vector2D,B: Vector2D,ErrorTolerance: number): boolean;
	static NotEqualExactly_Vector2DVector2D(A: Vector2D,B: Vector2D): boolean;
	static Set2D(A?: Vector2D,X?: number,Y?: number): {A: Vector2D};
	static Spherical2DToUnitCartesian(A: Vector2D): Vector;
	static Subtract_Vector2DFloat(A: Vector2D,B: number): Vector2D;
	static Subtract_Vector2DVector2D(A: Vector2D,B: Vector2D): Vector2D;
	static ToDirectionAndLength2D(A: Vector2D,OutDir?: Vector2D,OutLength?: number): {OutDir: Vector2D, OutLength: number};
	static ToRounded2D(A: Vector2D): Vector2D;
	static ToSign2D(A: Vector2D): Vector2D;
	static Vector2DInterpTo(Current: Vector2D,Target: Vector2D,DeltaTime: number,InterpSpeed: number): Vector2D;
	static Vector2DInterpTo_Constant(Current: Vector2D,Target: Vector2D,DeltaTime: number,InterpSpeed: number): Vector2D;
	static VSize2D(A: Vector2D): number;
	static VSize2DSquared(A: Vector2D): number;
	static Conv_Vector2dToText(InVec: Vector2D): string;
	static SetSpectatorScreenModeTexturePlusEyeLayout(EyeRectMin: Vector2D,EyeRectMax: Vector2D,TextureRectMin: Vector2D,TextureRectMax: Vector2D,bDrawEyeFirst: boolean,bClearBlack: boolean,bUseAlpha: boolean): void;
	static LineTraceTrackedObjects(ScreenCoord: Vector2D,bTestFeaturePoints: boolean,bTestGroundPlane: boolean,bTestPlaneExtents: boolean,bTestPlaneBoundaryPolygon: boolean): ARTraceResult[];
	static GenerateDynamicImageResource(InDynamicBrushName: string): Vector2D;
	static MakeVector2D(X: number,Y: number): Vector2D;
	static Vector2D_One(): Vector2D;
	static Vector2D_Unit45Deg(): Vector2D;
	static Vector2D_Zero(): Vector2D;
	static NextSobolCell2D(Index: number,NumCells: number,PreviousValue: Vector2D): Vector2D;
	static RandomSobolCell2D(Index: number,NumCells: number,Cell: Vector2D,Seed: Vector2D): Vector2D;
	static GetMousePositionOnPlatform(): Vector2D;
	static GetPlayAreaBounds(Origin: EHMDTrackingOrigin): Vector2D;
}

declare class Transform { 
	Rotation: Quat;
	Translation: Vector;
	Scale3D: Vector;
	clone() : Transform;
	static C(Other: UObject | any): Transform;
	GetDesiredValue(LastBoneTransform: Transform,DeltaTime: number,MotionType: EMotionExtractor_MotionType,Axis: EMotionExtractor_Axis): number;
	Conv_TransformToString(): string;
	BreakTransform(Location?: Vector,Rotation?: Rotator,Scale?: Vector): {Location: Vector, Rotation: Rotator, Scale: Vector};
	ComposeTransforms(B: Transform): Transform;
	Conv_TransformToMatrix(): Matrix;
	ConvertTransformToRelative(ParentTransform: Transform): Transform;
	EqualEqual_TransformTransform(B: Transform): boolean;
	FindRelativeLookAtRotation(TargetLocation: Vector): Rotator;
	InverseTransformDirection(Direction: Vector): Vector;
	InverseTransformLocation(Location: Vector): Vector;
	InverseTransformRotation(Rotation: Rotator): Rotator;
	InvertTransform(): Transform;
	MakeRelativeTransform(RelativeTo: Transform): Transform;
	NearlyEqual_TransformTransform(B: Transform,LocationTolerance: number,RotationTolerance: number,Scale3DTolerance: number): boolean;
	SelectTransform(B: Transform,bPickA: boolean): Transform;
	TEase(B: Transform,Alpha: number,EasingFunc: EEasingFunc,BlendExp: number,Steps: number): Transform;
	TInterpTo(Target: Transform,DeltaTime: number,InterpSpeed: number): Transform;
	TLerp(B: Transform,Alpha: number,InterpMode: ELerpInterpolationMode): Transform;
	Transform_Determinant(): number;
	TransformDirection(Direction: Vector): Vector;
	TransformLocation(Location: Vector): Vector;
	TransformRotation(Rotation: Rotator): Rotator;
	Conv_TransformToText(): string;
	K2_LookAt(TargetPosition: Vector,LookAtVector: Vector,bUseUpVector: boolean,UpVector: Vector,ClampConeInDegree: number): Transform;
	CalibrateExternalTrackingToHMD(): void;
	GetPlayAreaRect(OutRect?: Vector2D): {OutTransform: Transform, OutRect: Vector2D, $: boolean};
	UpdateExternalTrackingHMDPosition(): void;
	AddTrackedPointWithName(PointName: string,bDeletePointsWithSameName: boolean): boolean;
	CalculateAlignmentTransform(TransformInSecondCoordinateSystem: Transform,AlignmentTransform?: Transform): {AlignmentTransform: Transform};
	SetAlignmentTransform(): void;
	static GetDesiredValue(BoneTransform: Transform,LastBoneTransform: Transform,DeltaTime: number,MotionType: EMotionExtractor_MotionType,Axis: EMotionExtractor_Axis): number;
	static Conv_TransformToString(InTrans: Transform): string;
	static BreakTransform(InTransform: Transform,Location?: Vector,Rotation?: Rotator,Scale?: Vector): {Location: Vector, Rotation: Rotator, Scale: Vector};
	static ComposeTransforms(A: Transform,B: Transform): Transform;
	static Conv_TransformToMatrix(Transform: Transform): Matrix;
	static ConvertTransformToRelative(Transform: Transform,ParentTransform: Transform): Transform;
	static EqualEqual_TransformTransform(A: Transform,B: Transform): boolean;
	static FindRelativeLookAtRotation(StartTransform: Transform,TargetLocation: Vector): Rotator;
	static InverseTransformDirection(T: Transform,Direction: Vector): Vector;
	static InverseTransformLocation(T: Transform,Location: Vector): Vector;
	static InverseTransformRotation(T: Transform,Rotation: Rotator): Rotator;
	static InvertTransform(T: Transform): Transform;
	static MakeRelativeTransform(A: Transform,RelativeTo: Transform): Transform;
	static NearlyEqual_TransformTransform(A: Transform,B: Transform,LocationTolerance: number,RotationTolerance: number,Scale3DTolerance: number): boolean;
	static SelectTransform(A: Transform,B: Transform,bPickA: boolean): Transform;
	static TEase(A: Transform,B: Transform,Alpha: number,EasingFunc: EEasingFunc,BlendExp: number,Steps: number): Transform;
	static TInterpTo(Current: Transform,Target: Transform,DeltaTime: number,InterpSpeed: number): Transform;
	static TLerp(A: Transform,B: Transform,Alpha: number,InterpMode: ELerpInterpolationMode): Transform;
	static Transform_Determinant(Transform: Transform): number;
	static TransformDirection(T: Transform,Direction: Vector): Vector;
	static TransformLocation(T: Transform,Location: Vector): Vector;
	static TransformRotation(T: Transform,Rotation: Rotator): Rotator;
	static Conv_TransformToText(InTrans: Transform): string;
	static K2_LookAt(CurrentTransform: Transform,TargetPosition: Vector,LookAtVector: Vector,bUseUpVector: boolean,UpVector: Vector,ClampConeInDegree: number): Transform;
	static CalibrateExternalTrackingToHMD(ExternalTrackingTransform: Transform): void;
	static GetPlayAreaRect(OutTransform?: Transform,OutRect?: Vector2D): {OutTransform: Transform, OutRect: Vector2D, $: boolean};
	static UpdateExternalTrackingHMDPosition(ExternalTrackingTransform: Transform): void;
	static AddTrackedPointWithName(WorldTransform: Transform,PointName: string,bDeletePointsWithSameName: boolean): boolean;
	static CalculateAlignmentTransform(TransformInFirstCoordinateSystem: Transform,TransformInSecondCoordinateSystem: Transform,AlignmentTransform?: Transform): {AlignmentTransform: Transform};
	static SetAlignmentTransform(InAlignmentTransform: Transform): void;
	static GetAlignmentTransform(): Transform;
}

declare class Rotator { 
	Pitch: number;
	Yaw: number;
	Roll: number;
	clone() : Rotator;
	static C(Other: UObject | any): Rotator;
	Conv_RotatorToString(): string;
	BreakRotator(Roll?: number,Pitch?: number,Yaw?: number): {Roll: number, Pitch: number, Yaw: number};
	BreakRotIntoAxes(X?: Vector,Y?: Vector,Z?: Vector): {X: Vector, Y: Vector, Z: Vector};
	ComposeRotators(B: Rotator): Rotator;
	Conv_RotatorToQuaternion(): Quat;
	Conv_RotatorToTransform(): Transform;
	Conv_RotatorToVector(): Vector;
	DynamicWeightedMovingAverage_FRotator(PreviousSample: Rotator,MaxDistance: number,MinWeight: number,MaxWeight: number): Rotator;
	EqualEqual_RotatorRotator(B: Rotator,ErrorTolerance: number): boolean;
	GetAxes(X?: Vector,Y?: Vector,Z?: Vector): {X: Vector, Y: Vector, Z: Vector};
	GetForwardVector(): Vector;
	GetRightVector(): Vector;
	GetUpVector(): Vector;
	Multiply_RotatorFloat(B: number): Rotator;
	Multiply_RotatorInt(B: number): Rotator;
	NegateRotator(): Rotator;
	NormalizedDeltaRotator(B: Rotator): Rotator;
	NotEqual_RotatorRotator(B: Rotator,ErrorTolerance: number): boolean;
	REase(B: Rotator,Alpha: number,bShortestPath: boolean,EasingFunc: EEasingFunc,BlendExp: number,Steps: number): Rotator;
	RInterpTo(Target: Rotator,DeltaTime: number,InterpSpeed: number): Rotator;
	RInterpTo_Constant(Target: Rotator,DeltaTime: number,InterpSpeed: number): Rotator;
	RLerp(B: Rotator,Alpha: number,bShortestPath: boolean): Rotator;
	SelectRotator(B: Rotator,bPickA: boolean): Rotator;
	WeightedMovingAverage_FRotator(PreviousSample: Rotator,Weight: number): Rotator;
	Conv_RotatorToText(): string;
	IsValidAIRotation(): boolean;
	GetOrientationAndPosition(DevicePosition?: Vector): {DeviceRotation: Rotator, DevicePosition: Vector};
	static Conv_RotatorToString(InRot: Rotator): string;
	static BreakRotator(InRot: Rotator,Roll?: number,Pitch?: number,Yaw?: number): {Roll: number, Pitch: number, Yaw: number};
	static BreakRotIntoAxes(InRot: Rotator,X?: Vector,Y?: Vector,Z?: Vector): {X: Vector, Y: Vector, Z: Vector};
	static ComposeRotators(A: Rotator,B: Rotator): Rotator;
	static Conv_RotatorToQuaternion(InRot: Rotator): Quat;
	static Conv_RotatorToTransform(InRotator: Rotator): Transform;
	static Conv_RotatorToVector(InRot: Rotator): Vector;
	static DynamicWeightedMovingAverage_FRotator(CurrentSample: Rotator,PreviousSample: Rotator,MaxDistance: number,MinWeight: number,MaxWeight: number): Rotator;
	static EqualEqual_RotatorRotator(A: Rotator,B: Rotator,ErrorTolerance: number): boolean;
	static GetAxes(A: Rotator,X?: Vector,Y?: Vector,Z?: Vector): {X: Vector, Y: Vector, Z: Vector};
	static GetForwardVector(InRot: Rotator): Vector;
	static GetRightVector(InRot: Rotator): Vector;
	static GetUpVector(InRot: Rotator): Vector;
	static Multiply_RotatorFloat(A: Rotator,B: number): Rotator;
	static Multiply_RotatorInt(A: Rotator,B: number): Rotator;
	static NegateRotator(A: Rotator): Rotator;
	static NormalizedDeltaRotator(A: Rotator,B: Rotator): Rotator;
	static NotEqual_RotatorRotator(A: Rotator,B: Rotator,ErrorTolerance: number): boolean;
	static REase(A: Rotator,B: Rotator,Alpha: number,bShortestPath: boolean,EasingFunc: EEasingFunc,BlendExp: number,Steps: number): Rotator;
	static RInterpTo(Current: Rotator,Target: Rotator,DeltaTime: number,InterpSpeed: number): Rotator;
	static RInterpTo_Constant(Current: Rotator,Target: Rotator,DeltaTime: number,InterpSpeed: number): Rotator;
	static RLerp(A: Rotator,B: Rotator,Alpha: number,bShortestPath: boolean): Rotator;
	static SelectRotator(A: Rotator,B: Rotator,bPickA: boolean): Rotator;
	static WeightedMovingAverage_FRotator(CurrentSample: Rotator,PreviousSample: Rotator,Weight: number): Rotator;
	static Conv_RotatorToText(InRot: Rotator): string;
	static IsValidAIRotation(Rotation: Rotator): boolean;
	static GetOrientationAndPosition(DeviceRotation?: Rotator,DevicePosition?: Vector): {DeviceRotation: Rotator, DevicePosition: Vector};
	static MakeRotator(Roll: number,Pitch: number,Yaw: number): Rotator;
	static RandomRotator(bRoll: boolean): Rotator;
	static RandomRotatorFromStream(bRoll: boolean,Stream: RandomStream): Rotator;
}

declare class VectorSpringState { 
	clone() : VectorSpringState;
	static C(Other: UObject | any): VectorSpringState;
	ResetVectorSpringState(): {SpringState: VectorSpringState};
	SetVectorSpringStateVelocity(Velocity?: Vector): {SpringState: VectorSpringState};
	static ResetVectorSpringState(SpringState?: VectorSpringState): {SpringState: VectorSpringState};
	static SetVectorSpringStateVelocity(SpringState?: VectorSpringState,Velocity?: Vector): {SpringState: VectorSpringState};
}

declare class Vector { 
	X: number;
	Y: number;
	Z: number;
	clone() : Vector;
	static C(Other: UObject | any): Vector;
	GetLevelViewportCameraInfo(CameraRotation?: Rotator): {CameraLocation: Vector, CameraRotation: Rotator, $: boolean};
	SetLevelViewportCameraInfo(CameraRotation: Rotator): void;
	GetSelectionBounds(BoxExtent?: Vector,SphereRadius?: number): {Origin: Vector, BoxExtent: Vector, SphereRadius: number};
	GenerateBoxMesh(Vertices?: Vector[],Triangles?: number[],Normals?: Vector[],UVs?: Vector2D[],Tangents?: ProcMeshTangent[]): {Vertices: Vector[], Triangles: number[], Normals: Vector[], UVs: Vector2D[], Tangents: ProcMeshTangent[]};
	SegmentIntersection2D(SegmentEndA: Vector,SegmentStartB: Vector,SegmentEndB: Vector,IntersectionPoint?: Vector): {IntersectionPoint: Vector, $: boolean};
	Conv_VectorToString(): string;
	Add_VectorFloat(B: number): Vector;
	Add_VectorInt(B: number): Vector;
	Add_VectorVector(B: Vector): Vector;
	BreakVector(X?: number,Y?: number,Z?: number): {X: number, Y: number, Z: number};
	ClampVectorSize(Min: number,Max: number): Vector;
	Conv_VectorToLinearColor(): LinearColor;
	Conv_VectorToQuaternion(): Quat;
	Conv_VectorToRotator(): Rotator;
	Conv_VectorToTransform(): Transform;
	Conv_VectorToVector2D(): Vector2D;
	Cross_VectorVector(B: Vector): Vector;
	Divide_VectorFloat(B: number): Vector;
	Divide_VectorInt(B: number): Vector;
	Divide_VectorVector(B: Vector): Vector;
	Dot_VectorVector(B: Vector): number;
	DynamicWeightedMovingAverage_FVector(PreviousSample: Vector,MaxDistance: number,MinWeight: number,MaxWeight: number): Vector;
	EqualEqual_VectorVector(B: Vector,ErrorTolerance: number): boolean;
	EqualExactly_VectorVector(B: Vector): boolean;
	FindClosestPointOnLine(LineOrigin: Vector,LineDirection: Vector): Vector;
	FindClosestPointOnSegment(SegmentStart: Vector,SegmentEnd: Vector): Vector;
	FindLookAtRotation(Target: Vector): Rotator;
	FindNearestPointsOnLineSegments(Segment1End: Vector,Segment2Start: Vector,Segment2End: Vector,Segment1Point?: Vector,Segment2Point?: Vector): {Segment1Point: Vector, Segment2Point: Vector};
	FTruncVector(): IntVector;
	GetAzimuthAndElevation(ReferenceFrame: Transform,Azimuth?: number,Elevation?: number): {Azimuth: number, Elevation: number};
	GetDirectionUnitVector(To: Vector): Vector;
	GetMaxElement(): number;
	GetMinElement(): number;
	GetPointDistanceToLine(LineOrigin: Vector,LineDirection: Vector): number;
	GetPointDistanceToSegment(SegmentStart: Vector,SegmentEnd: Vector): number;
	GetReflectionVector(SurfaceNormal: Vector): Vector;
	GetSlopeDegreeAngles(FloorNormal: Vector,UpVector: Vector,OutSlopePitchDegreeAngle?: number,OutSlopeRollDegreeAngle?: number): {OutSlopePitchDegreeAngle: number, OutSlopeRollDegreeAngle: number};
	GetYawPitchFromVector(Yaw?: number,Pitch?: number): {Yaw: number, Pitch: number};
	GreaterGreater_VectorRotator(B: Rotator): Vector;
	IsPointInBox(BoxOrigin: Vector,BoxExtent: Vector): boolean;
	IsPointInBox_Box(Box: Box): boolean;
	IsPointInBoxWithTransform(BoxWorldTransform: Transform,BoxExtent: Vector): boolean;
	IsPointInBoxWithTransform_Box(BoxWorldTransform: Transform,BoxExtent: Box): boolean;
	LessLess_VectorRotator(B: Rotator): Vector;
	LinePlaneIntersection(LineEnd: Vector,APlane: Plane,T?: number,Intersection?: Vector): {T: number, Intersection: Vector, $: boolean};
	LinePlaneIntersection_OriginNormal(LineEnd: Vector,PlaneOrigin: Vector,PlaneNormal: Vector,T?: number,Intersection?: Vector): {T: number, Intersection: Vector, $: boolean};
	MakeBox(Max: Vector): Box;
	MakeBoxSphereBounds(BoxExtent: Vector,SphereRadius: number): BoxSphereBounds;
	MakePlaneFromPointAndNormal(Normal: Vector): Plane;
	MakeRotationFromAxes(Right: Vector,Up: Vector): Rotator;
	MakeRotFromX(): Rotator;
	MakeRotFromXY(Y: Vector): Rotator;
	MakeRotFromXZ(Z: Vector): Rotator;
	MakeRotFromY(): Rotator;
	MakeRotFromYX(X: Vector): Rotator;
	MakeRotFromYZ(Z: Vector): Rotator;
	MakeRotFromZ(): Rotator;
	MakeRotFromZX(X: Vector): Rotator;
	MakeRotFromZY(Y: Vector): Rotator;
	MakeTransform(Rotation: Rotator,Scale: Vector): Transform;
	MirrorVectorByNormal(InNormal: Vector): Vector;
	Multiply_VectorFloat(B: number): Vector;
	Multiply_VectorInt(B: number): Vector;
	Multiply_VectorVector(B: Vector): Vector;
	NegateVector(): Vector;
	Normal(Tolerance: number): Vector;
	NotEqual_VectorVector(B: Vector,ErrorTolerance: number): boolean;
	NotEqualExactly_VectorVector(B: Vector): boolean;
	ProjectPointOnToPlane(PlaneBase: Vector,PlaneNormal: Vector): Vector;
	ProjectVectorOnToPlane(PlaneNormal: Vector): Vector;
	ProjectVectorOnToVector(Target: Vector): Vector;
	Quat_MakeFromEuler(): Quat;
	RandomPointInBoundingBox(HalfSize: Vector): Vector;
	RandomPointInBoundingBoxFromStream(HalfSize: Vector,Stream: RandomStream): Vector;
	RandomUnitVectorInConeInDegrees(ConeHalfAngleInDegrees: number): Vector;
	RandomUnitVectorInConeInDegreesFromStream(ConeHalfAngleInDegrees: number,Stream: RandomStream): Vector;
	RandomUnitVectorInConeInRadians(ConeHalfAngleInRadians: number): Vector;
	RandomUnitVectorInConeInRadiansFromStream(ConeHalfAngleInRadians: number,Stream: RandomStream): Vector;
	RandomUnitVectorInEllipticalConeInDegrees(MaxYawInDegrees: number,MaxPitchInDegrees: number): Vector;
	RandomUnitVectorInEllipticalConeInDegreesFromStream(MaxYawInDegrees: number,MaxPitchInDegrees: number,Stream: RandomStream): Vector;
	RandomUnitVectorInEllipticalConeInRadians(MaxYawInRadians: number,MaxPitchInRadians: number): Vector;
	RandomUnitVectorInEllipticalConeInRadiansFromStream(MaxYawInRadians: number,MaxPitchInRadians: number,Stream: RandomStream): Vector;
	RotateAngleAxis(AngleDeg: number,Axis: Vector): Vector;
	RotatorFromAxisAndAngle(Angle: number): Rotator;
	SelectVector(B: Vector,bPickA: boolean): Vector;
	Subtract_VectorFloat(B: number): Vector;
	Subtract_VectorInt(B: number): Vector;
	Subtract_VectorVector(B: Vector): Vector;
	VEase(B: Vector,Alpha: number,EasingFunc: EEasingFunc,BlendExp: number,Steps: number): Vector;
	Vector_AddBounded(InAddVect?: Vector,InRadius?: number): {A: Vector};
	Vector_Assign(InVector?: Vector): {A: Vector};
	Vector_BoundedToBox(InBoxMin: Vector,InBoxMax: Vector): Vector;
	Vector_BoundedToCube(InRadius: number): Vector;
	Vector_ClampSize2D(Min: number,Max: number): Vector;
	Vector_ClampSizeMax(Max: number): Vector;
	Vector_ClampSizeMax2D(Max: number): Vector;
	Vector_ComponentMax(B: Vector): Vector;
	Vector_ComponentMin(B: Vector): Vector;
	Vector_CosineAngle2D(B: Vector): number;
	Vector_Distance(v2: Vector): number;
	Vector_Distance2D(v2: Vector): number;
	Vector_Distance2DSquared(v2: Vector): number;
	Vector_DistanceSquared(v2: Vector): number;
	Vector_GetAbs(): Vector;
	Vector_GetAbsMax(): number;
	Vector_GetAbsMin(): number;
	Vector_GetProjection(): Vector;
	Vector_GetSignVector(): Vector;
	Vector_HeadingAngle(): number;
	Vector_IsNAN(): boolean;
	Vector_IsNearlyZero(Tolerance: number): boolean;
	Vector_IsNormal(): boolean;
	Vector_IsUniform(Tolerance: number): boolean;
	Vector_IsUnit(SquaredLenthTolerance: number): boolean;
	Vector_IsZero(): boolean;
	Vector_MirrorByPlane(InPlane: Plane): Vector;
	Vector_Normal2D(Tolerance: number): Vector;
	Vector_Normalize(Tolerance?: number): {A: Vector};
	Vector_NormalUnsafe(): Vector;
	Vector_ProjectOnToNormal(InNormal: Vector): Vector;
	Vector_Reciprocal(): Vector;
	Vector_Set(X?: number,Y?: number,Z?: number): {A: Vector};
	Vector_SnappedToGrid(InGridSize: number): Vector;
	Vector_ToDegrees(): Vector;
	Vector_ToRadians(): Vector;
	Vector_UnitCartesianToSpherical(): Vector2D;
	Vector_UnwindEuler(): {A: Vector};
	VectorSpringInterp(Target: Vector,SpringState?: VectorSpringState,Stiffness?: number,CriticalDampingFactor?: number,DeltaTime?: number,Mass?: number,TargetVelocityAmount?: number,bClamp?: boolean,MinValue?: Vector,MaxValue?: Vector,bInitializeFromTarget?: boolean): {SpringState: VectorSpringState, $: Vector};
	VInterpTo(Target: Vector,DeltaTime: number,InterpSpeed: number): Vector;
	VInterpTo_Constant(Target: Vector,DeltaTime: number,InterpSpeed: number): Vector;
	VLerp(B: Vector,Alpha: number): Vector;
	VSize(): number;
	VSizeSquared(): number;
	VSizeXY(): number;
	VSizeXYSquared(): number;
	WeightedMovingAverage_FVector(PreviousSample: Vector,Weight: number): Vector;
	FindNearestActor(ActorsToCheck: Actor[],Distance?: number): {Distance: number, $: Actor};
	Conv_VectorToText(): string;
	IsValidAIDirection(): boolean;
	IsValidAILocation(): boolean;
	CalculateDirection(BaseRotation: Rotator): number;
	K2_TwoBoneIK(JointPos: Vector,EndPos: Vector,JointTarget: Vector,Effector: Vector,OutJointPos?: Vector,OutEndPos?: Vector,bAllowStretching?: boolean,StartStretchRatio?: number,MaxStretchScale?: number): {OutJointPos: Vector, OutEndPos: Vector};
	GetPositionalTrackingCameraParameters(CameraRotation?: Rotator,HFOV?: number,VFOV?: number,CameraDistance?: number,NearPlane?: number,FarPlane?: number): {CameraOrigin: Vector, CameraRotation: Rotator, HFOV: number, VFOV: number, CameraDistance: number, NearPlane: number, FarPlane: number};
	GetTrackingSensorParameters(Rotation?: Rotator,LeftFOV?: number,RightFOV?: number,TopFOV?: number,BottomFOV?: number,Distance?: number,NearPlane?: number,FarPlane?: number,IsActive?: boolean,Index?: number): {Origin: Vector, Rotation: Rotator, LeftFOV: number, RightFOV: number, TopFOV: number, BottomFOV: number, Distance: number, NearPlane: number, FarPlane: number, IsActive: boolean};
	AddManualEnvironmentCaptureProbe(Extent: Vector): boolean;
	GetObjectClassificationAtLocation(OutClassification?: EARObjectClassification,OutClassificationLocation?: Vector,MaxLocationDiff?: number): {OutClassification: EARObjectClassification, OutClassificationLocation: Vector, $: boolean};
	LineTraceTrackedObjects3D(End: Vector,bTestFeaturePoints: boolean,bTestGroundPlane: boolean,bTestPlaneExtents: boolean,bTestPlaneBoundaryPolygon: boolean): ARTraceResult[];
	SetARWorldOriginLocationAndRotation(OriginRotation: Rotator,bIsTransformInWorldSpace: boolean,bMaintainUpDirection: boolean): void;
	static GetLevelViewportCameraInfo(CameraLocation?: Vector,CameraRotation?: Rotator): {CameraLocation: Vector, CameraRotation: Rotator, $: boolean};
	static SetLevelViewportCameraInfo(CameraLocation: Vector,CameraRotation: Rotator): void;
	static GetSelectionBounds(Origin?: Vector,BoxExtent?: Vector,SphereRadius?: number): {Origin: Vector, BoxExtent: Vector, SphereRadius: number};
	static GenerateBoxMesh(BoxRadius: Vector,Vertices?: Vector[],Triangles?: number[],Normals?: Vector[],UVs?: Vector2D[],Tangents?: ProcMeshTangent[]): {Vertices: Vector[], Triangles: number[], Normals: Vector[], UVs: Vector2D[], Tangents: ProcMeshTangent[]};
	static SegmentIntersection2D(SegmentStartA: Vector,SegmentEndA: Vector,SegmentStartB: Vector,SegmentEndB: Vector,IntersectionPoint?: Vector): {IntersectionPoint: Vector, $: boolean};
	static Conv_VectorToString(InVec: Vector): string;
	static Add_VectorFloat(A: Vector,B: number): Vector;
	static Add_VectorInt(A: Vector,B: number): Vector;
	static Add_VectorVector(A: Vector,B: Vector): Vector;
	static BreakVector(InVec: Vector,X?: number,Y?: number,Z?: number): {X: number, Y: number, Z: number};
	static ClampVectorSize(A: Vector,Min: number,Max: number): Vector;
	static Conv_VectorToLinearColor(InVec: Vector): LinearColor;
	static Conv_VectorToQuaternion(InVec: Vector): Quat;
	static Conv_VectorToRotator(InVec: Vector): Rotator;
	static Conv_VectorToTransform(InLocation: Vector): Transform;
	static Conv_VectorToVector2D(InVector: Vector): Vector2D;
	static Cross_VectorVector(A: Vector,B: Vector): Vector;
	static Divide_VectorFloat(A: Vector,B: number): Vector;
	static Divide_VectorInt(A: Vector,B: number): Vector;
	static Divide_VectorVector(A: Vector,B: Vector): Vector;
	static Dot_VectorVector(A: Vector,B: Vector): number;
	static DynamicWeightedMovingAverage_FVector(CurrentSample: Vector,PreviousSample: Vector,MaxDistance: number,MinWeight: number,MaxWeight: number): Vector;
	static EqualEqual_VectorVector(A: Vector,B: Vector,ErrorTolerance: number): boolean;
	static EqualExactly_VectorVector(A: Vector,B: Vector): boolean;
	static FindClosestPointOnLine(Point: Vector,LineOrigin: Vector,LineDirection: Vector): Vector;
	static FindClosestPointOnSegment(Point: Vector,SegmentStart: Vector,SegmentEnd: Vector): Vector;
	static FindLookAtRotation(Start: Vector,Target: Vector): Rotator;
	static FindNearestPointsOnLineSegments(Segment1Start: Vector,Segment1End: Vector,Segment2Start: Vector,Segment2End: Vector,Segment1Point?: Vector,Segment2Point?: Vector): {Segment1Point: Vector, Segment2Point: Vector};
	static FTruncVector(InVector: Vector): IntVector;
	static GetAzimuthAndElevation(InDirection: Vector,ReferenceFrame: Transform,Azimuth?: number,Elevation?: number): {Azimuth: number, Elevation: number};
	static GetDirectionUnitVector(From: Vector,To: Vector): Vector;
	static GetMaxElement(A: Vector): number;
	static GetMinElement(A: Vector): number;
	static GetPointDistanceToLine(Point: Vector,LineOrigin: Vector,LineDirection: Vector): number;
	static GetPointDistanceToSegment(Point: Vector,SegmentStart: Vector,SegmentEnd: Vector): number;
	static GetReflectionVector(Direction: Vector,SurfaceNormal: Vector): Vector;
	static GetSlopeDegreeAngles(MyRightYAxis: Vector,FloorNormal: Vector,UpVector: Vector,OutSlopePitchDegreeAngle?: number,OutSlopeRollDegreeAngle?: number): {OutSlopePitchDegreeAngle: number, OutSlopeRollDegreeAngle: number};
	static GetYawPitchFromVector(InVec: Vector,Yaw?: number,Pitch?: number): {Yaw: number, Pitch: number};
	static GreaterGreater_VectorRotator(A: Vector,B: Rotator): Vector;
	static IsPointInBox(Point: Vector,BoxOrigin: Vector,BoxExtent: Vector): boolean;
	static IsPointInBox_Box(Point: Vector,Box: Box): boolean;
	static IsPointInBoxWithTransform(Point: Vector,BoxWorldTransform: Transform,BoxExtent: Vector): boolean;
	static IsPointInBoxWithTransform_Box(Point: Vector,BoxWorldTransform: Transform,BoxExtent: Box): boolean;
	static LessLess_VectorRotator(A: Vector,B: Rotator): Vector;
	static LinePlaneIntersection(LineStart: Vector,LineEnd: Vector,APlane: Plane,T?: number,Intersection?: Vector): {T: number, Intersection: Vector, $: boolean};
	static LinePlaneIntersection_OriginNormal(LineStart: Vector,LineEnd: Vector,PlaneOrigin: Vector,PlaneNormal: Vector,T?: number,Intersection?: Vector): {T: number, Intersection: Vector, $: boolean};
	static MakeBox(Min: Vector,Max: Vector): Box;
	static MakeBoxSphereBounds(Origin: Vector,BoxExtent: Vector,SphereRadius: number): BoxSphereBounds;
	static MakePlaneFromPointAndNormal(Point: Vector,Normal: Vector): Plane;
	static MakeRotationFromAxes(Forward: Vector,Right: Vector,Up: Vector): Rotator;
	static MakeRotFromX(X: Vector): Rotator;
	static MakeRotFromXY(X: Vector,Y: Vector): Rotator;
	static MakeRotFromXZ(X: Vector,Z: Vector): Rotator;
	static MakeRotFromY(Y: Vector): Rotator;
	static MakeRotFromYX(Y: Vector,X: Vector): Rotator;
	static MakeRotFromYZ(Y: Vector,Z: Vector): Rotator;
	static MakeRotFromZ(Z: Vector): Rotator;
	static MakeRotFromZX(Z: Vector,X: Vector): Rotator;
	static MakeRotFromZY(Z: Vector,Y: Vector): Rotator;
	static MakeTransform(Location: Vector,Rotation: Rotator,Scale: Vector): Transform;
	static MirrorVectorByNormal(InVect: Vector,InNormal: Vector): Vector;
	static Multiply_VectorFloat(A: Vector,B: number): Vector;
	static Multiply_VectorInt(A: Vector,B: number): Vector;
	static Multiply_VectorVector(A: Vector,B: Vector): Vector;
	static NegateVector(A: Vector): Vector;
	static Normal(A: Vector,Tolerance: number): Vector;
	static NotEqual_VectorVector(A: Vector,B: Vector,ErrorTolerance: number): boolean;
	static NotEqualExactly_VectorVector(A: Vector,B: Vector): boolean;
	static ProjectPointOnToPlane(Point: Vector,PlaneBase: Vector,PlaneNormal: Vector): Vector;
	static ProjectVectorOnToPlane(V: Vector,PlaneNormal: Vector): Vector;
	static ProjectVectorOnToVector(V: Vector,Target: Vector): Vector;
	static Quat_MakeFromEuler(Euler: Vector): Quat;
	static RandomPointInBoundingBox(Center: Vector,HalfSize: Vector): Vector;
	static RandomPointInBoundingBoxFromStream(Center: Vector,HalfSize: Vector,Stream: RandomStream): Vector;
	static RandomUnitVectorInConeInDegrees(ConeDir: Vector,ConeHalfAngleInDegrees: number): Vector;
	static RandomUnitVectorInConeInDegreesFromStream(ConeDir: Vector,ConeHalfAngleInDegrees: number,Stream: RandomStream): Vector;
	static RandomUnitVectorInConeInRadians(ConeDir: Vector,ConeHalfAngleInRadians: number): Vector;
	static RandomUnitVectorInConeInRadiansFromStream(ConeDir: Vector,ConeHalfAngleInRadians: number,Stream: RandomStream): Vector;
	static RandomUnitVectorInEllipticalConeInDegrees(ConeDir: Vector,MaxYawInDegrees: number,MaxPitchInDegrees: number): Vector;
	static RandomUnitVectorInEllipticalConeInDegreesFromStream(ConeDir: Vector,MaxYawInDegrees: number,MaxPitchInDegrees: number,Stream: RandomStream): Vector;
	static RandomUnitVectorInEllipticalConeInRadians(ConeDir: Vector,MaxYawInRadians: number,MaxPitchInRadians: number): Vector;
	static RandomUnitVectorInEllipticalConeInRadiansFromStream(ConeDir: Vector,MaxYawInRadians: number,MaxPitchInRadians: number,Stream: RandomStream): Vector;
	static RotateAngleAxis(InVect: Vector,AngleDeg: number,Axis: Vector): Vector;
	static RotatorFromAxisAndAngle(Axis: Vector,Angle: number): Rotator;
	static SelectVector(A: Vector,B: Vector,bPickA: boolean): Vector;
	static Subtract_VectorFloat(A: Vector,B: number): Vector;
	static Subtract_VectorInt(A: Vector,B: number): Vector;
	static Subtract_VectorVector(A: Vector,B: Vector): Vector;
	static VEase(A: Vector,B: Vector,Alpha: number,EasingFunc: EEasingFunc,BlendExp: number,Steps: number): Vector;
	static Vector_AddBounded(A?: Vector,InAddVect?: Vector,InRadius?: number): {A: Vector};
	static Vector_Assign(A?: Vector,InVector?: Vector): {A: Vector};
	static Vector_BoundedToBox(InVect: Vector,InBoxMin: Vector,InBoxMax: Vector): Vector;
	static Vector_BoundedToCube(InVect: Vector,InRadius: number): Vector;
	static Vector_ClampSize2D(A: Vector,Min: number,Max: number): Vector;
	static Vector_ClampSizeMax(A: Vector,Max: number): Vector;
	static Vector_ClampSizeMax2D(A: Vector,Max: number): Vector;
	static Vector_ComponentMax(A: Vector,B: Vector): Vector;
	static Vector_ComponentMin(A: Vector,B: Vector): Vector;
	static Vector_CosineAngle2D(A: Vector,B: Vector): number;
	static Vector_Distance(v1: Vector,v2: Vector): number;
	static Vector_Distance2D(v1: Vector,v2: Vector): number;
	static Vector_Distance2DSquared(v1: Vector,v2: Vector): number;
	static Vector_DistanceSquared(v1: Vector,v2: Vector): number;
	static Vector_GetAbs(A: Vector): Vector;
	static Vector_GetAbsMax(A: Vector): number;
	static Vector_GetAbsMin(A: Vector): number;
	static Vector_GetProjection(A: Vector): Vector;
	static Vector_GetSignVector(A: Vector): Vector;
	static Vector_HeadingAngle(A: Vector): number;
	static Vector_IsNAN(A: Vector): boolean;
	static Vector_IsNearlyZero(A: Vector,Tolerance: number): boolean;
	static Vector_IsNormal(A: Vector): boolean;
	static Vector_IsUniform(A: Vector,Tolerance: number): boolean;
	static Vector_IsUnit(A: Vector,SquaredLenthTolerance: number): boolean;
	static Vector_IsZero(A: Vector): boolean;
	static Vector_MirrorByPlane(A: Vector,InPlane: Plane): Vector;
	static Vector_Normal2D(A: Vector,Tolerance: number): Vector;
	static Vector_Normalize(A?: Vector,Tolerance?: number): {A: Vector};
	static Vector_NormalUnsafe(A: Vector): Vector;
	static Vector_ProjectOnToNormal(V: Vector,InNormal: Vector): Vector;
	static Vector_Reciprocal(A: Vector): Vector;
	static Vector_Set(A?: Vector,X?: number,Y?: number,Z?: number): {A: Vector};
	static Vector_SnappedToGrid(InVect: Vector,InGridSize: number): Vector;
	static Vector_ToDegrees(A: Vector): Vector;
	static Vector_ToRadians(A: Vector): Vector;
	static Vector_UnitCartesianToSpherical(A: Vector): Vector2D;
	static Vector_UnwindEuler(A?: Vector): {A: Vector};
	static VectorSpringInterp(Current: Vector,Target: Vector,SpringState?: VectorSpringState,Stiffness?: number,CriticalDampingFactor?: number,DeltaTime?: number,Mass?: number,TargetVelocityAmount?: number,bClamp?: boolean,MinValue?: Vector,MaxValue?: Vector,bInitializeFromTarget?: boolean): {SpringState: VectorSpringState, $: Vector};
	static VInterpTo(Current: Vector,Target: Vector,DeltaTime: number,InterpSpeed: number): Vector;
	static VInterpTo_Constant(Current: Vector,Target: Vector,DeltaTime: number,InterpSpeed: number): Vector;
	static VLerp(A: Vector,B: Vector,Alpha: number): Vector;
	static VSize(A: Vector): number;
	static VSizeSquared(A: Vector): number;
	static VSizeXY(A: Vector): number;
	static VSizeXYSquared(A: Vector): number;
	static WeightedMovingAverage_FVector(CurrentSample: Vector,PreviousSample: Vector,Weight: number): Vector;
	static FindNearestActor(Origin: Vector,ActorsToCheck: Actor[],Distance?: number): {Distance: number, $: Actor};
	static Conv_VectorToText(InVec: Vector): string;
	static IsValidAIDirection(DirectionVector: Vector): boolean;
	static IsValidAILocation(Location: Vector): boolean;
	static CalculateDirection(Velocity: Vector,BaseRotation: Rotator): number;
	static K2_TwoBoneIK(RootPos: Vector,JointPos: Vector,EndPos: Vector,JointTarget: Vector,Effector: Vector,OutJointPos?: Vector,OutEndPos?: Vector,bAllowStretching?: boolean,StartStretchRatio?: number,MaxStretchScale?: number): {OutJointPos: Vector, OutEndPos: Vector};
	static GetPositionalTrackingCameraParameters(CameraOrigin?: Vector,CameraRotation?: Rotator,HFOV?: number,VFOV?: number,CameraDistance?: number,NearPlane?: number,FarPlane?: number): {CameraOrigin: Vector, CameraRotation: Rotator, HFOV: number, VFOV: number, CameraDistance: number, NearPlane: number, FarPlane: number};
	static GetTrackingSensorParameters(Origin?: Vector,Rotation?: Rotator,LeftFOV?: number,RightFOV?: number,TopFOV?: number,BottomFOV?: number,Distance?: number,NearPlane?: number,FarPlane?: number,IsActive?: boolean,Index?: number): {Origin: Vector, Rotation: Rotator, LeftFOV: number, RightFOV: number, TopFOV: number, BottomFOV: number, Distance: number, NearPlane: number, FarPlane: number, IsActive: boolean};
	static AddManualEnvironmentCaptureProbe(Location: Vector,Extent: Vector): boolean;
	static GetObjectClassificationAtLocation(InWorldLocation: Vector,OutClassification?: EARObjectClassification,OutClassificationLocation?: Vector,MaxLocationDiff?: number): {OutClassification: EARObjectClassification, OutClassificationLocation: Vector, $: boolean};
	static LineTraceTrackedObjects3D(Start: Vector,End: Vector,bTestFeaturePoints: boolean,bTestGroundPlane: boolean,bTestPlaneExtents: boolean,bTestPlaneBoundaryPolygon: boolean): ARTraceResult[];
	static SetARWorldOriginLocationAndRotation(OriginLocation: Vector,OriginRotation: Rotator,bIsTransformInWorldSpace: boolean,bMaintainUpDirection: boolean): void;
	static Conv_DoubleToVector(InDouble: number): Vector;
	static Conv_FloatToVector(InFloat: number): Vector;
	static Conv_IntToVector(inInt: number): Vector;
	static CreateVectorFromYawPitch(Yaw: number,Pitch: number,Length: number): Vector;
	static GetVectorArrayAverage(Vectors: Vector[]): Vector;
	static MakeVector(X: number,Y: number,Z: number): Vector;
	static RandomUnitVector(): Vector;
	static Vector_Backward(): Vector;
	static Vector_Down(): Vector;
	static Vector_Forward(): Vector;
	static Vector_Left(): Vector;
	static Vector_One(): Vector;
	static Vector_Right(): Vector;
	static Vector_Up(): Vector;
	static Vector_Zero(): Vector;
	static NextSobolCell3D(Index: number,NumCells: number,PreviousValue: Vector): Vector;
	static RandomSobolCell3D(Index: number,NumCells: number,Cell: Vector,Seed: Vector): Vector;
	static GetActorArrayAverageLocation(Actors: Actor[]): Vector;
	static K2_MakePerlinNoiseVectorAndRemap(X: number,Y: number,Z: number,RangeOutMinX: number,RangeOutMaxX: number,RangeOutMinY: number,RangeOutMaxY: number,RangeOutMinZ: number,RangeOutMaxZ: number): Vector;
}

declare class Vector_NetQuantize100 extends Vector { 
	clone() : Vector_NetQuantize100;
	static C(Other: UObject | any): Vector_NetQuantize100;
	BreakVector_NetQuantize100(X?: number,Y?: number,Z?: number): {X: number, Y: number, Z: number};
	static BreakVector_NetQuantize100(InVec: Vector_NetQuantize100,X?: number,Y?: number,Z?: number): {X: number, Y: number, Z: number};
	static MakeVector_NetQuantize100(X: number,Y: number,Z: number): Vector_NetQuantize100;
}

declare class RepAttachment { 
	AttachParent: Actor;
	LocationOffset: Vector_NetQuantize100;
	RelativeScale3D: Vector_NetQuantize100;
	RotationOffset: Rotator;
	AttachSocket: string;
	AttachComponent: SceneComponent;
	clone() : RepAttachment;
	static C(Other: UObject | any): RepAttachment;
}

declare type EVectorQuantization = 'RoundWholeNumber' | 'RoundOneDecimal' | 'RoundTwoDecimals' | 'EVectorQuantization_MAX';
declare var EVectorQuantization : { RoundWholeNumber:'RoundWholeNumber',RoundOneDecimal:'RoundOneDecimal',RoundTwoDecimals:'RoundTwoDecimals',EVectorQuantization_MAX:'EVectorQuantization_MAX', };
declare type ERotatorQuantization = 'ByteComponents' | 'ShortComponents' | 'ERotatorQuantization_MAX';
declare var ERotatorQuantization : { ByteComponents:'ByteComponents',ShortComponents:'ShortComponents',ERotatorQuantization_MAX:'ERotatorQuantization_MAX', };
declare class RepMovement { 
	LinearVelocity: Vector;
	AngularVelocity: Vector;
	Location: Vector;
	Rotation: Rotator;
	bSimulatedPhysicSleep: boolean;
	bRepPhysics: boolean;
	ServerFrame: number;
	ServerPhysicsHandle: number;
	LocationQuantizationLevel: EVectorQuantization;
	VelocityQuantizationLevel: EVectorQuantization;
	RotationQuantizationLevel: ERotatorQuantization;
	clone() : RepMovement;
	static C(Other: UObject | any): RepMovement;
}

declare type ENetDormancy = 'DORM_Never' | 'DORM_Awake' | 'DORM_DormantAll' | 'DORM_DormantPartial' | 'DORM_Initial' | 'DORM_MAX';
declare var ENetDormancy : { DORM_Never:'DORM_Never',DORM_Awake:'DORM_Awake',DORM_DormantAll:'DORM_DormantAll',DORM_DormantPartial:'DORM_DormantPartial',DORM_Initial:'DORM_Initial',DORM_MAX:'DORM_MAX', };
declare type EChildActorComponentTreeViewVisualizationMode = 'UseDefault' | 'ComponentOnly' | 'ComponentWithChildActor' | 'ChildActorOnly' | 'EChildActorComponentTreeViewVisualizationMode_MAX';
declare var EChildActorComponentTreeViewVisualizationMode : { UseDefault:'UseDefault',ComponentOnly:'ComponentOnly',ComponentWithChildActor:'ComponentWithChildActor',ChildActorOnly:'ChildActorOnly',EChildActorComponentTreeViewVisualizationMode_MAX:'EChildActorComponentTreeViewVisualizationMode_MAX', };
declare class ChildActorComponent extends SceneComponent { 
	ChildActorClass: UnrealEngineClass;
	ChildActor: Actor;
	ChildActorTemplate: Actor;
	EditorTreeViewVisualizationMode: EChildActorComponentTreeViewVisualizationMode;
	static Load(ResourceName: string): ChildActorComponent;
	static Find(Outer: UObject, ResourceName: string): ChildActorComponent;
	static GetDefaultObject(): ChildActorComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChildActorComponent;
	SetChildActorClass(InClass: UnrealEngineClass): void;
	OnChildActorDestroyed(DestroyedActor: Actor): void;
	static C(Other: UObject | any): ChildActorComponent;
}

declare class JavascriptHitProxy { 
	clone() : JavascriptHitProxy;
	static C(Other: UObject | any): JavascriptHitProxy;
	GetActor(): Actor;
	GetName(): string;
	static GetActor(Proxy: JavascriptHitProxy): Actor;
	static GetName(Proxy: JavascriptHitProxy): string;
}

declare class JavascriptEdViewport { 
	clone() : JavascriptEdViewport;
	static C(Other: UObject | any): JavascriptEdViewport;
	GetHitProxy(): JavascriptHitProxy;
	static GetHitProxy(Viewport: JavascriptEdViewport): JavascriptHitProxy;
}

declare class JavascriptViewportClick { 
	clone() : JavascriptViewportClick;
	static C(Other: UObject | any): JavascriptViewportClick;
	GetClickPos(): IntPoint;
	GetDirection(): Vector;
	GetEvent(): EInputEvent;
	GetKey(): Key;
	GetOrigin(): Vector;
	IsAltDown(): boolean;
	IsControlDown(): boolean;
	IsShiftDown(): boolean;
	static GetClickPos(Click: JavascriptViewportClick): IntPoint;
	static GetDirection(Click: JavascriptViewportClick): Vector;
	static GetEvent(Click: JavascriptViewportClick): EInputEvent;
	static GetKey(Click: JavascriptViewportClick): Key;
	static GetOrigin(Click: JavascriptViewportClick): Vector;
	static IsAltDown(Click: JavascriptViewportClick): boolean;
	static IsControlDown(Click: JavascriptViewportClick): boolean;
	static IsShiftDown(Click: JavascriptViewportClick): boolean;
}

declare type EInputActionValueType = 'Boolean' | 'Axis1D' | 'Axis2D' | 'Axis3D' | 'EInputActionValueType_MAX';
declare var EInputActionValueType : { Boolean:'Boolean',Axis1D:'Axis1D',Axis2D:'Axis2D',Axis3D:'Axis3D',EInputActionValueType_MAX:'EInputActionValueType_MAX', };
declare class InputActionValue { 
	clone() : InputActionValue;
	static C(Other: UObject | any): InputActionValue;
	BreakInputActionValue(X?: number,Y?: number,Z?: number,Type?: EInputActionValueType): {X: number, Y: number, Z: number, Type: EInputActionValueType};
	Conv_InputActionValueToAxis1D(): number;
	Conv_InputActionValueToAxis2D(): Vector2D;
	Conv_InputActionValueToAxis3D(): Vector;
	Conv_InputActionValueToBool(): boolean;
	Conv_InputActionValueToString(): string;
	static BreakInputActionValue(InActionValue: InputActionValue,X?: number,Y?: number,Z?: number,Type?: EInputActionValueType): {X: number, Y: number, Z: number, Type: EInputActionValueType};
	static Conv_InputActionValueToAxis1D(InValue: InputActionValue): number;
	static Conv_InputActionValueToAxis2D(InValue: InputActionValue): Vector2D;
	static Conv_InputActionValueToAxis3D(ActionValue: InputActionValue): Vector;
	static Conv_InputActionValueToBool(InValue: InputActionValue): boolean;
	static Conv_InputActionValueToString(ActionValue: InputActionValue): string;
	static MakeInputActionValue(X: number,Y: number,Z: number,MatchValueType: InputActionValue): InputActionValue;
	static MakeInputActionValueOfType(X: number,Y: number,Z: number,ValueType: EInputActionValueType): InputActionValue;
}

declare class PlayerMappableKeyOptions { 
	MetaData: UObject;
	Name: string;
	DisplayName: string;
	DisplayCategory: string;
	clone() : PlayerMappableKeyOptions;
	static C(Other: UObject | any): PlayerMappableKeyOptions;
}

declare class InputModifier extends UObject { 
	static Load(ResourceName: string): InputModifier;
	static Find(Outer: UObject, ResourceName: string): InputModifier;
	static GetDefaultObject(): InputModifier;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputModifier;
	ModifyRaw(PlayerInput: EnhancedPlayerInput,CurrentValue: InputActionValue,DeltaTime: number): InputActionValue;
	GetVisualizationColor(SampleValue: InputActionValue,FinalValue: InputActionValue): LinearColor;
	static C(Other: UObject | any): InputModifier;
}

declare class EnhancedActionKeyMapping { 
	PlayerMappableOptions: PlayerMappableKeyOptions;
	Triggers: InputTrigger[];
	Modifiers: InputModifier[];
	Action: InputAction;
	Key: Key;
	bIsPlayerMappable: boolean;
	bShouldBeIgnored: boolean;
	clone() : EnhancedActionKeyMapping;
	static C(Other: UObject | any): EnhancedActionKeyMapping;
}

declare class InputMappingContext extends DataAsset { 
	Mappings: EnhancedActionKeyMapping[];
	ContextDescription: string;
	static Load(ResourceName: string): InputMappingContext;
	static Find(Outer: UObject, ResourceName: string): InputMappingContext;
	static GetDefaultObject(): InputMappingContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputMappingContext;
	UnmapKey(Action: InputAction,Key: Key): void;
	UnmapAllKeysFromAction(Action: InputAction): void;
	UnmapAll(): void;
	UnmapAction(Action: InputAction): void;
	MapKey(Action: InputAction,ToKey: Key): EnhancedActionKeyMapping;
	static C(Other: UObject | any): InputMappingContext;
	RequestRebuildControlMappingsUsingContext(bForceImmediately: boolean): void;
	static RequestRebuildControlMappingsUsingContext(Context: InputMappingContext,bForceImmediately: boolean): void;
}

declare type ETriggerEvent = 'None' | 'Triggered' | 'Started' | 'Ongoing' | 'Canceled' | 'Completed' | 'ETriggerEvent_MAX';
declare var ETriggerEvent : { None:'None',Triggered:'Triggered',Started:'Started',Ongoing:'Ongoing',Canceled:'Canceled',Completed:'Completed',ETriggerEvent_MAX:'ETriggerEvent_MAX', };
declare class InputActionInstance { 
	SourceAction: InputAction;
	TriggerEvent: ETriggerEvent;
	LastTriggeredWorldTime: number;
	Triggers: InputTrigger[];
	Modifiers: InputModifier[];
	ElapsedProcessedTime: number;
	ElapsedTriggeredTime: number;
	clone() : InputActionInstance;
	static C(Other: UObject | any): InputActionInstance;
}

declare class InjectedInputArray { 
	clone() : InjectedInputArray;
	static C(Other: UObject | any): InjectedInputArray;
}

declare class EnhancedPlayerInput extends PlayerInput { 
	AppliedInputContexts: Map<InputMappingContext, number>;
	EnhancedActionMappings: EnhancedActionKeyMapping[];
	ActionInstanceData: Map<InputAction, InputActionInstance>;
	KeysPressedThisTick: Map<Key, Vector>;
	InputsInjectedThisTick: Map<InputAction, InjectedInputArray>;
	LastInjectedActions: Set<InputAction>;
	static Load(ResourceName: string): EnhancedPlayerInput;
	static Find(Outer: UObject, ResourceName: string): EnhancedPlayerInput;
	static GetDefaultObject(): EnhancedPlayerInput;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnhancedPlayerInput;
	static C(Other: UObject | any): EnhancedPlayerInput;
}

declare type ETriggerState = 'None' | 'Ongoing' | 'Triggered' | 'ETriggerState_MAX';
declare var ETriggerState : { None:'None',Ongoing:'Ongoing',Triggered:'Triggered',ETriggerState_MAX:'ETriggerState_MAX', };
declare type ETriggerType = 'Explicit' | 'Implicit' | 'Blocker' | 'ETriggerType_MAX';
declare var ETriggerType : { Explicit:'Explicit',Implicit:'Implicit',Blocker:'Blocker',ETriggerType_MAX:'ETriggerType_MAX', };
declare class InputTrigger extends UObject { 
	ActuationThreshold: number;
	bShouldAlwaysTick: boolean;
	LastValue: InputActionValue;
	static Load(ResourceName: string): InputTrigger;
	static Find(Outer: UObject, ResourceName: string): InputTrigger;
	static GetDefaultObject(): InputTrigger;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputTrigger;
	UpdateState(PlayerInput: EnhancedPlayerInput,ModifiedValue: InputActionValue,DeltaTime: number): ETriggerState;
	IsActuated(ForValue: InputActionValue): boolean;
	GetTriggerType(): ETriggerType;
	static C(Other: UObject | any): InputTrigger;
}

declare class InputAction extends DataAsset { 
	ActionDescription: string;
	bConsumeInput: boolean;
	bTriggerWhenPaused: boolean;
	bReserveAllMappings: boolean;
	ValueType: EInputActionValueType;
	Triggers: InputTrigger[];
	Modifiers: InputModifier[];
	static Load(ResourceName: string): InputAction;
	static Find(Outer: UObject, ResourceName: string): InputAction;
	static GetDefaultObject(): InputAction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputAction;
	static C(Other: UObject | any): InputAction;
}

declare class ScriptTypedElementHandle { 
	clone() : ScriptTypedElementHandle;
	static C(Other: UObject | any): ScriptTypedElementHandle;
}

declare class Actor extends UObject { 
	PrimaryActorTick: ActorTickFunction;
	bNetTemporary: boolean;
	bOnlyRelevantToOwner: boolean;
	bAlwaysRelevant: boolean;
	bReplicateMovement: boolean;
	bCallPreReplication: boolean;
	bCallPreReplicationForReplay: boolean;
	bHidden: boolean;
	bTearOff: boolean;
	bForceNetAddressable: boolean;
	bIsInEditingLevelInstance: boolean;
	bExchangedRoles: boolean;
	bNetLoadOnClient: boolean;
	bNetUseOwnerRelevancy: boolean;
	bRelevantForNetworkReplays: boolean;
	bRelevantForLevelBounds: boolean;
	bReplayRewindable: boolean;
	bAllowTickBeforeBeginPlay: boolean;
	bAutoDestroyWhenFinished: boolean;
	bCanBeDamaged: boolean;
	bBlockInput: boolean;
	bCollideWhenPlacing: boolean;
	bFindCameraComponentWhenViewTarget: boolean;
	bGenerateOverlapEventsDuringLevelStreaming: boolean;
	bIgnoresOriginShifting: boolean;
	bEnableAutoLODGeneration: boolean;
	bIsEditorOnlyActor: boolean;
	bActorSeamlessTraveled: boolean;
	bReplicates: boolean;
	bCanBeInCluster: boolean;
	bAllowReceiveTickEventOnDedicatedServer: boolean;
	bReplicateUsingRegisteredSubObjectList: boolean;
	bActorEnableCollision: boolean;
	bActorIsBeingDestroyed: boolean;
	bAsyncPhysicsTickEnabled: boolean;
	UpdateOverlapsMethodDuringLevelStreaming: EActorUpdateOverlapsMethod;
	DefaultUpdateOverlapsMethodDuringLevelStreaming: EActorUpdateOverlapsMethod;
	InitialLifeSpan: number;
	CustomTimeDilation: number;
	RemoteRole: ENetRole;
	RayTracingGroupId: number;
	GridPlacement: EActorGridPlacement;
	RuntimeGrid: string;
	AttachmentReplication: RepAttachment;
	ReplicatedMovement: RepMovement;
	Owner: Actor;
	NetDriverName: string;
	Role: ENetRole;
	NetDormancy: ENetDormancy;
	SpawnCollisionHandlingMethod: ESpawnActorCollisionHandlingMethod;
	AutoReceiveInput: EAutoReceiveInput;
	InputPriority: number;
	InputComponent: InputComponent;
	NetCullDistanceSquared: number;
	NetTag: number;
	NetUpdateFrequency: number;
	MinNetUpdateFrequency: number;
	NetPriority: number;
	Instigator: Pawn;
	Children: Actor[];
	RootComponent: SceneComponent;
	PivotOffset: Vector;
	HLODLayer: HLODLayer;
	Layers: string[];
	ParentComponentActor: Actor;
	ParentComponent: ChildActorComponent;
	ActorGuid: Guid;
	ContentBundleGuid: Guid;
	DataLayers: ActorDataLayer[];
	DataLayerAssets: DataLayerAsset[];
	GroupActor: Actor;
	SpriteScale: number;
	HiddenEditorViews: number;
	ActorLabel: string;
	FolderPath: string;
	FolderGuid: Guid;
	bHiddenEd: boolean;
	bIsEditorPreviewActor: boolean;
	bHiddenEdLayer: boolean;
	bHiddenEdLevel: boolean;
	bLockLocation: boolean;
	bActorLabelEditable: boolean;
	bEditable: boolean;
	bListedInSceneOutliner: boolean;
	bOptimizeBPComponentData: boolean;
	bCanPlayFromHere: boolean;
	bIsSpatiallyLoaded: boolean;
	bHiddenEdTemporary: boolean;
	bForceExternalActorLevelReferenceForPIE: boolean;
	Tags: string[];
	OnTakeAnyDamage: UnrealEngineMulticastDelegate<(DamagedActor: Actor, Damage: number, DamageType: DamageType, InstigatedBy: Controller, DamageCauser: Actor) => void>;
	OnTakePointDamage: UnrealEngineMulticastDelegate<(DamagedActor: Actor, Damage: number, InstigatedBy: Controller, HitLocation: Vector, FHitComponent: PrimitiveComponent, BoneName: string, ShotFromDirection: Vector, DamageType: DamageType, DamageCauser: Actor) => void>;
	OnTakeRadialDamage: UnrealEngineMulticastDelegate<(DamagedActor: Actor, Damage: number, DamageType: DamageType, Origin: Vector, HitInfo: HitResult, InstigatedBy: Controller, DamageCauser: Actor) => void>;
	OnActorBeginOverlap: UnrealEngineMulticastDelegate<(OverlappedActor: Actor, OtherActor: Actor) => void>;
	OnActorEndOverlap: UnrealEngineMulticastDelegate<(OverlappedActor: Actor, OtherActor: Actor) => void>;
	OnBeginCursorOver: UnrealEngineMulticastDelegate<(TouchedActor: Actor) => void>;
	OnEndCursorOver: UnrealEngineMulticastDelegate<(TouchedActor: Actor) => void>;
	OnClicked: UnrealEngineMulticastDelegate<(TouchedActor: Actor, ButtonPressed: Key) => void>;
	OnReleased: UnrealEngineMulticastDelegate<(TouchedActor: Actor, ButtonReleased: Key) => void>;
	OnInputTouchBegin: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedActor: Actor) => void>;
	OnInputTouchEnd: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedActor: Actor) => void>;
	OnInputTouchEnter: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedActor: Actor) => void>;
	OnInputTouchLeave: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedActor: Actor) => void>;
	OnActorHit: UnrealEngineMulticastDelegate<(SelfActor: Actor, OtherActor: Actor, NormalImpulse: Vector, Hit: HitResult) => void>;
	OnDestroyed: UnrealEngineMulticastDelegate<(DestroyedActor: Actor) => void>;
	OnEndPlay: UnrealEngineMulticastDelegate<(Actor: Actor, EndPlayReason: EEndPlayReason) => void>;
	InstanceComponents: ActorComponent[];
	BlueprintCreatedComponents: ActorComponent[];
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static GetDefaultObject(): Actor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Actor;
	WasRecentlyRendered(Tolerance: number): boolean;
	UserConstructionScript(): void;
	TearOff(): void;
	SetTickGroup(NewTickGroup: ETickingGroup): void;
	SetTickableWhenPaused(bTickableWhenPaused: boolean): void;
	SetReplicates(bInReplicates: boolean): void;
	SetReplicateMovement(bInReplicateMovement: boolean): void;
	SetRayTracingGroupId(InRaytracingGroupId: number): void;
	SetOwner(NewOwner: Actor): void;
	SetNetDormancy(NewDormancy: ENetDormancy): void;
	SetLifeSpan(InLifespan: number): void;
	SetIsTemporarilyHiddenInEditor(bIsHidden: boolean): void;
	SetFolderPath(NewFolderPath: string): void;
	SetAutoDestroyWhenFinished(bVal: boolean): void;
	SetActorTickInterval(TickInterval: number): void;
	SetActorTickEnabled(bEnabled: boolean): void;
	SetActorScale3D(NewScale3D: Vector): void;
	SetActorRelativeScale3D(NewRelativeScale: Vector): void;
	SetActorLabel(NewActorLabel: string,bMarkDirty: boolean): void;
	SetActorHiddenInGame(bNewHidden: boolean): void;
	SetActorEnableCollision(bNewActorEnableCollision: boolean): void;
	RemoveTickPrerequisiteComponent(PrerequisiteComponent: ActorComponent): void;
	RemoveTickPrerequisiteActor(PrerequisiteActor: Actor): void;
	ReceiveTick(DeltaSeconds: number): void;
	ReceiveRadialDamage(DamageReceived: number,DamageType: DamageType,Origin: Vector,HitInfo: HitResult,InstigatedBy: Controller,DamageCauser: Actor): void;
	ReceivePointDamage(Damage: number,DamageType: DamageType,HitLocation: Vector,HitNormal: Vector,HitComponent: PrimitiveComponent,BoneName: string,ShotFromDirection: Vector,InstigatedBy: Controller,DamageCauser: Actor,HitInfo: HitResult): void;
	ReceiveHit(MyComp: PrimitiveComponent,Other: Actor,OtherComp: PrimitiveComponent,bSelfMoved: boolean,HitLocation: Vector,HitNormal: Vector,NormalImpulse: Vector,Hit: HitResult): void;
	ReceiveEndPlay(EndPlayReason: EEndPlayReason): void;
	ReceiveDestroyed(): void;
	ReceiveBeginPlay(): void;
	ReceiveAsyncPhysicsTick(DeltaSeconds: number,SimSeconds: number): void;
	ReceiveAnyDamage(Damage: number,DamageType: DamageType,InstigatedBy: Controller,DamageCauser: Actor): void;
	ReceiveActorOnReleased(ButtonReleased: Key): void;
	ReceiveActorOnInputTouchLeave(FingerIndex: ETouchIndex): void;
	ReceiveActorOnInputTouchEnter(FingerIndex: ETouchIndex): void;
	ReceiveActorOnInputTouchEnd(FingerIndex: ETouchIndex): void;
	ReceiveActorOnInputTouchBegin(FingerIndex: ETouchIndex): void;
	ReceiveActorOnClicked(ButtonPressed: Key): void;
	ReceiveActorEndOverlap(OtherActor: Actor): void;
	ReceiveActorEndCursorOver(): void;
	ReceiveActorBeginOverlap(OtherActor: Actor): void;
	ReceiveActorBeginCursorOver(): void;
	PrestreamTextures(Seconds: number,bEnableStreaming: boolean,CinematicTextureGroups: number): void;
	OnRep_ReplicateMovement(): void;
	OnRep_ReplicatedMovement(): void;
	OnRep_Owner(): void;
	OnRep_Instigator(): void;
	OnRep_AttachmentReplication(): void;
	MakeNoise(Loudness: number,NoiseInstigator: Pawn,NoiseLocation: Vector,MaxRange: number,Tag: string): void;
	K2_TeleportTo(DestLocation: Vector,DestRotation: Rotator): boolean;
	K2_SetActorTransform(NewTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult, $: boolean};
	K2_SetActorRotation(NewRotation: Rotator,bTeleportPhysics: boolean): boolean;
	K2_SetActorRelativeTransform(NewRelativeTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetActorRelativeRotation(NewRelativeRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetActorRelativeLocation(NewRelativeLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetActorLocationAndRotation(NewLocation: Vector,NewRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult, $: boolean};
	K2_SetActorLocation(NewLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult, $: boolean};
	K2_OnReset(): void;
	K2_OnEndViewTarget(PC: PlayerController): void;
	K2_OnBecomeViewTarget(PC: PlayerController): void;
	K2_GetRootComponent(): SceneComponent;
	K2_GetComponentsByClass(ComponentClass: UnrealEngineClass): ActorComponent[];
	K2_GetActorRotation(): Rotator;
	K2_GetActorLocation(): Vector;
	K2_DetachFromActor(LocationRule: EDetachmentRule,RotationRule: EDetachmentRule,ScaleRule: EDetachmentRule): void;
	K2_DestroyActor(): void;
	K2_AttachToComponent(Parent: SceneComponent,SocketName: string,LocationRule: EAttachmentRule,RotationRule: EAttachmentRule,ScaleRule: EAttachmentRule,bWeldSimulatedBodies: boolean): void;
	K2_AttachToActor(ParentActor: Actor,SocketName: string,LocationRule: EAttachmentRule,RotationRule: EAttachmentRule,ScaleRule: EAttachmentRule,bWeldSimulatedBodies: boolean): void;
	K2_AttachRootComponentToActor(InParentActor: Actor,InSocketName: string,AttachLocationType: EAttachLocation,bWeldSimulatedBodies: boolean): void;
	K2_AttachRootComponentTo(InParent: SceneComponent,InSocketName: string,AttachLocationType: EAttachLocation,bWeldSimulatedBodies: boolean): void;
	K2_AddActorWorldTransformKeepScale(DeltaTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddActorWorldTransform(DeltaTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddActorWorldRotation(DeltaRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddActorWorldOffset(DeltaLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddActorLocalTransform(NewTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddActorLocalRotation(DeltaRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddActorLocalOffset(DeltaLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	IsTemporarilyHiddenInEditor(bIncludeParent: boolean): boolean;
	IsSelectable(): boolean;
	IsOverlappingActor(Other: Actor): boolean;
	IsHiddenEdAtStartup(): boolean;
	IsHiddenEd(): boolean;
	IsEditable(): boolean;
	IsChildActor(): boolean;
	IsActorTickEnabled(): boolean;
	IsActorBeingDestroyed(): boolean;
	HasAuthority(): boolean;
	GetVerticalDistanceTo(OtherActor: Actor): number;
	GetVelocity(): Vector;
	GetTransform(): Transform;
	GetTickableWhenPaused(): boolean;
	GetSquaredHorizontalDistanceTo(OtherActor: Actor): number;
	GetSquaredDistanceTo(OtherActor: Actor): number;
	GetRemoteRole(): ENetRole;
	GetRayTracingGroupId(): number;
	GetParentComponent(): ChildActorComponent;
	GetParentActor(): Actor;
	GetOwner(): Actor;
	GetOverlappingComponents(OverlappingComponents?: PrimitiveComponent[]): {OverlappingComponents: PrimitiveComponent[]};
	GetOverlappingActors(OverlappingActors?: Actor[],ClassFilter?: UnrealEngineClass): {OverlappingActors: Actor[]};
	GetLocalRole(): ENetRole;
	GetLifeSpan(): number;
	GetLevelTransform(): Transform;
	GetLevel(): Level;
	GetInstigatorController(): Controller;
	GetInstigator(): Pawn;
	GetInputVectorAxisValue(InputAxisKey: Key): Vector;
	GetInputAxisValue(InputAxisName: string): number;
	GetInputAxisKeyValue(InputAxisKey: Key): number;
	GetHorizontalDotProductTo(OtherActor: Actor): number;
	GetHorizontalDistanceTo(OtherActor: Actor): number;
	GetGameTimeSinceCreation(): number;
	GetFolderPath(): string;
	GetDotProductTo(OtherActor: Actor): number;
	GetDistanceTo(OtherActor: Actor): number;
	GetDefaultActorLabel(): string;
	GetComponentsByTag(ComponentClass: UnrealEngineClass,Tag: string): ActorComponent[];
	GetComponentsByInterface(Interface: UnrealEngineClass): ActorComponent[];
	GetComponentByClass(ComponentClass: UnrealEngineClass): ActorComponent;
	GetAttachParentSocketName(): string;
	GetAttachParentActor(): Actor;
	GetAttachedActors(OutActors?: Actor[],bResetArray?: boolean,bRecursivelyIncludeAttachedActors?: boolean): {OutActors: Actor[]};
	GetAllChildActors(ChildActors?: Actor[],bIncludeDescendants?: boolean): {ChildActors: Actor[]};
	GetActorUpVector(): Vector;
	GetActorTimeDilation(): number;
	GetActorTickInterval(): number;
	GetActorScale3D(): Vector;
	GetActorRightVector(): Vector;
	GetActorRelativeScale3D(): Vector;
	GetActorLabel(bCreateIfNone: boolean): string;
	GetActorForwardVector(): Vector;
	GetActorEyesViewPoint(OutLocation?: Vector,OutRotation?: Rotator): {OutLocation: Vector, OutRotation: Rotator};
	GetActorEnableCollision(): boolean;
	GetActorBounds(bOnlyCollidingComponents: boolean,Origin?: Vector,BoxExtent?: Vector,bIncludeFromChildActors?: boolean): {Origin: Vector, BoxExtent: Vector};
	ForceNetUpdate(): void;
	FlushNetDormancy(): void;
	FinishAddComponent(Component: ActorComponent,bManualAttachment: boolean,RelativeTransform: Transform): void;
	EnableInput(PlayerController: PlayerController): void;
	DisableInput(PlayerController: PlayerController): void;
	DetachRootComponentFromParent(bMaintainWorldPosition: boolean): void;
	AddTickPrerequisiteComponent(PrerequisiteComponent: ActorComponent): void;
	AddTickPrerequisiteActor(PrerequisiteActor: Actor): void;
	AddComponentByClass(Class: UnrealEngineClass,bManualAttachment: boolean,RelativeTransform: Transform,bDeferredFinish: boolean): ActorComponent;
	AddComponent(TemplateName: string,bManualAttachment: boolean,RelativeTransform: Transform,ComponentTemplateContext: UObject,bDeferredFinish: boolean): ActorComponent;
	ActorHasTag(Tag: string): boolean;
	static C(Other: UObject | any): Actor;
	GetWorldPositionFromJavascriptEdViewport(Viewport: JavascriptEdViewport,OutVector?: Vector): {OutVector: Vector, $: boolean};
	ClearActorLabel(): void;
	GetActorLabel(): string;
	GetActorLocation(): Vector;
	GetActorRotation(): Rotator;
	GetFolderPath(): string;
	GetWorldPositionFromViewportClick(Click: JavascriptViewportClick,OutHitResult?: HitResult): {OutHitResult: HitResult, $: boolean};
	IsActorLabelEditable(): boolean;
	OpenCreateBlueprintFromActorDialog(): void;
	SetActorLabel(NewActorLabel: string,bMarkDirty: boolean): void;
	SetActorLabelUnique(NewActorLabel: string,InExistingActorLabels: string[]): void;
	SetActorLocation(NewLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult, $: boolean};
	SetFolderPath(NewFolderPath: string): void;
	SetFolderPath_Recursively(NewFolderPath: string): void;
	SetIsTemporarilyHiddenInEditor(bIsHidden: boolean): void;
	AddActorToLayer(Layer: ActorLayer): void;
	RemoveActorFromLayer(Layer: ActorLayer): void;
	DestroyActor(): boolean;
	PilotLevelActor(): void;
	SetActorSelectionState(bShouldBeSelected: boolean): void;
	Actor_GetWorld(): World;
	GetComponentsByClass(ComponentClass: UnrealEngineClass): ActorComponent[];
	GetLastRenderTime(): number;
	GetLevel(): Level;
	IsPendingKill(): boolean;
	ReregisterAllComponents(): void;
	SetActorFlags(Flags: number): void;
	SetRootComponent(Component: SceneComponent): void;
	GetBoundActionValue(Action: InputAction): InputActionValue;
	ConvertActorToLightWeightInstance(): ActorInstanceHandle;
	GetActorBounds(Origin?: Vector,BoxExtent?: Vector): {Origin: Vector, BoxExtent: Vector};
	ApplyDamage(BaseDamage: number,EventInstigator: Controller,DamageCauser: Actor,DamageTypeClass: UnrealEngineClass): number;
	ApplyPointDamage(BaseDamage: number,HitFromDirection: Vector,HitInfo: HitResult,EventInstigator: Controller,DamageCauser: Actor,DamageTypeClass: UnrealEngineClass): number;
	FinishSpawningActor(SpawnTransform: Transform): Actor;
	K2_AcquireEditorActorElementHandle(bAllowCreate: boolean): ScriptTypedElementHandle;
	GetAIController(): AIController;
	GetBlackboard(): BlackboardComponent;
	AddDeviceVisualizationComponentBlocking(XRDeviceId: XRDeviceId,bManualAttachment: boolean,RelativeTransform: Transform): PrimitiveComponent;
	AddNamedDeviceVisualizationComponentBlocking(SystemName: string,DeviceName: string,bManualAttachment: boolean,RelativeTransform: Transform,XRDeviceId?: XRDeviceId): {XRDeviceId: XRDeviceId, $: PrimitiveComponent};
	static GetWorldPositionFromJavascriptEdViewport(Actor: Actor,Viewport: JavascriptEdViewport,OutVector?: Vector): {OutVector: Vector, $: boolean};
	static ClearActorLabel(Actor: Actor): void;
	static GetActorLabel(Actor: Actor): string;
	static GetActorLocation(Actor: Actor): Vector;
	static GetActorRotation(Actor: Actor): Rotator;
	static GetFolderPath(Actor: Actor): string;
	static GetWorldPositionFromViewportClick(Actor: Actor,Click: JavascriptViewportClick,OutHitResult?: HitResult): {OutHitResult: HitResult, $: boolean};
	static IsActorLabelEditable(Actor: Actor): boolean;
	static OpenCreateBlueprintFromActorDialog(Actor: Actor): void;
	static SetActorLabel(Actor: Actor,NewActorLabel: string,bMarkDirty: boolean): void;
	static SetActorLabelUnique(Actor: Actor,NewActorLabel: string,InExistingActorLabels: string[]): void;
	static SetActorLocation(Actor: Actor,NewLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult, $: boolean};
	static SetFolderPath(Actor: Actor,NewFolderPath: string): void;
	static SetFolderPath_Recursively(Actor: Actor,NewFolderPath: string): void;
	static SetIsTemporarilyHiddenInEditor(Actor: Actor,bIsHidden: boolean): void;
	static AddActorToLayer(InActor: Actor,Layer: ActorLayer): void;
	static RemoveActorFromLayer(InActor: Actor,Layer: ActorLayer): void;
	static DestroyActor(ActorToDestroy: Actor): boolean;
	static PilotLevelActor(ActorToPilot: Actor): void;
	static SetActorSelectionState(Actor: Actor,bShouldBeSelected: boolean): void;
	static Actor_GetWorld(Actor: Actor): World;
	static GetComponentsByClass(Actor: Actor,ComponentClass: UnrealEngineClass): ActorComponent[];
	static GetLastRenderTime(Actor: Actor): number;
	static GetLevel(Actor: Actor): Level;
	static IsPendingKill(InActor: Actor): boolean;
	static ReregisterAllComponents(Actor: Actor): void;
	static SetActorFlags(Actor: Actor,Flags: number): void;
	static SetRootComponent(Actor: Actor,Component: SceneComponent): void;
	static GetBoundActionValue(Actor: Actor,Action: InputAction): InputActionValue;
	static ConvertActorToLightWeightInstance(Actor: Actor): ActorInstanceHandle;
	static GetActorBounds(Actor: Actor,Origin?: Vector,BoxExtent?: Vector): {Origin: Vector, BoxExtent: Vector};
	static ApplyDamage(DamagedActor: Actor,BaseDamage: number,EventInstigator: Controller,DamageCauser: Actor,DamageTypeClass: UnrealEngineClass): number;
	static ApplyPointDamage(DamagedActor: Actor,BaseDamage: number,HitFromDirection: Vector,HitInfo: HitResult,EventInstigator: Controller,DamageCauser: Actor,DamageTypeClass: UnrealEngineClass): number;
	static FinishSpawningActor(Actor: Actor,SpawnTransform: Transform): Actor;
	static K2_AcquireEditorActorElementHandle(Actor: Actor,bAllowCreate: boolean): ScriptTypedElementHandle;
	static GetAIController(ControlledActor: Actor): AIController;
	static GetBlackboard(Target: Actor): BlackboardComponent;
	static AddDeviceVisualizationComponentBlocking(Target: Actor,XRDeviceId: XRDeviceId,bManualAttachment: boolean,RelativeTransform: Transform): PrimitiveComponent;
	static AddNamedDeviceVisualizationComponentBlocking(Target: Actor,SystemName: string,DeviceName: string,bManualAttachment: boolean,RelativeTransform: Transform,XRDeviceId?: XRDeviceId): {XRDeviceId: XRDeviceId, $: PrimitiveComponent};
}

declare class ActorComponent extends UObject { 
	PrimaryComponentTick: ActorComponentTickFunction;
	ComponentTags: string[];
	AssetUserData: AssetUserData[];
	UCSSerializationIndex: number;
	bNetAddressable: boolean;
	bReplicateUsingRegisteredSubObjectList: boolean;
	bReplicates: boolean;
	bCreatedByConstructionScript: boolean;
	bInstanceComponent: boolean;
	bAutoActivate: boolean;
	bIsActive: boolean;
	bEditableWhenInherited: boolean;
	bCanEverAffectNavigation: boolean;
	bIsEditorOnly: boolean;
	bIsVisualizationComponent: boolean;
	bNeedsUCSSerializationIndexEvaluted: boolean;
	CreationMethod: EComponentCreationMethod;
	OnComponentActivated: UnrealEngineMulticastDelegate<(Component: ActorComponent, bReset: boolean) => void>;
	OnComponentDeactivated: UnrealEngineMulticastDelegate<(Component: ActorComponent) => void>;
	UCSModifiedProperties: SimpleMemberReference[];
	static Load(ResourceName: string): ActorComponent;
	static Find(Outer: UObject, ResourceName: string): ActorComponent;
	static GetDefaultObject(): ActorComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorComponent;
	ToggleActive(): void;
	SetTickGroup(NewTickGroup: ETickingGroup): void;
	SetTickableWhenPaused(bTickableWhenPaused: boolean): void;
	SetIsReplicated(ShouldReplicate: boolean): void;
	SetComponentTickIntervalAndCooldown(TickInterval: number): void;
	SetComponentTickInterval(TickInterval: number): void;
	SetComponentTickEnabled(bEnabled: boolean): void;
	SetAutoActivate(bNewAutoActivate: boolean): void;
	SetActive(bNewActive: boolean,bReset: boolean): void;
	RemoveTickPrerequisiteComponent(PrerequisiteComponent: ActorComponent): void;
	RemoveTickPrerequisiteActor(PrerequisiteActor: Actor): void;
	ReceiveTick(DeltaSeconds: number): void;
	ReceiveEndPlay(EndPlayReason: EEndPlayReason): void;
	ReceiveBeginPlay(): void;
	ReceiveAsyncPhysicsTick(DeltaSeconds: number,SimSeconds: number): void;
	OnRep_IsActive(): void;
	K2_DestroyComponent(UObject: UObject): void;
	IsComponentTickEnabled(): boolean;
	IsBeingDestroyed(): boolean;
	IsActive(): boolean;
	GetOwner(): Actor;
	GetComponentTickInterval(): number;
	Deactivate(): void;
	ComponentHasTag(Tag: string): boolean;
	AddTickPrerequisiteComponent(PrerequisiteComponent: ActorComponent): void;
	AddTickPrerequisiteActor(PrerequisiteActor: Actor): void;
	Activate(bReset: boolean): void;
	static C(Other: UObject | any): ActorComponent;
	IsRegistered(): boolean;
	MarkRenderStateDirty(): void;
	RegisterComponent(): void;
	ReregisterComponent(): void;
	UnregisterComponent(): void;
	K2_AcquireEditorComponentElementHandle(bAllowCreate: boolean): ScriptTypedElementHandle;
	static IsRegistered(ActorComponent: ActorComponent): boolean;
	static MarkRenderStateDirty(Component: ActorComponent): void;
	static RegisterComponent(ActorComponent: ActorComponent): void;
	static ReregisterComponent(ActorComponent: ActorComponent): void;
	static UnregisterComponent(ActorComponent: ActorComponent): void;
	static K2_AcquireEditorComponentElementHandle(Component: ActorComponent,bAllowCreate: boolean): ScriptTypedElementHandle;
}

declare class BlueprintComponentChangedPropertyInfo { 
	PropertyName: string;
	ArrayIndex: number;
	PropertyScope: Struct;
	clone() : BlueprintComponentChangedPropertyInfo;
	static C(Other: UObject | any): BlueprintComponentChangedPropertyInfo;
}

declare class BlueprintCookedComponentInstancingData { 
	ChangedPropertyList: BlueprintComponentChangedPropertyInfo[];
	bHasValidCookedData: boolean;
	clone() : BlueprintCookedComponentInstancingData;
	static C(Other: UObject | any): BlueprintCookedComponentInstancingData;
}

declare class BPVariableMetaDataEntry { 
	DataKey: string;
	DataValue: string;
	clone() : BPVariableMetaDataEntry;
	static C(Other: UObject | any): BPVariableMetaDataEntry;
}

declare class SCS_Node extends UObject { 
	ComponentClass: UnrealEngineClass;
	ComponentTemplate: ActorComponent;
	CookedComponentInstancingData: BlueprintCookedComponentInstancingData;
	CategoryName: string;
	AttachToName: string;
	ParentComponentOrVariableName: string;
	ParentComponentOwnerClassName: string;
	bIsParentComponentNative: boolean;
	ChildNodes: SCS_Node[];
	MetaDataArray: BPVariableMetaDataEntry[];
	VariableGuid: Guid;
	bIsNative: boolean;
	NativeComponentName: string;
	bVariableNameAutoGenerated: boolean;
	InternalVariableName: string;
	static Load(ResourceName: string): SCS_Node;
	static Find(Outer: UObject, ResourceName: string): SCS_Node;
	static GetDefaultObject(): SCS_Node;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SCS_Node;
	static C(Other: UObject | any): SCS_Node;
}

declare class SimpleConstructionScript extends UObject { 
	RootNodes: SCS_Node[];
	AllNodes: SCS_Node[];
	DefaultSceneRootNode: SCS_Node;
	RootNode: SCS_Node;
	ActorComponentNodes: SCS_Node[];
	static Load(ResourceName: string): SimpleConstructionScript;
	static Find(Outer: UObject, ResourceName: string): SimpleConstructionScript;
	static GetDefaultObject(): SimpleConstructionScript;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SimpleConstructionScript;
	static C(Other: UObject | any): SimpleConstructionScript;
}

declare class BlueprintMacroCosmeticInfo { 
	clone() : BlueprintMacroCosmeticInfo;
	static C(Other: UObject | any): BlueprintMacroCosmeticInfo;
}

declare type ETimelineLengthMode = 'TL_TimelineLength' | 'TL_LastKeyFrame' | 'TL_MAX';
declare var ETimelineLengthMode : { TL_TimelineLength:'TL_TimelineLength',TL_LastKeyFrame:'TL_LastKeyFrame',TL_MAX:'TL_MAX', };
declare class TTTrackBase { 
	TrackName: string;
	bIsExternalCurve: boolean;
	bIsExpanded: boolean;
	bIsCurveViewSynchronized: boolean;
	clone() : TTTrackBase;
	static C(Other: UObject | any): TTTrackBase;
}

declare class TTEventTrack extends TTTrackBase { 
	FunctionName: string;
	CurveKeys: CurveFloat;
	clone() : TTEventTrack;
	static C(Other: UObject | any): TTEventTrack;
}

declare class TTPropertyTrack extends TTTrackBase { 
	PropertyName: string;
	clone() : TTPropertyTrack;
	static C(Other: UObject | any): TTPropertyTrack;
}

declare class TTFloatTrack extends TTPropertyTrack { 
	CurveFloat: CurveFloat;
	clone() : TTFloatTrack;
	static C(Other: UObject | any): TTFloatTrack;
}

declare class CurveVector extends CurveBase { 
	FloatCurves: RichCurve;
	static Load(ResourceName: string): CurveVector;
	static Find(Outer: UObject, ResourceName: string): CurveVector;
	static GetDefaultObject(): CurveVector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveVector;
	GetVectorValue(InTime: number): Vector;
	static C(Other: UObject | any): CurveVector;
}

declare class TTVectorTrack extends TTPropertyTrack { 
	CurveVector: CurveVector;
	clone() : TTVectorTrack;
	static C(Other: UObject | any): TTVectorTrack;
}

declare class TTLinearColorTrack extends TTPropertyTrack { 
	CurveLinearColor: CurveLinearColor;
	clone() : TTLinearColorTrack;
	static C(Other: UObject | any): TTLinearColorTrack;
}

declare class TTTrackId { 
	TrackType: number;
	TrackIndex: number;
	clone() : TTTrackId;
	static C(Other: UObject | any): TTTrackId;
}

declare class TimelineTemplate extends UObject { 
	TimelineLength: number;
	LengthMode: ETimelineLengthMode;
	bAutoPlay: boolean;
	bLoop: boolean;
	bReplicated: boolean;
	bIgnoreTimeDilation: boolean;
	EventTracks: TTEventTrack[];
	FloatTracks: TTFloatTrack[];
	VectorTracks: TTVectorTrack[];
	LinearColorTracks: TTLinearColorTrack[];
	MetaDataArray: BPVariableMetaDataEntry[];
	TimelineGuid: Guid;
	TimelineTickGroup: ETickingGroup;
	VariableName: string;
	DirectionPropertyName: string;
	UpdateFunctionName: string;
	FinishedFunctionName: string;
	TrackDisplayOrder: TTTrackId[];
	static Load(ResourceName: string): TimelineTemplate;
	static Find(Outer: UObject, ResourceName: string): TimelineTemplate;
	static GetDefaultObject(): TimelineTemplate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TimelineTemplate;
	static C(Other: UObject | any): TimelineTemplate;
}

declare class BPComponentClassOverride { 
	ComponentName: string;
	ComponentClass: UnrealEngineClass;
	clone() : BPComponentClassOverride;
	static C(Other: UObject | any): BPComponentClassOverride;
}

declare class ComponentKey { 
	OwnerClass: UnrealEngineClass;
	SCSVariableName: string;
	AssociatedGuid: Guid;
	clone() : ComponentKey;
	static C(Other: UObject | any): ComponentKey;
}

declare class ComponentOverrideRecord { 
	ComponentClass: UnrealEngineClass;
	ComponentTemplate: ActorComponent;
	ComponentKey: ComponentKey;
	CookedComponentInstancingData: BlueprintCookedComponentInstancingData;
	clone() : ComponentOverrideRecord;
	static C(Other: UObject | any): ComponentOverrideRecord;
}

declare class InheritableComponentHandler extends UObject { 
	Records: ComponentOverrideRecord[];
	UnnecessaryComponents: ActorComponent[];
	static Load(ResourceName: string): InheritableComponentHandler;
	static Find(Outer: UObject, ResourceName: string): InheritableComponentHandler;
	static GetDefaultObject(): InheritableComponentHandler;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InheritableComponentHandler;
	static C(Other: UObject | any): InheritableComponentHandler;
}

declare type ELifetimeCondition = 'COND_None' | 'COND_InitialOnly' | 'COND_OwnerOnly' | 'COND_SkipOwner' | 'COND_SimulatedOnly' | 'COND_AutonomousOnly' | 'COND_SimulatedOrPhysics' | 'COND_InitialOrOwner' | 'COND_Custom' | 'COND_ReplayOrOwner' | 'COND_ReplayOnly' | 'COND_SimulatedOnlyNoReplay' | 'COND_SimulatedOrPhysicsNoReplay' | 'COND_SkipReplay' | 'COND_Never' | 'COND_NetGroup' | 'COND_Max';
declare var ELifetimeCondition : { COND_None:'COND_None',COND_InitialOnly:'COND_InitialOnly',COND_OwnerOnly:'COND_OwnerOnly',COND_SkipOwner:'COND_SkipOwner',COND_SimulatedOnly:'COND_SimulatedOnly',COND_AutonomousOnly:'COND_AutonomousOnly',COND_SimulatedOrPhysics:'COND_SimulatedOrPhysics',COND_InitialOrOwner:'COND_InitialOrOwner',COND_Custom:'COND_Custom',COND_ReplayOrOwner:'COND_ReplayOrOwner',COND_ReplayOnly:'COND_ReplayOnly',COND_SimulatedOnlyNoReplay:'COND_SimulatedOnlyNoReplay',COND_SimulatedOrPhysicsNoReplay:'COND_SimulatedOrPhysicsNoReplay',COND_SkipReplay:'COND_SkipReplay',COND_Never:'COND_Never',COND_NetGroup:'COND_NetGroup',COND_Max:'COND_Max', };
declare class BPVariableDescription { 
	VarName: string;
	VarGuid: Guid;
	VarType: EdGraphPinType;
	FriendlyName: string;
	Category: string;
	PropertyFlags: number;
	RepNotifyFunc: string;
	ReplicationCondition: ELifetimeCondition;
	MetaDataArray: BPVariableMetaDataEntry[];
	DefaultValue: string;
	clone() : BPVariableDescription;
	static C(Other: UObject | any): BPVariableDescription;
}

declare class BPInterfaceDescription { 
	Interface: UnrealEngineClass;
	Graphs: EdGraph[];
	clone() : BPInterfaceDescription;
	static C(Other: UObject | any): BPInterfaceDescription;
}

declare class BPEditorBookmarkNode { 
	NodeGuid: Guid;
	ParentGuid: Guid;
	DisplayName: string;
	clone() : BPEditorBookmarkNode;
	static C(Other: UObject | any): BPEditorBookmarkNode;
}

declare class Breakpoint extends UObject { 
	static Load(ResourceName: string): Breakpoint;
	static Find(Outer: UObject, ResourceName: string): Breakpoint;
	static GetDefaultObject(): Breakpoint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Breakpoint;
	static C(Other: UObject | any): Breakpoint;
}

declare class EdGraphPinReference { 
	OwningNode: EdGraphNode;
	PinId: Guid;
	clone() : EdGraphPinReference;
	static C(Other: UObject | any): EdGraphPinReference;
}

declare class BlueprintExtension extends UObject { 
	static Load(ResourceName: string): BlueprintExtension;
	static Find(Outer: UObject, ResourceName: string): BlueprintExtension;
	static GetDefaultObject(): BlueprintExtension;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintExtension;
	static C(Other: UObject | any): BlueprintExtension;
}

declare class Blueprint extends BlueprintCore { 
	ParentClass: UnrealEngineClass;
	BlueprintType: EBlueprintType;
	bRecompileOnLoad: boolean;
	bHasBeenRegenerated: boolean;
	bIsRegeneratingOnLoad: boolean;
	bBeingCompiled: boolean;
	bIsNewlyCreated: boolean;
	bForceFullEditor: boolean;
	bQueuedForCompilation: boolean;
	bRunConstructionScriptOnDrag: boolean;
	bRunConstructionScriptInSequencer: boolean;
	bGenerateConstClass: boolean;
	bGenerateAbstractClass: boolean;
	bDisplayCompilePIEWarning: boolean;
	bDeprecate: boolean;
	bDuplicatingReadOnly: boolean;
	ShouldCookPropertyGuidsValue: EShouldCookBlueprintPropertyGuids;
	NativizationFlag: EBlueprintNativizationFlag;
	CompileMode: EBlueprintCompileMode;
	Status: EBlueprintStatus;
	BlueprintDisplayName: string;
	BlueprintDescription: string;
	BlueprintNamespace: string;
	BlueprintCategory: string;
	HideCategories: string[];
	BlueprintSystemVersion: number;
	SimpleConstructionScript: SimpleConstructionScript;
	UbergraphPages: EdGraph[];
	FunctionGraphs: EdGraph[];
	DelegateSignatureGraphs: EdGraph[];
	MacroGraphs: EdGraph[];
	IntermediateGeneratedGraphs: EdGraph[];
	EventGraphs: EdGraph[];
	PRIVATE_CachedMacroInfo: Map<EdGraph, BlueprintMacroCosmeticInfo>;
	ComponentTemplates: ActorComponent[];
	Timelines: TimelineTemplate[];
	ComponentClassOverrides: BPComponentClassOverride[];
	InheritableComponentHandler: InheritableComponentHandler;
	NewVariables: BPVariableDescription[];
	CategorySorting: string[];
	ImportedNamespaces: Set<string>;
	ImplementedInterfaces: BPInterfaceDescription[];
	LastEditedDocuments: EditedDocumentInfo[];
	Bookmarks: Map<Guid, EditedDocumentInfo>;
	BookmarkNodes: BPEditorBookmarkNode[];
	Breakpoints: Breakpoint[];
	WatchedPins: EdGraphPinReference[];
	DeprecatedPinWatches: EdGraphPin_Deprecated[];
	ComponentTemplateNameIndex: Map<string, number>;
	OldToNewComponentTemplateNames: Map<string, string>;
	Extensions: BlueprintExtension[];
	ThumbnailInfo: ThumbnailInfo;
	CrcLastCompiledCDO: number;
	CrcLastCompiledSignature: number;
	bCachedDependenciesUpToDate: boolean;
	CachedDependencies: Set<Blueprint>;
	CachedDependents: Set<Blueprint>;
	CachedUDSDependencies: Set<Struct>;
	OriginalClass: UnrealEngineClass;
	static Load(ResourceName: string): Blueprint;
	static Find(Outer: UObject, ResourceName: string): Blueprint;
	static GetDefaultObject(): Blueprint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Blueprint;
	static C(Other: UObject | any): Blueprint;
	AddComponentsToBlueprint(Components: ActorComponent[],bHarvesting: boolean,OptionalNewRootComponent: ActorComponent,bKeepMobility: boolean): void;
	CompileBlueprint(): void;
	GetParentClassOfBlueprint(): UnrealEngineClass;
	RemoveComponentFromBlueprint(RemoveComponent: ActorComponent,bPromoteChildren: boolean): void;
	GetBlueprintGeneratedClass(): UnrealEngineClass;
	AddFunctionGraph(FuncName: string): EdGraph;
	CompileBlueprint(): void;
	FindEventGraph(): EdGraph;
	FindGraph(GraphName: string): EdGraph;
	RemoveFunctionGraph(FuncName: string): void;
	RemoveGraph(Graph: EdGraph): void;
	RemoveUnusedNodes(): void;
	RemoveUnusedVariables(): number;
	ReparentBlueprint(NewParentClass: UnrealEngineClass): void;
	ReplaceVariableReferences(OldVarName: string,NewVarName: string): void;
	SetBlueprintVariableExposeOnSpawn(VariableName: string,bExposeOnSpawn: boolean): void;
	SetBlueprintVariableExposeToCinematics(VariableName: string,bExposeToCinematics: boolean): void;
	SetBlueprintVariableInstanceEditable(VariableName: string,bInstanceEditable: boolean): void;
	UpgradeOperatorNodes(): void;
	static AddComponentsToBlueprint(Blueprint: Blueprint,Components: ActorComponent[],bHarvesting: boolean,OptionalNewRootComponent: ActorComponent,bKeepMobility: boolean): void;
	static CompileBlueprint(Blueprint: Blueprint): void;
	static GetParentClassOfBlueprint(Blueprint: Blueprint): UnrealEngineClass;
	static RemoveComponentFromBlueprint(Blueprint: Blueprint,RemoveComponent: ActorComponent,bPromoteChildren: boolean): void;
	static GetBlueprintGeneratedClass(Blueprint: Blueprint): UnrealEngineClass;
	static AddFunctionGraph(Blueprint: Blueprint,FuncName: string): EdGraph;
	static CompileBlueprint(Blueprint: Blueprint): void;
	static FindEventGraph(Blueprint: Blueprint): EdGraph;
	static FindGraph(Blueprint: Blueprint,GraphName: string): EdGraph;
	static RemoveFunctionGraph(Blueprint: Blueprint,FuncName: string): void;
	static RemoveGraph(Blueprint: Blueprint,Graph: EdGraph): void;
	static RemoveUnusedNodes(Blueprint: Blueprint): void;
	static RemoveUnusedVariables(Blueprint: Blueprint): number;
	static ReparentBlueprint(Blueprint: Blueprint,NewParentClass: UnrealEngineClass): void;
	static ReplaceVariableReferences(Blueprint: Blueprint,OldVarName: string,NewVarName: string): void;
	static SetBlueprintVariableExposeOnSpawn(Blueprint: Blueprint,VariableName: string,bExposeOnSpawn: boolean): void;
	static SetBlueprintVariableExposeToCinematics(Blueprint: Blueprint,VariableName: string,bExposeToCinematics: boolean): void;
	static SetBlueprintVariableInstanceEditable(Blueprint: Blueprint,VariableName: string,bInstanceEditable: boolean): void;
	static UpgradeOperatorNodes(Blueprint: Blueprint): void;
}

declare type ERigVMGraphNotifType = 'GraphChanged' | 'NodeAdded' | 'NodeRemoved' | 'NodeSelected' | 'NodeDeselected' | 'NodeSelectionChanged' | 'NodePositionChanged' | 'NodeSizeChanged' | 'NodeColorChanged' | 'PinAdded' | 'PinRemoved' | 'PinRenamed' | 'PinExpansionChanged' | 'PinWatchedChanged' | 'PinArraySizeChanged' | 'PinDefaultValueChanged' | 'PinDirectionChanged' | 'PinTypeChanged' | 'PinIndexChanged' | 'LinkAdded' | 'LinkRemoved' | 'CommentTextChanged' | 'RerouteCompactnessChanged' | 'VariableAdded' | 'VariableRemoved' | 'VariableRenamed' | 'InteractionBracketOpened' | 'InteractionBracketClosed' | 'InteractionBracketCanceled' | 'PinBoundVariableChanged' | 'NodeRenamed' | 'NodeReferenceChanged' | 'NodeCategoryChanged' | 'NodeKeywordsChanged' | 'NodeDescriptionChanged' | 'VariableRemappingChanged' | 'Invalid' | 'ERigVMGraphNotifType_MAX';
declare var ERigVMGraphNotifType : { GraphChanged:'GraphChanged',NodeAdded:'NodeAdded',NodeRemoved:'NodeRemoved',NodeSelected:'NodeSelected',NodeDeselected:'NodeDeselected',NodeSelectionChanged:'NodeSelectionChanged',NodePositionChanged:'NodePositionChanged',NodeSizeChanged:'NodeSizeChanged',NodeColorChanged:'NodeColorChanged',PinAdded:'PinAdded',PinRemoved:'PinRemoved',PinRenamed:'PinRenamed',PinExpansionChanged:'PinExpansionChanged',PinWatchedChanged:'PinWatchedChanged',PinArraySizeChanged:'PinArraySizeChanged',PinDefaultValueChanged:'PinDefaultValueChanged',PinDirectionChanged:'PinDirectionChanged',PinTypeChanged:'PinTypeChanged',PinIndexChanged:'PinIndexChanged',LinkAdded:'LinkAdded',LinkRemoved:'LinkRemoved',CommentTextChanged:'CommentTextChanged',RerouteCompactnessChanged:'RerouteCompactnessChanged',VariableAdded:'VariableAdded',VariableRemoved:'VariableRemoved',VariableRenamed:'VariableRenamed',InteractionBracketOpened:'InteractionBracketOpened',InteractionBracketClosed:'InteractionBracketClosed',InteractionBracketCanceled:'InteractionBracketCanceled',PinBoundVariableChanged:'PinBoundVariableChanged',NodeRenamed:'NodeRenamed',NodeReferenceChanged:'NodeReferenceChanged',NodeCategoryChanged:'NodeCategoryChanged',NodeKeywordsChanged:'NodeKeywordsChanged',NodeDescriptionChanged:'NodeDescriptionChanged',VariableRemappingChanged:'VariableRemappingChanged',Invalid:'Invalid',ERigVMGraphNotifType_MAX:'ERigVMGraphNotifType_MAX', };
declare type ERigVMPinDirection = 'Input' | 'Output' | 'IO' | 'Visible' | 'Hidden' | 'Invalid' | 'ERigVMPinDirection_MAX';
declare var ERigVMPinDirection : { Input:'Input',Output:'Output',IO:'IO',Visible:'Visible',Hidden:'Hidden',Invalid:'Invalid',ERigVMPinDirection_MAX:'ERigVMPinDirection_MAX', };
declare class RigVMLink extends UObject { 
	SourcePinPath: string;
	TargetPinPath: string;
	static Load(ResourceName: string): RigVMLink;
	static Find(Outer: UObject, ResourceName: string): RigVMLink;
	static GetDefaultObject(): RigVMLink;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMLink;
	GetTargetPin(): RigVMPin;
	GetSourcePin(): RigVMPin;
	GetPinPathRepresentation(): string;
	GetOppositePin(InPin: RigVMPin): RigVMPin;
	GetLinkIndex(): number;
	GetGraph(): RigVMGraph;
	static C(Other: UObject | any): RigVMLink;
}

declare class RigVMTemplatePreferredType { 
	Argument: string;
	TypeIndex: number;
	TypeString: string;
	clone() : RigVMTemplatePreferredType;
	static C(Other: UObject | any): RigVMTemplatePreferredType;
}

declare class RigVMTemplateNode extends RigVMNode { 
	TemplateNotation: string;
	ResolvedFunctionName: string;
	PreferredPermutationTypes: string[];
	PreferredPermutationPairs: RigVMTemplatePreferredType[];
	static Load(ResourceName: string): RigVMTemplateNode;
	static Find(Outer: UObject, ResourceName: string): RigVMTemplateNode;
	static GetDefaultObject(): RigVMTemplateNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMTemplateNode;
	IsSingleton(): boolean;
	IsResolved(): boolean;
	IsFullyUnresolved(): boolean;
	GetScriptStruct(): ScriptStruct;
	GetNotation(): string;
	static C(Other: UObject | any): RigVMTemplateNode;
}

declare class RigVMUnitNode extends RigVMTemplateNode { 
	ScriptStruct: ScriptStruct;
	MethodName: string;
	static Load(ResourceName: string): RigVMUnitNode;
	static Find(Outer: UObject, ResourceName: string): RigVMUnitNode;
	static GetDefaultObject(): RigVMUnitNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMUnitNode;
	GetStructDefaultValue(): string;
	GetMethodName(): string;
	static C(Other: UObject | any): RigVMUnitNode;
}

declare class RigVMInjectionInfo extends UObject { 
	UnitNode: RigVMUnitNode;
	UNode: RigVMNode;
	bInjectedAsInput: boolean;
	InputPin: RigVMPin;
	OutputPin: RigVMPin;
	static Load(ResourceName: string): RigVMInjectionInfo;
	static Find(Outer: UObject, ResourceName: string): RigVMInjectionInfo;
	static GetDefaultObject(): RigVMInjectionInfo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMInjectionInfo;
	GetPin(): RigVMPin;
	GetGraph(): RigVMGraph;
	static C(Other: UObject | any): RigVMInjectionInfo;
}

declare class RigVMPin extends UObject { 
	DisplayName: string;
	Direction: ERigVMPinDirection;
	bIsExpanded: boolean;
	bIsConstant: boolean;
	bRequiresWatch: boolean;
	bIsDynamicArray: boolean;
	CPPType: string;
	CPPTypeObject: UObject;
	CPPTypeObjectPath: string;
	DefaultValue: string;
	CustomWidgetName: string;
	SubPins: RigVMPin[];
	Links: RigVMLink[];
	InjectionInfos: RigVMInjectionInfo[];
	BoundVariablePath: string;
	static Load(ResourceName: string): RigVMPin;
	static Find(Outer: UObject, ResourceName: string): RigVMPin;
	static GetDefaultObject(): RigVMPin;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMPin;
	RequiresWatch(bCheckExposedPinChain: boolean): boolean;
	IsWildCard(): boolean;
	IsUObject(): boolean;
	IsStructMember(): boolean;
	IsStruct(): boolean;
	IsStringType(): boolean;
	IsRootPin(): boolean;
	IsReferenceCountedContainer(): boolean;
	IsLinkedTo(InPin: RigVMPin): boolean;
	IsInterface(): boolean;
	IsExpanded(): boolean;
	IsExecuteContext(): boolean;
	IsEnum(): boolean;
	IsDynamicArray(): boolean;
	IsDefinedAsConstant(): boolean;
	IsArrayElement(): boolean;
	IsArray(): boolean;
	GetToolTipText(): string;
	GetTargetLinks(bRecursive: boolean): RigVMLink[];
	GetSubPins(): RigVMPin[];
	GetSubPinPath(InParentPin: RigVMPin,bIncludeParentPinName: boolean): string;
	GetSourceLinks(bRecursive: boolean): RigVMLink[];
	GetSegmentPath(bIncludeRootPin: boolean): string;
	GetScriptStruct(): ScriptStruct;
	GetRootPin(): RigVMPin;
	GetPinPath(bUseNodePath: boolean): string;
	GetPinIndex(): number;
	GetPinForLink(): RigVMPin;
	GetParentPin(): RigVMPin;
	GetOriginalPinFromInjectedNode(): RigVMPin;
	GetNode(): RigVMNode;
	GetLinks(): RigVMLink[];
	GetLinkedTargetPins(bRecursive: boolean): RigVMPin[];
	GetLinkedSourcePins(bRecursive: boolean): RigVMPin[];
	GetGraph(): RigVMGraph;
	GetEnum(): Enum;
	GetDisplayName(): string;
	GetDirection(): ERigVMPinDirection;
	GetDefaultValue(): string;
	GetCustomWidgetName(): string;
	GetCPPTypeObject(): UObject;
	GetCPPType(): string;
	GetArraySize(): number;
	GetArrayElementCppType(): string;
	GetAbsolutePinIndex(): number;
	FindSubPin(InPinPath: string): RigVMPin;
	FindLinkForPin(InOtherPin: RigVMPin): RigVMLink;
	ContainsWildCardSubPin(): boolean;
	static C(Other: UObject | any): RigVMPin;
}

declare type ERigVMUserWorkflowType = 'Invalid' | 'NodeContext' | 'PinContext' | 'OnPinDefaultChanged' | 'All' | 'ERigVMUserWorkflowType_MAX';
declare var ERigVMUserWorkflowType : { Invalid:'Invalid',NodeContext:'NodeContext',PinContext:'PinContext',OnPinDefaultChanged:'OnPinDefaultChanged',All:'All',ERigVMUserWorkflowType_MAX:'ERigVMUserWorkflowType_MAX', };
declare class RigVMUserWorkflowOptions extends UObject { 
	Subject: UObject;
	Workflow: RigVMUserWorkflow;
	static Load(ResourceName: string): RigVMUserWorkflowOptions;
	static Find(Outer: UObject, ResourceName: string): RigVMUserWorkflowOptions;
	static GetDefaultObject(): RigVMUserWorkflowOptions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMUserWorkflowOptions;
	RequiresDialog(): boolean;
	ReportWarning(InMessage: string): void;
	ReportInfo(InMessage: string): void;
	ReportError(InMessage: string): void;
	IsValid(): boolean;
	static C(Other: UObject | any): RigVMUserWorkflowOptions;
}

declare class RigVMUserWorkflow { 
	Title: string;
	Tooltip: string;
	Type: ERigVMUserWorkflowType;
	PerformDynamicDelegate: UnrealEngineDelegate<(InOptions: RigVMUserWorkflowOptions, InController: UObject) => boolean>;
	OptionsClass: UnrealEngineClass;
	clone() : RigVMUserWorkflow;
	static C(Other: UObject | any): RigVMUserWorkflow;
}

declare class RigVMNode extends UObject { 
	NodeTitle: string;
	Position: Vector2D;
	Size: Vector2D;
	NodeColor: LinearColor;
	PreviousName: string;
	bHasBreakpoint: boolean;
	bHaltedAtThisNode: boolean;
	Pins: RigVMPin[];
	OrphanedPins: RigVMPin[];
	static Load(ResourceName: string): RigVMNode;
	static Find(Outer: UObject, ResourceName: string): RigVMNode;
	static GetDefaultObject(): RigVMNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMNode;
	SetHasBreakpoint(bValue: boolean): void;
	SetExecutionIsHaltedAtThisNode(bValue: boolean): void;
	IsVisibleInUI(): boolean;
	IsSelected(): boolean;
	IsPure(): boolean;
	IsMutable(): boolean;
	IsLoopNode(): boolean;
	IsLinkedTo(InNode: RigVMNode): boolean;
	IsInputAggregate(): boolean;
	IsInjected(): boolean;
	IsEvent(): boolean;
	IsDefinedAsVarying(): boolean;
	IsDefinedAsConstant(): boolean;
	IsAggregate(): boolean;
	HasPinOfDirection(InDirection: ERigVMPinDirection): boolean;
	HasOutputPin(bIncludeIO: boolean): boolean;
	HasOrphanedPins(): boolean;
	HasIOPin(): boolean;
	HasInputPin(bIncludeIO: boolean): boolean;
	HasBreakpoint(): boolean;
	GetToolTipText(): string;
	GetSupportedWorkflows(InType: ERigVMUserWorkflowType,InSubject: UObject): RigVMUserWorkflow[];
	GetSize(): Vector2D;
	GetSecondAggregatePin(): RigVMPin;
	GetRootGraph(): RigVMGraph;
	GetPreviousFName(): string;
	GetPosition(): Vector2D;
	GetPins(): RigVMPin[];
	GetOrphanedPins(): RigVMPin[];
	GetOppositeAggregatePin(): RigVMPin;
	GetNodeTitle(): string;
	GetNodePath(bRecursive: boolean): string;
	GetNodeIndex(): number;
	GetNodeColor(): LinearColor;
	GetNextAggregateName(InLastAggregatePinName: string): string;
	GetLinks(): RigVMLink[];
	GetLinkedTargetNodes(): RigVMNode[];
	GetLinkedSourceNodes(): RigVMNode[];
	GetInjectionInfo(): RigVMInjectionInfo;
	GetGraph(): RigVMGraph;
	GetFirstAggregatePin(): RigVMPin;
	GetEventName(): string;
	GetAllPinsRecursively(): RigVMPin[];
	GetAggregateOutputs(): RigVMPin[];
	GetAggregateInputs(): RigVMPin[];
	FindPin(InPinPath: string): RigVMPin;
	ExecutionIsHaltedAtThisNode(): boolean;
	CanOnlyExistOnce(): boolean;
	CanBeUpgraded(): boolean;
	static C(Other: UObject | any): RigVMNode;
}

declare class RigVMGraphVariableDescription { 
	Name: string;
	CPPType: string;
	CPPTypeObject: UObject;
	DefaultValue: string;
	clone() : RigVMGraphVariableDescription;
	static C(Other: UObject | any): RigVMGraphVariableDescription;
}

declare class RigVMLibraryNode extends RigVMTemplateNode { 
	static Load(ResourceName: string): RigVMLibraryNode;
	static Find(Outer: UObject, ResourceName: string): RigVMLibraryNode;
	static GetDefaultObject(): RigVMLibraryNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMLibraryNode;
	GetLibrary(): RigVMFunctionLibrary;
	GetContainedGraph(): RigVMGraph;
	static C(Other: UObject | any): RigVMLibraryNode;
}

declare class RigVMFunctionReferenceNode extends RigVMLibraryNode { 
	ReferencedNodePtr: RigVMLibraryNode;
	VariableMap: Map<string, string>;
	static Load(ResourceName: string): RigVMFunctionReferenceNode;
	static Find(Outer: UObject, ResourceName: string): RigVMFunctionReferenceNode;
	static GetDefaultObject(): RigVMFunctionReferenceNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMFunctionReferenceNode;
	static C(Other: UObject | any): RigVMFunctionReferenceNode;
}

declare class RigVMFunctionReferenceArray { 
	FunctionReferences: RigVMFunctionReferenceNode[];
	clone() : RigVMFunctionReferenceArray;
	static C(Other: UObject | any): RigVMFunctionReferenceArray;
}

declare class RigVMBuildData extends UObject { 
	FunctionReferences: Map<RigVMLibraryNode, RigVMFunctionReferenceArray>;
	static Load(ResourceName: string): RigVMBuildData;
	static Find(Outer: UObject, ResourceName: string): RigVMBuildData;
	static GetDefaultObject(): RigVMBuildData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMBuildData;
	static C(Other: UObject | any): RigVMBuildData;
}

declare class RigVMFunctionLibrary extends RigVMGraph { 
	FunctionReferences: Map<RigVMLibraryNode, RigVMFunctionReferenceArray>;
	LocalizedFunctions: Map<string, RigVMLibraryNode>;
	static Load(ResourceName: string): RigVMFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): RigVMFunctionLibrary;
	static GetDefaultObject(): RigVMFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMFunctionLibrary;
	GetReferencesForFunction(InFunctionName: string): RigVMFunctionReferenceNode[];
	GetReferencePathsForFunction(InFunctionName: string): string[];
	GetFunctions(): RigVMLibraryNode[];
	GetBuildData(): RigVMBuildData;
	FindFunctionForNode(InNode: RigVMNode): RigVMLibraryNode;
	FindFunction(InFunctionName: string): RigVMLibraryNode;
	static C(Other: UObject | any): RigVMFunctionLibrary;
}

declare class RigVMFunctionReturnNode extends RigVMTemplateNode { 
	static Load(ResourceName: string): RigVMFunctionReturnNode;
	static Find(Outer: UObject, ResourceName: string): RigVMFunctionReturnNode;
	static GetDefaultObject(): RigVMFunctionReturnNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMFunctionReturnNode;
	static C(Other: UObject | any): RigVMFunctionReturnNode;
}

declare class RigVMFunctionEntryNode extends RigVMTemplateNode { 
	static Load(ResourceName: string): RigVMFunctionEntryNode;
	static Find(Outer: UObject, ResourceName: string): RigVMFunctionEntryNode;
	static GetDefaultObject(): RigVMFunctionEntryNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMFunctionEntryNode;
	static C(Other: UObject | any): RigVMFunctionEntryNode;
}

declare class RigVMGraph extends UObject { 
	Nodes: RigVMNode[];
	Links: RigVMLink[];
	SelectedNodes: string[];
	DefaultFunctionLibraryPtr: RigVMGraph;
	ExecuteContextStruct: ScriptStruct;
	bEditable: boolean;
	LocalVariables: RigVMGraphVariableDescription[];
	static Load(ResourceName: string): RigVMGraph;
	static Find(Outer: UObject, ResourceName: string): RigVMGraph;
	static GetDefaultObject(): RigVMGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMGraph;
	SetDefaultFunctionLibrary(InFunctionLibrary: RigVMFunctionLibrary): void;
	IsTopLevelGraph(): boolean;
	IsRootGraph(): boolean;
	IsNodeSelected(InNodeName: string): boolean;
	GetVariableDescriptions(): RigVMGraphVariableDescription[];
	GetSelectNodes(): string[];
	GetRootGraph(): RigVMGraph;
	GetReturnNode(): RigVMFunctionReturnNode;
	GetParentGraph(): RigVMGraph;
	GetOutputArguments(): RigVMGraphVariableDescription[];
	GetNodes(): RigVMNode[];
	GetNodePath(): string;
	GetLocalVariables(bIncludeInputArguments: boolean): RigVMGraphVariableDescription[];
	GetLinks(): RigVMLink[];
	GetInputArguments(): RigVMGraphVariableDescription[];
	GetGraphName(): string;
	GetEntryNode(): RigVMFunctionEntryNode;
	GetDefaultFunctionLibrary(): RigVMFunctionLibrary;
	GetContainedGraphs(bRecursive: boolean): RigVMGraph[];
	FindPin(InPinPath: string): RigVMPin;
	FindNodeByName(InNodeName: string): RigVMNode;
	FindNode(InNodePath: string): RigVMNode;
	FindLink(InLinkPinPathRepresentation: string): RigVMLink;
	static C(Other: UObject | any): RigVMGraph;
}

declare class RigVMActionKey { 
	ScriptStructPath: string;
	ExportedText: string;
	clone() : RigVMActionKey;
	static C(Other: UObject | any): RigVMActionKey;
}

declare class RigVMActionStack extends UObject { 
	ActionIndex: number;
	UndoActions: RigVMActionKey[];
	RedoActions: RigVMActionKey[];
	static Load(ResourceName: string): RigVMActionStack;
	static Find(Outer: UObject, ResourceName: string): RigVMActionStack;
	static GetDefaultObject(): RigVMActionStack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMActionStack;
	Undo(InController: RigVMController): boolean;
	Redo(InController: RigVMController): boolean;
	OpenUndoBracket(InTitle: string): boolean;
	CloseUndoBracket(InController: RigVMController): boolean;
	CancelUndoBracket(InController: RigVMController): boolean;
	static C(Other: UObject | any): RigVMActionStack;
}

declare class RigVMCollapseNode extends RigVMLibraryNode { 
	ContainedGraph: RigVMGraph;
	NodeCategory: string;
	NodeKeywords: string;
	NodeDescription: string;
	static Load(ResourceName: string): RigVMCollapseNode;
	static Find(Outer: UObject, ResourceName: string): RigVMCollapseNode;
	static GetDefaultObject(): RigVMCollapseNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMCollapseNode;
	static C(Other: UObject | any): RigVMCollapseNode;
}

declare class RigVMVariableNode extends RigVMNode { 
	static Load(ResourceName: string): RigVMVariableNode;
	static Find(Outer: UObject, ResourceName: string): RigVMVariableNode;
	static GetDefaultObject(): RigVMVariableNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMVariableNode;
	IsLocalVariable(): boolean;
	IsInputArgument(): boolean;
	IsGetter(): boolean;
	IsExternalVariable(): boolean;
	GetVariableName(): string;
	GetVariableDescription(): RigVMGraphVariableDescription;
	GetDefaultValue(): string;
	GetCPPTypeObject(): UObject;
	GetCPPType(): string;
	static C(Other: UObject | any): RigVMVariableNode;
}

declare class RigVMSelectNode extends RigVMTemplateNode { 
	static Load(ResourceName: string): RigVMSelectNode;
	static Find(Outer: UObject, ResourceName: string): RigVMSelectNode;
	static GetDefaultObject(): RigVMSelectNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMSelectNode;
	static C(Other: UObject | any): RigVMSelectNode;
}

declare class RigVMRerouteNode extends RigVMTemplateNode { 
	bShowAsFullNode: boolean;
	static Load(ResourceName: string): RigVMRerouteNode;
	static Find(Outer: UObject, ResourceName: string): RigVMRerouteNode;
	static GetDefaultObject(): RigVMRerouteNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMRerouteNode;
	GetShowsAsFullNode(): boolean;
	static C(Other: UObject | any): RigVMRerouteNode;
}

declare class RigVMGraphParameterDescription { 
	Name: string;
	bIsInput: boolean;
	CPPType: string;
	CPPTypeObject: UObject;
	DefaultValue: string;
	clone() : RigVMGraphParameterDescription;
	static C(Other: UObject | any): RigVMGraphParameterDescription;
}

declare class RigVMParameterNode extends RigVMNode { 
	static Load(ResourceName: string): RigVMParameterNode;
	static Find(Outer: UObject, ResourceName: string): RigVMParameterNode;
	static GetDefaultObject(): RigVMParameterNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMParameterNode;
	IsInput(): boolean;
	GetParameterName(): string;
	GetParameterDescription(): RigVMGraphParameterDescription;
	GetDefaultValue(): string;
	GetCPPTypeObject(): UObject;
	GetCPPType(): string;
	static C(Other: UObject | any): RigVMParameterNode;
}

declare class RigVMInvokeEntryNode extends RigVMNode { 
	static Load(ResourceName: string): RigVMInvokeEntryNode;
	static Find(Outer: UObject, ResourceName: string): RigVMInvokeEntryNode;
	static GetDefaultObject(): RigVMInvokeEntryNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMInvokeEntryNode;
	GetEntryName(): string;
	static C(Other: UObject | any): RigVMInvokeEntryNode;
}

declare class RigVMIfNode extends RigVMTemplateNode { 
	static Load(ResourceName: string): RigVMIfNode;
	static Find(Outer: UObject, ResourceName: string): RigVMIfNode;
	static GetDefaultObject(): RigVMIfNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMIfNode;
	static C(Other: UObject | any): RigVMIfNode;
}

declare class RigVMEnumNode extends RigVMNode { 
	static Load(ResourceName: string): RigVMEnumNode;
	static Find(Outer: UObject, ResourceName: string): RigVMEnumNode;
	static GetDefaultObject(): RigVMEnumNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMEnumNode;
	GetEnum(): Enum;
	GetCPPTypeObject(): UObject;
	GetCPPType(): string;
	static C(Other: UObject | any): RigVMEnumNode;
}

declare class RigVMCommentNode extends RigVMNode { 
	CommentText: string;
	FontSize: number;
	bBubbleVisible: boolean;
	bColorBubble: boolean;
	static Load(ResourceName: string): RigVMCommentNode;
	static Find(Outer: UObject, ResourceName: string): RigVMCommentNode;
	static GetDefaultObject(): RigVMCommentNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMCommentNode;
	GetCommentText(): string;
	GetCommentFontSize(): number;
	GetCommentColorBubble(): boolean;
	GetCommentBubbleVisible(): boolean;
	static C(Other: UObject | any): RigVMCommentNode;
}

declare class RigVMBranchNode extends RigVMNode { 
	static Load(ResourceName: string): RigVMBranchNode;
	static Find(Outer: UObject, ResourceName: string): RigVMBranchNode;
	static GetDefaultObject(): RigVMBranchNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMBranchNode;
	static C(Other: UObject | any): RigVMBranchNode;
}

declare class RigVMArrayNode extends RigVMTemplateNode { 
	OpCode: ERigVMOpCode;
	static Load(ResourceName: string): RigVMArrayNode;
	static Find(Outer: UObject, ResourceName: string): RigVMArrayNode;
	static GetDefaultObject(): RigVMArrayNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMArrayNode;
	GetOpCode(): ERigVMOpCode;
	GetCPPTypeObject(): UObject;
	GetCPPType(): string;
	static C(Other: UObject | any): RigVMArrayNode;
}

declare class RigVMController extends UObject { 
	ModifiedEventDynamic: UnrealEngineMulticastDelegate<(NotifType: ERigVMGraphNotifType, Graph: RigVMGraph, Subject: UObject) => void>;
	Graphs: RigVMGraph[];
	ActionStack: RigVMActionStack;
	static Load(ResourceName: string): RigVMController;
	static Find(Outer: UObject, ResourceName: string): RigVMController;
	static GetDefaultObject(): RigVMController;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMController;
	UpgradeNodes(InNodeNames: string[],bRecursive: boolean,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMNode[];
	UnresolveTemplateNodes(InNodeNames: string[],bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	Undo(): boolean;
	UnbindPinFromVariable(InPinPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SetUnitNodeDefaults(InNode: RigVMUnitNode,InDefaults: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SetRerouteCompactnessByName(InNodeName: string,bShowAsFullNode: boolean,bSetupUndoRedo: boolean): boolean;
	SetRerouteCompactness(InNode: RigVMNode,bShowAsFullNode: boolean,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SetRemappedVariable(InFunctionRefNode: RigVMFunctionReferenceNode,InInnerVariableName: string,InOuterVariableName: string,bSetupUndoRedo: boolean): boolean;
	SetPinIsWatched(InPinPath: string,bIsWatched: boolean,bSetupUndoRedo: boolean): boolean;
	SetPinExpansion(InPinPath: string,bIsExpanded: boolean,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SetPinDefaultValue(InPinPath: string,InDefaultValue: string,bResizeArrays: boolean,bSetupUndoRedo: boolean,bMergeUndoAction: boolean,bPrintPythonCommand: boolean): boolean;
	SetNodeSizeByName(InNodeName: string,InSize: Vector2D,bSetupUndoRedo: boolean,bMergeUndoAction: boolean,bPrintPythonCommand: boolean): boolean;
	SetNodeSize(InNode: RigVMNode,InSize: Vector2D,bSetupUndoRedo: boolean,bMergeUndoAction: boolean,bPrintPythonCommand: boolean): boolean;
	SetNodeSelection(InNodeNames: string[],bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SetNodePositionByName(InNodeName: string,InPosition: Vector2D,bSetupUndoRedo: boolean,bMergeUndoAction: boolean,bPrintPythonCommand: boolean): boolean;
	SetNodePosition(InNode: RigVMNode,InPosition: Vector2D,bSetupUndoRedo: boolean,bMergeUndoAction: boolean,bPrintPythonCommand: boolean): boolean;
	SetNodeKeywordsByName(InNodeName: string,InKeywords: string,bSetupUndoRedo: boolean,bMergeUndoAction: boolean): boolean;
	SetNodeKeywords(InNode: RigVMCollapseNode,InKeywords: string,bSetupUndoRedo: boolean,bMergeUndoAction: boolean,bPrintPythonCommand: boolean): boolean;
	SetNodeDescriptionByName(InNodeName: string,InDescription: string,bSetupUndoRedo: boolean,bMergeUndoAction: boolean): boolean;
	SetNodeDescription(InNode: RigVMCollapseNode,InDescription: string,bSetupUndoRedo: boolean,bMergeUndoAction: boolean,bPrintPythonCommand: boolean): boolean;
	SetNodeColorByName(InNodeName: string,InColor: LinearColor,bSetupUndoRedo: boolean,bMergeUndoAction: boolean): boolean;
	SetNodeColor(InNode: RigVMNode,InColor: LinearColor,bSetupUndoRedo: boolean,bMergeUndoAction: boolean,bPrintPythonCommand: boolean): boolean;
	SetNodeCategoryByName(InNodeName: string,InCategory: string,bSetupUndoRedo: boolean,bMergeUndoAction: boolean): boolean;
	SetNodeCategory(InNode: RigVMCollapseNode,InCategory: string,bSetupUndoRedo: boolean,bMergeUndoAction: boolean,bPrintPythonCommand: boolean): boolean;
	SetLocalVariableTypeFromObjectPath(InVariableName: string,InCPPType: string,InCPPTypeObjectPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SetLocalVariableType(InVariableName: string,InCPPType: string,InCPPTypeObject: UObject,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SetLocalVariableDefaultValue(InVariableName: string,InDefaultValue: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean,bNotify: boolean): boolean;
	SetIsRunningUnitTest(bIsRunning: boolean): void;
	SetGraph(InGraph: RigVMGraph): void;
	SetExposedPinIndex(InPinName: string,InNewIndex: number,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SetCommentTextByName(InNodeName: string,InCommentText: string,InCommentFontSize: number,bInCommentBubbleVisible: boolean,bInCommentColorBubble: boolean,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SetCommentText(InNode: RigVMNode,InCommentText: string,InCommentFontSize: number,bInCommentBubbleVisible: boolean,bInCommentColorBubble: boolean,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SetArrayPinSize(InArrayPinPath: string,InSize: number,InDefaultValue: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SelectNodeByName(InNodeName: string,bSelect: boolean,bSetupUndoRedo: boolean): boolean;
	SelectNode(InNode: RigVMNode,bSelect: boolean,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	ResolveWildCardPin(InPinPath: string,InCPPType: string,InCPPTypeObjectPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	ResetPinDefaultValue(InPinPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	ReplaceParameterNodeWithVariable(InNodeName: string,InVariableName: string,InCPPType: string,InCPPTypeObject: UObject,bSetupUndoRedo: boolean): RigVMVariableNode;
	RenameVariable(InOldName: string,InNewName: string,bSetupUndoRedo: boolean): boolean;
	RenameParameter(InOldName: string,InNewName: string,bSetupUndoRedo: boolean): boolean;
	RenameNode(InNode: RigVMNode,InNewName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	RenameLocalVariable(InVariableName: string,InNewVariableName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	RenameFunction(InOldFunctionName: string,InNewFunctionName: string,bSetupUndoRedo: boolean): boolean;
	RenameExposedPin(InOldPinName: string,InNewPinName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	RemoveNodeByName(InNodeName: string,bSetupUndoRedo: boolean,bRecursive: boolean,bPrintPythonCommand: boolean,bRelinkPins: boolean): boolean;
	RemoveNode(InNode: RigVMNode,bSetupUndoRedo: boolean,bRecursive: boolean,bPrintPythonCommand: boolean,bRelinkPins: boolean): boolean;
	RemoveLocalVariable(InVariableName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	RemoveInjectedNode(InPinPath: string,bAsInput: boolean,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	RemoveFunctionFromLibrary(InFunctionName: string,bSetupUndoRedo: boolean): boolean;
	RemoveExposedPin(InPinName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	RemoveArrayPin(InArrayElementPinPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	RemoveAggregatePin(InPinPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	RefreshVariableNode(InNodeName: string,InVariableName: string,InCPPType: string,InCPPTypeObject: UObject,bSetupUndoRedo: boolean,bSetupOrphanPins: boolean): void;
	Redo(): boolean;
	PushGraph(InGraph: RigVMGraph,bSetupUndoRedo: boolean): void;
	PromotePinToVariable(InPinPath: string,bCreateVariableNode: boolean,InNodePosition: Vector2D,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	PromoteFunctionReferenceNodeToCollapseNode(InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean,bRemoveFunctionDefinition: boolean): string;
	PromoteCollapseNodeToFunctionReferenceNode(InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean,InExistingFunctionDefinitionPath: string): string;
	PopGraph(bSetupUndoRedo: boolean): RigVMGraph;
	PerformUserWorkflow(InWorkflow: RigVMUserWorkflow,InOptions: RigVMUserWorkflowOptions,bSetupUndoRedo: boolean): boolean;
	OpenUndoBracket(InTitle: string): boolean;
	MakeVariableNodeFromBinding(InPinPath: string,InNodePosition: Vector2D,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	MakeOptionsForWorkflow(InSubject: UObject,InWorkflow: RigVMUserWorkflow): RigVMUserWorkflowOptions;
	MakeBindingsFromVariableNode(InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	LocalizeFunctions(InFunctionDefinitions: RigVMLibraryNode[],bLocalizeDependentPrivateFunctions: boolean,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): Map<RigVMLibraryNode, RigVMLibraryNode>;
	LocalizeFunction(InFunctionDefinition: RigVMLibraryNode,bLocalizeDependentPrivateFunctions: boolean,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMLibraryNode;
	IsReportingEnabled(): boolean;
	InsertArrayPin(InArrayPinPath: string,InIndex: number,InDefaultValue: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): string;
	ImportNodesFromText(InText: string,bSetupUndoRedo: boolean,bPrintPythonCommands: boolean): string[];
	static GetUnitStructsForTemplate(InNotation: string): ScriptStruct[];
	GetTopLevelGraph(): RigVMGraph;
	static GetTemplateForUnitStruct(InFunction: ScriptStruct,InMethodName: string): string;
	static GetRegisteredUnitStructs(): ScriptStruct[];
	static GetRegisteredTemplates(): string[];
	GetPinDefaultValue(InPinPath: string): string;
	GetGraph(): RigVMGraph;
	GeneratePythonCommands(): string[];
	ExportSelectedNodesToText(): string;
	ExportNodesToText(InNodeNames: string[]): string;
	ExpandLibraryNode(InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMNode[];
	EnableReporting(bEnabled: boolean): void;
	EjectNodeFromPin(InPinPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMNode;
	DuplicateArrayPin(InArrayElementPinPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): string;
	CollapseNodes(InNodeNames: string[],InCollapseNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean,bIsAggregate: boolean): RigVMCollapseNode;
	CloseUndoBracket(): boolean;
	ClearNodeSelection(bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	ClearArrayPin(InArrayPinPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	ChangeExposedPinType(InPinName: string,InCPPType: string,InCPPTypeObjectPath: string,bSetupUndoRedo?: boolean,bSetupOrphanPins?: boolean,bPrintPythonCommand?: boolean): {bSetupUndoRedo: boolean, $: boolean};
	CanImportNodesFromText(InText: string): boolean;
	CancelUndoBracket(): boolean;
	BreakLink(InOutputPinPath: string,InInputPinPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	BreakAllLinks(InPinPath: string,bAsInput: boolean,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	BindPinToVariable(InPinPath: string,InNewBoundVariablePath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	AddVariableNodeFromObjectPath(InVariableName: string,InCPPType: string,InCPPTypeObjectPath: string,bIsGetter: boolean,InDefaultValue: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMVariableNode;
	AddVariableNode(InVariableName: string,InCPPType: string,InCPPTypeObject: UObject,bIsGetter: boolean,InDefaultValue: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMVariableNode;
	AddUnitNodeWithDefaults(InScriptStruct: ScriptStruct,InDefaults: string,InMethodName: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMUnitNode;
	AddUnitNodeFromStructPath(InScriptStructPath: string,InMethodName: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMUnitNode;
	AddUnitNode(InScriptStruct: ScriptStruct,InMethodName: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMUnitNode;
	AddTemplateNode(InNotation: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMTemplateNode;
	AddSelectNodeFromStruct(InScriptStruct: ScriptStruct,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean): RigVMSelectNode;
	AddSelectNode(InCPPType: string,InCPPTypeObjectPath: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMSelectNode;
	AddRerouteNodeOnPin(InPinPath: string,bAsInput: boolean,bShowAsFullNode: boolean,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMRerouteNode;
	AddRerouteNodeOnLinkPath(InLinkPinPathRepresentation: string,bShowAsFullNode: boolean,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMRerouteNode;
	AddRerouteNodeOnLink(InLink: RigVMLink,bShowAsFullNode: boolean,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMRerouteNode;
	AddParameterNodeFromObjectPath(InParameterName: string,InCPPType: string,InCPPTypeObjectPath: string,bIsInput: boolean,InDefaultValue: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMParameterNode;
	AddParameterNode(InParameterName: string,InCPPType: string,InCPPTypeObject: UObject,bIsInput: boolean,InDefaultValue: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMParameterNode;
	AddLocalVariableFromObjectPath(InVariableName: string,InCPPType: string,InCPPTypeObjectPath: string,InDefaultValue: string,bSetupUndoRedo: boolean): RigVMGraphVariableDescription;
	AddLocalVariable(InVariableName: string,InCPPType: string,InCPPTypeObject: UObject,InDefaultValue: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMGraphVariableDescription;
	AddLink(InOutputPinPath: string,InInputPinPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean,InUserDirection: ERigVMPinDirection): boolean;
	AddInvokeEntryNode(InEntryName: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMInvokeEntryNode;
	AddInjectedNodeFromStructPath(InPinPath: string,bAsInput: boolean,InScriptStructPath: string,InMethodName: string,InInputPinName: string,InOutputPinName: string,InNodeName: string,bSetupUndoRedo: boolean): RigVMInjectionInfo;
	AddInjectedNode(InPinPath: string,bAsInput: boolean,InScriptStruct: ScriptStruct,InMethodName: string,InInputPinName: string,InOutputPinName: string,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMInjectionInfo;
	AddIfNodeFromStruct(InScriptStruct: ScriptStruct,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean): RigVMIfNode;
	AddIfNode(InCPPType: string,InCPPTypeObjectPath: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMIfNode;
	AddFunctionToLibrary(InFunctionName: string,bMutable: boolean,InNodePosition: Vector2D,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMLibraryNode;
	AddFunctionReferenceNode(InFunctionDefinition: RigVMLibraryNode,InNodePosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMFunctionReferenceNode;
	AddFreeRerouteNode(bShowAsFullNode: boolean,InCPPType: string,InCPPTypeObjectPath: string,bIsConstant: boolean,InCustomWidgetName: string,InDefaultValue: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean): RigVMRerouteNode;
	AddExposedPin(InPinName: string,InDirection: ERigVMPinDirection,InCPPType: string,InCPPTypeObjectPath: string,InDefaultValue: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): string;
	AddEnumNode(InCPPTypeObjectPath: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMEnumNode;
	AddCommentNode(InCommentText: string,InPosition: Vector2D,InSize: Vector2D,InColor: LinearColor,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMCommentNode;
	AddBranchNode(InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMBranchNode;
	AddArrayPin(InArrayPinPath: string,InDefaultValue: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): string;
	AddArrayNodeFromObjectPath(InOpCode: ERigVMOpCode,InCPPType: string,InCPPTypeObjectPath: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMArrayNode;
	AddArrayNode(InOpCode: ERigVMOpCode,InCPPType: string,InCPPTypeObject: UObject,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMArrayNode;
	AddAggregatePin(InNodeName: string,InPinName: string,InDefaultValue: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): string;
	static C(Other: UObject | any): RigVMController;
}

declare class ControlRigGraph extends EdGraph { 
	ModelNodePath: string;
	bIsFunctionDefinition: boolean;
	TemplateController: RigVMController;
	static Load(ResourceName: string): ControlRigGraph;
	static Find(Outer: UObject, ResourceName: string): ControlRigGraph;
	static GetDefaultObject(): ControlRigGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ControlRigGraph;
	static C(Other: UObject | any): ControlRigGraph;
}

declare class RigGraphDisplaySettings { 
	bShowNodeInstructionIndex: boolean;
	bShowNodeRunCounts: boolean;
	NodeRunLowerBound: number;
	NodeRunLimit: number;
	MinMicroSeconds: number;
	MaxMicroSeconds: number;
	TotalMicroSeconds: number;
	bAutoDetermineRange: boolean;
	LastMinMicroSeconds: number;
	LastMaxMicroSeconds: number;
	MinDurationColor: LinearColor;
	MaxDurationColor: LinearColor;
	clone() : RigGraphDisplaySettings;
	static C(Other: UObject | any): RigGraphDisplaySettings;
}

declare class RigVMParserASTSettings { 
	bFoldAssignments: boolean;
	bFoldLiterals: boolean;
	bFoldConstantBranches: boolean;
	LinksToSkip: RigVMLink[];
	clone() : RigVMParserASTSettings;
	static C(Other: UObject | any): RigVMParserASTSettings;
}

declare class RigVMCompileSettings { 
	SurpressInfoMessages: boolean;
	SurpressWarnings: boolean;
	SurpressErrors: boolean;
	EnablePinWatches: boolean;
	IsPreprocessorPhase: boolean;
	ASTSettings: RigVMParserASTSettings;
	SetupNodeInstructionIndex: boolean;
	clone() : RigVMCompileSettings;
	static C(Other: UObject | any): RigVMCompileSettings;
}

declare class ControlRigPythonSettings { 
	clone() : ControlRigPythonSettings;
	static C(Other: UObject | any): ControlRigPythonSettings;
}

declare class RigVMClient { 
	Models: RigVMGraph[];
	FunctionLibrary: RigVMFunctionLibrary;
	Controllers: Map<SoftObjectPath, RigVMController>;
	UndoRedoIndex: number;
	clone() : RigVMClient;
	static C(Other: UObject | any): RigVMClient;
}

declare class ControlRigPublicFunctionArg { 
	Name: string;
	CPPType: string;
	CPPTypeObjectPath: string;
	bIsArray: boolean;
	Direction: ERigVMPinDirection;
	clone() : ControlRigPublicFunctionArg;
	static C(Other: UObject | any): ControlRigPublicFunctionArg;
}

declare class ControlRigPublicFunctionData { 
	Name: string;
	DisplayName: string;
	Category: string;
	Keywords: string;
	ReturnValue: ControlRigPublicFunctionArg;
	Arguments: ControlRigPublicFunctionArg[];
	clone() : ControlRigPublicFunctionData;
	static C(Other: UObject | any): ControlRigPublicFunctionData;
}

declare class RigVMReferenceNodeData { 
	ReferenceNodePath: string;
	ReferencedFunctionPath: string;
	clone() : RigVMReferenceNodeData;
	static C(Other: UObject | any): RigVMReferenceNodeData;
}

declare type ERigVMMemoryType = 'Work' | 'Literal' | 'External' | 'Debug' | 'Invalid' | 'ERigVMMemoryType_MAX';
declare var ERigVMMemoryType : { Work:'Work',Literal:'Literal',External:'External',Debug:'Debug',Invalid:'Invalid',ERigVMMemoryType_MAX:'ERigVMMemoryType_MAX', };
declare class RigVMOperand { 
	MemoryType: ERigVMMemoryType;
	RegisterIndex: number;
	RegisterOffset: number;
	clone() : RigVMOperand;
	static C(Other: UObject | any): RigVMOperand;
}

declare class RigElement { 
	Name: string;
	Index: number;
	clone() : RigElement;
	static C(Other: UObject | any): RigElement;
}

declare class RigBone extends RigElement { 
	ParentName: string;
	ParentIndex: number;
	InitialTransform: Transform;
	GlobalTransform: Transform;
	LocalTransform: Transform;
	Dependents: number[];
	Type: ERigBoneType;
	clone() : RigBone;
	static C(Other: UObject | any): RigBone;
}

declare class RigBoneHierarchy { 
	Bones: RigBone[];
	clone() : RigBoneHierarchy;
	static C(Other: UObject | any): RigBoneHierarchy;
}

declare type ERigSpaceType = 'Global' | 'Bone' | 'Control' | 'Space' | 'ERigSpaceType_MAX';
declare var ERigSpaceType : { Global:'Global',Bone:'Bone',Control:'Control',Space:'Space',ERigSpaceType_MAX:'ERigSpaceType_MAX', };
declare class RigSpace extends RigElement { 
	SpaceType: ERigSpaceType;
	ParentName: string;
	ParentIndex: number;
	InitialTransform: Transform;
	LocalTransform: Transform;
	clone() : RigSpace;
	static C(Other: UObject | any): RigSpace;
}

declare class RigSpaceHierarchy { 
	Spaces: RigSpace[];
	clone() : RigSpaceHierarchy;
	static C(Other: UObject | any): RigSpaceHierarchy;
}

declare class RigControl extends RigElement { 
	ControlType: ERigControlType;
	DisplayName: string;
	ParentName: string;
	ParentIndex: number;
	SpaceName: string;
	SpaceIndex: number;
	OffsetTransform: Transform;
	InitialValue: RigControlValue;
	Value: RigControlValue;
	PrimaryAxis: ERigControlAxis;
	bIsCurve: boolean;
	bAnimatable: boolean;
	bLimitTranslation: boolean;
	bLimitRotation: boolean;
	bLimitScale: boolean;
	bDrawLimits: boolean;
	MinimumValue: RigControlValue;
	MaximumValue: RigControlValue;
	bGizmoEnabled: boolean;
	bGizmoVisible: boolean;
	GizmoName: string;
	GizmoTransform: Transform;
	GizmoColor: LinearColor;
	Dependents: number[];
	bIsTransientControl: boolean;
	ControlEnum: Enum;
	clone() : RigControl;
	static C(Other: UObject | any): RigControl;
}

declare class RigControlHierarchy { 
	Controls: RigControl[];
	clone() : RigControlHierarchy;
	static C(Other: UObject | any): RigControlHierarchy;
}

declare class RigCurve extends RigElement { 
	Value: number;
	clone() : RigCurve;
	static C(Other: UObject | any): RigCurve;
}

declare class RigCurveContainer { 
	Curves: RigCurve[];
	clone() : RigCurveContainer;
	static C(Other: UObject | any): RigCurveContainer;
}

declare class RigHierarchyContainer { 
	BoneHierarchy: RigBoneHierarchy;
	SpaceHierarchy: RigSpaceHierarchy;
	ControlHierarchy: RigControlHierarchy;
	CurveContainer: RigCurveContainer;
	clone() : RigHierarchyContainer;
	static C(Other: UObject | any): RigHierarchyContainer;
}

declare class ControlRigValidationPass extends UObject { 
	static Load(ResourceName: string): ControlRigValidationPass;
	static Find(Outer: UObject, ResourceName: string): ControlRigValidationPass;
	static GetDefaultObject(): ControlRigValidationPass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ControlRigValidationPass;
	static C(Other: UObject | any): ControlRigValidationPass;
}

declare class ControlRigValidator extends UObject { 
	Passes: ControlRigValidationPass[];
	static Load(ResourceName: string): ControlRigValidator;
	static Find(Outer: UObject, ResourceName: string): ControlRigValidator;
	static GetDefaultObject(): ControlRigValidator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ControlRigValidator;
	static C(Other: UObject | any): ControlRigValidator;
}

declare class ControlRigBlueprint extends Blueprint { 
	FunctionLibraryEdGraph: ControlRigGraph;
	RigGraphDisplaySettings: RigGraphDisplaySettings;
	HierarchySettings: RigHierarchySettings;
	VMRuntimeSettings: RigVMRuntimeSettings;
	VMCompileSettings: RigVMCompileSettings;
	PythonLogSettings: ControlRigPythonSettings;
	Model: RigVMGraph;
	FunctionLibrary: RigVMFunctionLibrary;
	RigVMClient: RigVMClient;
	PublicFunctions: ControlRigPublicFunctionData[];
	FunctionReferenceNodeData: RigVMReferenceNodeData[];
	TemplateModel: RigVMGraph;
	TemplateController: RigVMController;
	PinToOperandMap: Map<string, RigVMOperand>;
	GizmoLibrary: ControlRigShapeLibrary;
	ShapeLibraries: ControlRigShapeLibrary[];
	Statistics: RigVMStatistics;
	DrawContainer: ControlRigDrawContainer;
	Influences: RigInfluenceMapPerEvent;
	HierarchyContainer: RigHierarchyContainer;
	Hierarchy: RigHierarchy;
	bSupportsInversion: boolean;
	bSupportsControls: boolean;
	PreviewSkeletalMesh: SkeletalMesh;
	SourceHierarchyImport: UObject;
	SourceCurveImport: UObject;
	SupportedEventNames: string[];
	bExposesAnimatableControls: boolean;
	bAutoRecompileVM: boolean;
	bVMRecompilationRequired: boolean;
	bIsCompiling: boolean;
	VMRecompilationBracket: number;
	Validator: ControlRigValidator;
	DebugBoneRadius: number;
	static Load(ResourceName: string): ControlRigBlueprint;
	static Find(Outer: UObject, ResourceName: string): ControlRigBlueprint;
	static GetDefaultObject(): ControlRigBlueprint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ControlRigBlueprint;
	SuspendNotifications(bSuspendNotifs: boolean): void;
	SetPreviewMesh(PreviewMesh: SkeletalMesh,bMarkAsDirty: boolean): void;
	RequestControlRigInit(): void;
	RequestAutoVMRecompilation(): void;
	RenameMemberVariable(InOldName: string,InNewName: string): boolean;
	RemoveModel(InName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	RemoveMemberVariable(InName: string): boolean;
	RecompileVMIfRequired(): void;
	RecompileVM(): void;
	GetPreviewMesh(): SkeletalMesh;
	GetOrCreateController(InGraph: RigVMGraph): RigVMController;
	GetModel(InEdGraph: EdGraph): RigVMGraph;
	GetMemberVariables(): RigVMGraphVariableDescription[];
	GetLocalFunctionLibrary(): RigVMFunctionLibrary;
	GetHierarchyController(): RigHierarchyController;
	GetDefaultModel(): RigVMGraph;
	static GetCurrentlyOpenRigBlueprints(): ControlRigBlueprint[];
	GetControlRigClass(): UnrealEngineClass;
	GetControllerByName(InGraphName: string): RigVMController;
	GetController(InGraph: RigVMGraph): RigVMController;
	static GetAvailableRigUnits(): Struct[];
	GetAllModels(): RigVMGraph[];
	GeneratePythonCommands(InNewBlueprintName: string): string[];
	CreateControlRig(): ControlRig;
	ChangeMemberVariableType(InName: string,InCPPType: string,bIsPublic: boolean,bIsReadOnly: boolean,InDefaultValue: string): boolean;
	AddModel(InName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMGraph;
	AddMemberVariable(InName: string,InCPPType: string,bIsPublic: boolean,bIsReadOnly: boolean,InDefaultValue: string): string;
	static C(Other: UObject | any): ControlRigBlueprint;
	GetController(): RigVMController;
	GetHierarchy(): RigHierarchy;
	GetHierarchyController(): RigHierarchyController;
	GetModel(): RigVMGraph;
	GetPreviewMesh(): SkeletalMesh;
	RecompileVM(): void;
	RecompileVMIfRequired(): void;
	RequestAutoVMRecompilation(): void;
	RequestControlRigInit(): void;
	SetPreviewMesh(PreviewMesh: SkeletalMesh,bMarkAsDirty: boolean): void;
	static GetController(InRigBlueprint: ControlRigBlueprint): RigVMController;
	static GetHierarchy(InRigBlueprint: ControlRigBlueprint): RigHierarchy;
	static GetHierarchyController(InRigBlueprint: ControlRigBlueprint): RigHierarchyController;
	static GetModel(InRigBlueprint: ControlRigBlueprint): RigVMGraph;
	static GetPreviewMesh(InRigBlueprint: ControlRigBlueprint): SkeletalMesh;
	static RecompileVM(InRigBlueprint: ControlRigBlueprint): void;
	static RecompileVMIfRequired(InRigBlueprint: ControlRigBlueprint): void;
	static RequestAutoVMRecompilation(InRigBlueprint: ControlRigBlueprint): void;
	static RequestControlRigInit(InRigBlueprint: ControlRigBlueprint): void;
	static SetPreviewMesh(InRigBlueprint: ControlRigBlueprint,PreviewMesh: SkeletalMesh,bMarkAsDirty: boolean): void;
}

declare class DirectoryItem { 
	Name: string;
	bIsDirectory: boolean;
	clone() : DirectoryItem;
	static C(Other: UObject | any): DirectoryItem;
}

declare type EFileRead_JS = 'FILEREAD_None' | 'FILEREAD_NoFail' | 'FILEREAD_Silent' | 'FILEREAD_NotUsedDummy' | 'FILEREAD_AllowWrite' | 'FILEREAD_MAX';
declare var EFileRead_JS : { FILEREAD_None:'FILEREAD_None',FILEREAD_NoFail:'FILEREAD_NoFail',FILEREAD_Silent:'FILEREAD_Silent',FILEREAD_NotUsedDummy:'FILEREAD_NotUsedDummy',FILEREAD_AllowWrite:'FILEREAD_AllowWrite',FILEREAD_MAX:'FILEREAD_MAX', };
declare class JavascriptStubStruct { 
	clone() : JavascriptStubStruct;
	static C(Other: UObject | any): JavascriptStubStruct;
}

declare class JavascriptFunction { 
	clone() : JavascriptFunction;
	static C(Other: UObject | any): JavascriptFunction;
	CallJS(CustomStruct: JavascriptStubStruct): void;
	static CallJS(UFunction: JavascriptFunction,CustomStruct: JavascriptStubStruct): void;
}

declare class ReadStringFromFileHandle { 
	clone() : ReadStringFromFileHandle;
	static C(Other: UObject | any): ReadStringFromFileHandle;
}

declare type EJavascriptEncodingOptions = 'AutoDetect' | 'ForceAnsi' | 'ForceUnicode' | 'ForceUTF8' | 'ForceUTF8WithoutBOM' | 'EJavascriptEncodingOptions_MAX';
declare var EJavascriptEncodingOptions : { AutoDetect:'AutoDetect',ForceAnsi:'ForceAnsi',ForceUnicode:'ForceUnicode',ForceUTF8:'ForceUTF8',ForceUTF8WithoutBOM:'ForceUTF8WithoutBOM',EJavascriptEncodingOptions_MAX:'EJavascriptEncodingOptions_MAX', };
declare class AudioEngineSubsystem extends DynamicSubsystem { 
	static Load(ResourceName: string): AudioEngineSubsystem;
	static Find(Outer: UObject, ResourceName: string): AudioEngineSubsystem;
	static GetDefaultObject(): AudioEngineSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioEngineSubsystem;
	static C(Other: UObject | any): AudioEngineSubsystem;
}

declare class GameInstanceSubsystem extends Subsystem { 
	static Load(ResourceName: string): GameInstanceSubsystem;
	static Find(Outer: UObject, ResourceName: string): GameInstanceSubsystem;
	static GetDefaultObject(): GameInstanceSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameInstanceSubsystem;
	static C(Other: UObject | any): GameInstanceSubsystem;
}

declare class WorldSubsystem extends Subsystem { 
	static Load(ResourceName: string): WorldSubsystem;
	static Find(Outer: UObject, ResourceName: string): WorldSubsystem;
	static GetDefaultObject(): WorldSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldSubsystem;
	static C(Other: UObject | any): WorldSubsystem;
}

declare class CollisionProfileName { 
	Name: string;
	clone() : CollisionProfileName;
	static C(Other: UObject | any): CollisionProfileName;
}

declare type EPropertyAccessChangeNotifyMode = 'Default' | 'Never' | 'Always' | 'EPropertyAccessChangeNotifyMode_MAX';
declare var EPropertyAccessChangeNotifyMode : { Default:'Default',Never:'Never',Always:'Always',EPropertyAccessChangeNotifyMode_MAX:'EPropertyAccessChangeNotifyMode_MAX', };
declare class GenericStruct { 
	Data: number;
	clone() : GenericStruct;
	static C(Other: UObject | any): GenericStruct;
}

declare class UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): UObject;
	static Find(Outer: UObject, ResourceName: string): UObject;
	static StaticClass: any;
	static GetClassObject(): Class;
	static GetDefaultObject(): UObject;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UObject;
	ExecuteUbergraph(EntryPoint: number): void;
	static C(Other: UObject | any): UObject;
	AddWhitelistedObject(): void;
	BroadcastAssetCreated(): void;
	ConditionalBeginDestroybyUObject(): boolean;
	GetUniqueID(): number;
	MarkPackageDirty(): boolean;
	ModifyObject(bAlwaysMarkDirty: boolean): void;
	OpenEditorForAsset(): boolean;
	PostEditChange(): void;
	CastToControlRigBlueprint(Branches?: ECastToControlRigBlueprintCases,AsControlRigBlueprint?: ControlRigBlueprint): {Branches: ECastToControlRigBlueprintCases, AsControlRigBlueprint: ControlRigBlueprint};
	SpawnActorFromObject(Location: Vector,Rotation: Rotator,bTransient: boolean): Actor;
	CheckoutLoadedAsset(): boolean;
	ConsolidateAssets(AssetsToConsolidate: UObject[]): boolean;
	DeleteLoadedAsset(): boolean;
	DuplicateLoadedAsset(DestinationAssetPath: string): UObject;
	GetMetadataTag(Tag: string): string;
	GetMetadataTagValues(): Map<string, string>;
	GetPathNameForLoadedAsset(): string;
	RemoveMetadataTag(Tag: string): void;
	RenameLoadedAsset(DestinationAssetPath: string): boolean;
	SaveLoadedAsset(bOnlyIfIsDirty: boolean): boolean;
	SetMetadataTag(Tag: string,Value: string): void;
	GetCapturableProperties(): string[];
	RenameAsset(NewName: string): void;
	DestroyUObject(): void;
	ConvertRelativePathToFull(RelativePath: string): string;
	CreateEnum(Name: string,DisplayNames: string[],Flags: string[]): Enum;
	CreatePackage(PackageName: string): Package;
	Duplicate(Outer: UObject,Name: string): UObject;
	FindObjectWithOuter(ClassToLookFor: UnrealEngineClass,NameToLookFor: string): UObject;
	FindPackage(PackageName: string): Package;
	GetArchetypePathName(): string;
	GetDir(WhichDir: string): string;
	GetFields(bIncludeSuper: boolean): Field[];
	GetFileSize(Filename: string): number;
	GetName(): string;
	GetObjectsWithOuter(Results?: UObject[],bIncludeNestedObjects?: boolean,ExclusionFlags?: number,ExclusionInternalFlags?: number): {Results: UObject[]};
	GetOuter(): UObject;
	GetOutermost(): UObject;
	HasAnyFlags(Flags: number): boolean;
	ReadDirectory(Directory: string,OutItems?: DirectoryItem[]): {OutItems: DirectoryItem[], $: boolean};
	ReadFile(Filename: string): boolean;
	ReadStringFromFile(Filename: string,ReadFlags: EFileRead_JS): string;
	ReadStringFromFileAsync(Filename: string,UFunction: JavascriptFunction): ReadStringFromFileHandle;
	SetObjectFlags(Flags: number): void;
	WriteFile(Filename: string): boolean;
	WriteStringToFile(Filename: string,Data: string,EncodingOptions: EJavascriptEncodingOptions): boolean;
	GetDatasmithUserData(): DatasmithAssetUserData;
	GetDatasmithUserDataKeysAndValuesForValue(StringToMatch: string,OutKeys?: string[],OutValues?: string[]): {OutKeys: string[], OutValues: string[]};
	GetDatasmithUserDataValueForKey(Key: string,bPartialMatchKey: boolean): string;
	GetDatasmithUserDataValuesForKey(Key: string,bPartialMatchKey: boolean): string[];
	RedirectVislog(DestinationOwner: UObject): void;
	GetAudioEngineSubsystem(Class: UnrealEngineClass): AudioEngineSubsystem;
	GetGameInstanceSubsystem(Class: UnrealEngineClass): GameInstanceSubsystem;
	GetLocalPlayerSubsystem(Class: UnrealEngineClass): LocalPlayerSubsystem;
	GetWorldSubsystem(Class: UnrealEngineClass): WorldSubsystem;
	MarkPropertyDirty(PropertyName: string): void;
	MarkPropertyDirtyFromRepIndex(RepIndex: number,PropertyName: string): void;
	Conv_ObjectToClass(Class: UnrealEngineClass): UnrealEngineClass;
	Conv_ObjectToSoftObjectReference(): UObject;
	Conv_SoftObjectReferenceToObject(): UObject;
	Conv_SoftObjectReferenceToString(): string;
	Conv_SoftObjRefToSoftObjPath(): SoftObjectPath;
	CreateCopyForUndoBuffer(): void;
	DoesImplementInterface(Interface: UnrealEngineClass): boolean;
	EqualEqual_SoftObjectReference(B: UObject): boolean;
	GetDisplayName(): string;
	GetEditorProperty(PropertyName: string,PropertyValue?: number): {PropertyValue: number, $: boolean};
	GetObjectName(): string;
	GetOuterObject(): UObject;
	GetPathName(): string;
	GetPrimaryAssetIdFromObject(): PrimaryAssetId;
	GetPrimaryAssetIdFromSoftObjectReference(): PrimaryAssetId;
	GetSoftObjectPath(): SoftObjectPath;
	GetSystemPath(): string;
	IsValid(): boolean;
	IsValidSoftObjectReference(): boolean;
	K2_ClearTimer(FunctionName: string): void;
	K2_GetTimerElapsedTime(FunctionName: string): number;
	K2_GetTimerRemainingTime(FunctionName: string): number;
	K2_IsTimerActive(FunctionName: string): boolean;
	K2_IsTimerPaused(FunctionName: string): boolean;
	K2_PauseTimer(FunctionName: string): void;
	K2_SetTimer(FunctionName: string,Time: number,bLooping: boolean,InitialStartDelay: number,InitialStartDelayVariance: number): TimerHandle;
	K2_SetTimerForNextTick(FunctionName: string): TimerHandle;
	K2_TimerExists(FunctionName: string): boolean;
	K2_UnPauseTimer(FunctionName: string): void;
	LoadAsset_Blocking(): UObject;
	NotEqual_SoftObjectReference(B: UObject): boolean;
	SetBoolPropertyByName(PropertyName: string,Value: boolean): void;
	SetBytePropertyByName(PropertyName: string,Value: number): void;
	SetClassPropertyByName(PropertyName: string,Value: UnrealEngineClass): void;
	SetCollisionProfileNameProperty(PropertyName: string,Value: CollisionProfileName): void;
	SetColorPropertyByName(PropertyName: string,Value: Color): void;
	SetDoublePropertyByName(PropertyName: string,Value: number): void;
	SetEditorProperty(PropertyName: string,PropertyValue: number,ChangeNotifyMode: EPropertyAccessChangeNotifyMode): boolean;
	SetFieldPathPropertyByName(PropertyName: string,Value: any): void;
	SetInt64PropertyByName(PropertyName: string,Value: number): void;
	SetInterfacePropertyByName(PropertyName: string,Value: Interface): void;
	SetIntPropertyByName(PropertyName: string,Value: number): void;
	SetLinearColorPropertyByName(PropertyName: string,Value: LinearColor): void;
	SetNamePropertyByName(PropertyName: string,Value: string): void;
	SetObjectPropertyByName(PropertyName: string,Value: UObject): void;
	SetRotatorPropertyByName(PropertyName: string,Value: Rotator): void;
	SetSoftClassPropertyByName(PropertyName: string,Value: Class): void;
	SetSoftObjectPropertyByName(PropertyName: string,Value: UObject): void;
	SetStringPropertyByName(PropertyName: string,Value: string): void;
	SetStructurePropertyByName(PropertyName: string,Value: GenericStruct): void;
	SetTextPropertyByName(PropertyName: string,Value: string): void;
	SetTransformPropertyByName(PropertyName: string,Value: Transform): void;
	SetVector3fPropertyByName(PropertyName: string,Value: Vector3f): void;
	SetVectorPropertyByName(PropertyName: string,Value: Vector): void;
	SnapshotObject(): void;
	TransactObject(): void;
	Conv_ObjectToString(): string;
	EqualEqual_ObjectObject(B: UObject): boolean;
	NotEqual_ObjectObject(B: UObject): boolean;
	SelectObject(B: UObject,bSelectA: boolean): UObject;
	SetArrayPropertyByName(PropertyName: string,Value: number[]): void;
	GetObjectClass(): UnrealEngineClass;
	ObjectIsA(ObjectClass: UnrealEngineClass): boolean;
	K2_AcquireEditorObjectElementHandle(bAllowCreate: boolean): ScriptTypedElementHandle;
	SetSetPropertyByName(PropertyName: string,Value: Set<number>): void;
	SetMapPropertyByName(PropertyName: string,Value: Map<number, number>): void;
	Conv_ObjectToText(): string;
	GetBlueprintAsset(): Blueprint;
	static AddWhitelistedObject(InObject: UObject): void;
	static BroadcastAssetCreated(NewAsset: UObject): void;
	static ConditionalBeginDestroybyUObject(TargetObject: UObject): boolean;
	static GetUniqueID(InObject: UObject): number;
	static MarkPackageDirty(InObject: UObject): boolean;
	static ModifyObject(UObject: UObject,bAlwaysMarkDirty: boolean): void;
	static OpenEditorForAsset(Asset: UObject): boolean;
	static PostEditChange(InObject: UObject): void;
	static CastToControlRigBlueprint(UObject: UObject,Branches?: ECastToControlRigBlueprintCases,AsControlRigBlueprint?: ControlRigBlueprint): {Branches: ECastToControlRigBlueprintCases, AsControlRigBlueprint: ControlRigBlueprint};
	static SpawnActorFromObject(ObjectToUse: UObject,Location: Vector,Rotation: Rotator,bTransient: boolean): Actor;
	static CheckoutLoadedAsset(AssetToCheckout: UObject): boolean;
	static ConsolidateAssets(AssetToConsolidateTo: UObject,AssetsToConsolidate: UObject[]): boolean;
	static DeleteLoadedAsset(AssetToDelete: UObject): boolean;
	static DuplicateLoadedAsset(SourceAsset: UObject,DestinationAssetPath: string): UObject;
	static GetMetadataTag(UObject: UObject,Tag: string): string;
	static GetMetadataTagValues(UObject: UObject): Map<string, string>;
	static GetPathNameForLoadedAsset(LoadedAsset: UObject): string;
	static RemoveMetadataTag(UObject: UObject,Tag: string): void;
	static RenameLoadedAsset(SourceAsset: UObject,DestinationAssetPath: string): boolean;
	static SaveLoadedAsset(AssetToSave: UObject,bOnlyIfIsDirty: boolean): boolean;
	static SetMetadataTag(UObject: UObject,Tag: string,Value: string): void;
	static GetCapturableProperties(ActorOrClass: UObject): string[];
	static RenameAsset(Asset: UObject,NewName: string): void;
	static DestroyUObject(UObject: UObject): void;
	static ConvertRelativePathToFull(UObject: UObject,RelativePath: string): string;
	static CreateEnum(Outer: UObject,Name: string,DisplayNames: string[],Flags: string[]): Enum;
	static CreatePackage(Outer: UObject,PackageName: string): Package;
	static Duplicate(UObject: UObject,Outer: UObject,Name: string): UObject;
	static FindObjectWithOuter(Outer: UObject,ClassToLookFor: UnrealEngineClass,NameToLookFor: string): UObject;
	static FindPackage(InOuter: UObject,PackageName: string): Package;
	static GetArchetypePathName(UObject: UObject): string;
	static GetDir(UObject: UObject,WhichDir: string): string;
	static GetFields(UObject: UObject,bIncludeSuper: boolean): Field[];
	static GetFileSize(UObject: UObject,Filename: string): number;
	static GetName(UObject: UObject): string;
	static GetObjectsWithOuter(Outer: UObject,Results?: UObject[],bIncludeNestedObjects?: boolean,ExclusionFlags?: number,ExclusionInternalFlags?: number): {Results: UObject[]};
	static GetOuter(UObject: UObject): UObject;
	static GetOutermost(UObject: UObject): UObject;
	static HasAnyFlags(UObject: UObject,Flags: number): boolean;
	static ReadDirectory(UObject: UObject,Directory: string,OutItems?: DirectoryItem[]): {OutItems: DirectoryItem[], $: boolean};
	static ReadFile(UObject: UObject,Filename: string): boolean;
	static ReadStringFromFile(UObject: UObject,Filename: string,ReadFlags: EFileRead_JS): string;
	static ReadStringFromFileAsync(UObject: UObject,Filename: string,UFunction: JavascriptFunction): ReadStringFromFileHandle;
	static SetObjectFlags(Obj: UObject,Flags: number): void;
	static WriteFile(UObject: UObject,Filename: string): boolean;
	static WriteStringToFile(UObject: UObject,Filename: string,Data: string,EncodingOptions: EJavascriptEncodingOptions): boolean;
	static GetDatasmithUserData(UObject: UObject): DatasmithAssetUserData;
	static GetDatasmithUserDataKeysAndValuesForValue(UObject: UObject,StringToMatch: string,OutKeys?: string[],OutValues?: string[]): {OutKeys: string[], OutValues: string[]};
	static GetDatasmithUserDataValueForKey(UObject: UObject,Key: string,bPartialMatchKey: boolean): string;
	static GetDatasmithUserDataValuesForKey(UObject: UObject,Key: string,bPartialMatchKey: boolean): string[];
	static RedirectVislog(SourceOwner: UObject,DestinationOwner: UObject): void;
	static GetAudioEngineSubsystem(ContextObject: UObject,Class: UnrealEngineClass): AudioEngineSubsystem;
	static GetGameInstanceSubsystem(ContextObject: UObject,Class: UnrealEngineClass): GameInstanceSubsystem;
	static GetLocalPlayerSubsystem(ContextObject: UObject,Class: UnrealEngineClass): LocalPlayerSubsystem;
	static GetWorldSubsystem(ContextObject: UObject,Class: UnrealEngineClass): WorldSubsystem;
	static MarkPropertyDirty(UObject: UObject,PropertyName: string): void;
	static MarkPropertyDirtyFromRepIndex(UObject: UObject,RepIndex: number,PropertyName: string): void;
	static Conv_ObjectToClass(UObject: UObject,Class: UnrealEngineClass): UnrealEngineClass;
	static Conv_ObjectToSoftObjectReference(UObject: UObject): UObject;
	static Conv_SoftObjectReferenceToObject(softobject: UObject): UObject;
	static Conv_SoftObjectReferenceToString(SoftObjectReference: UObject): string;
	static Conv_SoftObjRefToSoftObjPath(SoftObjectReference: UObject): SoftObjectPath;
	static CreateCopyForUndoBuffer(ObjectToModify: UObject): void;
	static DoesImplementInterface(TestObject: UObject,Interface: UnrealEngineClass): boolean;
	static EqualEqual_SoftObjectReference(A: UObject,B: UObject): boolean;
	static GetDisplayName(UObject: UObject): string;
	static GetEditorProperty(UObject: UObject,PropertyName: string,PropertyValue?: number): {PropertyValue: number, $: boolean};
	static GetObjectName(UObject: UObject): string;
	static GetOuterObject(UObject: UObject): UObject;
	static GetPathName(UObject: UObject): string;
	static GetPrimaryAssetIdFromObject(UObject: UObject): PrimaryAssetId;
	static GetPrimaryAssetIdFromSoftObjectReference(SoftObjectReference: UObject): PrimaryAssetId;
	static GetSoftObjectPath(UObject: UObject): SoftObjectPath;
	static GetSystemPath(UObject: UObject): string;
	static IsValid(UObject: UObject): boolean;
	static IsValidSoftObjectReference(SoftObjectReference: UObject): boolean;
	static K2_ClearTimer(UObject: UObject,FunctionName: string): void;
	static K2_GetTimerElapsedTime(UObject: UObject,FunctionName: string): number;
	static K2_GetTimerRemainingTime(UObject: UObject,FunctionName: string): number;
	static K2_IsTimerActive(UObject: UObject,FunctionName: string): boolean;
	static K2_IsTimerPaused(UObject: UObject,FunctionName: string): boolean;
	static K2_PauseTimer(UObject: UObject,FunctionName: string): void;
	static K2_SetTimer(UObject: UObject,FunctionName: string,Time: number,bLooping: boolean,InitialStartDelay: number,InitialStartDelayVariance: number): TimerHandle;
	static K2_SetTimerForNextTick(UObject: UObject,FunctionName: string): TimerHandle;
	static K2_TimerExists(UObject: UObject,FunctionName: string): boolean;
	static K2_UnPauseTimer(UObject: UObject,FunctionName: string): void;
	static LoadAsset_Blocking(Asset: UObject): UObject;
	static NotEqual_SoftObjectReference(A: UObject,B: UObject): boolean;
	static SetBoolPropertyByName(UObject: UObject,PropertyName: string,Value: boolean): void;
	static SetBytePropertyByName(UObject: UObject,PropertyName: string,Value: number): void;
	static SetClassPropertyByName(UObject: UObject,PropertyName: string,Value: UnrealEngineClass): void;
	static SetCollisionProfileNameProperty(UObject: UObject,PropertyName: string,Value: CollisionProfileName): void;
	static SetColorPropertyByName(UObject: UObject,PropertyName: string,Value: Color): void;
	static SetDoublePropertyByName(UObject: UObject,PropertyName: string,Value: number): void;
	static SetEditorProperty(UObject: UObject,PropertyName: string,PropertyValue: number,ChangeNotifyMode: EPropertyAccessChangeNotifyMode): boolean;
	static SetFieldPathPropertyByName(UObject: UObject,PropertyName: string,Value: any): void;
	static SetInt64PropertyByName(UObject: UObject,PropertyName: string,Value: number): void;
	static SetInterfacePropertyByName(UObject: UObject,PropertyName: string,Value: Interface): void;
	static SetIntPropertyByName(UObject: UObject,PropertyName: string,Value: number): void;
	static SetLinearColorPropertyByName(UObject: UObject,PropertyName: string,Value: LinearColor): void;
	static SetNamePropertyByName(UObject: UObject,PropertyName: string,Value: string): void;
	static SetObjectPropertyByName(UObject: UObject,PropertyName: string,Value: UObject): void;
	static SetRotatorPropertyByName(UObject: UObject,PropertyName: string,Value: Rotator): void;
	static SetSoftClassPropertyByName(UObject: UObject,PropertyName: string,Value: Class): void;
	static SetSoftObjectPropertyByName(UObject: UObject,PropertyName: string,Value: UObject): void;
	static SetStringPropertyByName(UObject: UObject,PropertyName: string,Value: string): void;
	static SetStructurePropertyByName(UObject: UObject,PropertyName: string,Value: GenericStruct): void;
	static SetTextPropertyByName(UObject: UObject,PropertyName: string,Value: string): void;
	static SetTransformPropertyByName(UObject: UObject,PropertyName: string,Value: Transform): void;
	static SetVector3fPropertyByName(UObject: UObject,PropertyName: string,Value: Vector3f): void;
	static SetVectorPropertyByName(UObject: UObject,PropertyName: string,Value: Vector): void;
	static SnapshotObject(UObject: UObject): void;
	static TransactObject(UObject: UObject): void;
	static Conv_ObjectToString(InObj: UObject): string;
	static EqualEqual_ObjectObject(A: UObject,B: UObject): boolean;
	static NotEqual_ObjectObject(A: UObject,B: UObject): boolean;
	static SelectObject(A: UObject,B: UObject,bSelectA: boolean): UObject;
	static SetArrayPropertyByName(UObject: UObject,PropertyName: string,Value: number[]): void;
	static GetObjectClass(UObject: UObject): UnrealEngineClass;
	static ObjectIsA(UObject: UObject,ObjectClass: UnrealEngineClass): boolean;
	static K2_AcquireEditorObjectElementHandle(UObject: UObject,bAllowCreate: boolean): ScriptTypedElementHandle;
	static SetSetPropertyByName(UObject: UObject,PropertyName: string,Value: Set<number>): void;
	static SetMapPropertyByName(UObject: UObject,PropertyName: string,Value: Map<number, number>): void;
	static Conv_ObjectToText(InObj: UObject): string;
	static GetBlueprintAsset(UObject: UObject): Blueprint;
}

declare class GCObjectReferencer extends UObject { 
	static Load(ResourceName: string): GCObjectReferencer;
	static Find(Outer: UObject, ResourceName: string): GCObjectReferencer;
	static GetDefaultObject(): GCObjectReferencer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GCObjectReferencer;
	static C(Other: UObject | any): GCObjectReferencer;
}

declare class TextBuffer extends UObject { 
	static Load(ResourceName: string): TextBuffer;
	static Find(Outer: UObject, ResourceName: string): TextBuffer;
	static GetDefaultObject(): TextBuffer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextBuffer;
	static C(Other: UObject | any): TextBuffer;
}

declare class DelegateFunction extends UFunction { 
	static Load(ResourceName: string): DelegateFunction;
	static Find(Outer: UObject, ResourceName: string): DelegateFunction;
	static GetDefaultObject(): DelegateFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DelegateFunction;
	static C(Other: UObject | any): DelegateFunction;
}

declare class SparseDelegateFunction extends DelegateFunction { 
	static Load(ResourceName: string): SparseDelegateFunction;
	static Find(Outer: UObject, ResourceName: string): SparseDelegateFunction;
	static GetDefaultObject(): SparseDelegateFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SparseDelegateFunction;
	static C(Other: UObject | any): SparseDelegateFunction;
}

declare class DynamicClass extends Class { 
	static Load(ResourceName: string): DynamicClass;
	static Find(Outer: UObject, ResourceName: string): DynamicClass;
	static GetDefaultObject(): DynamicClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DynamicClass;
	static C(Other: UObject | any): DynamicClass;
}

declare class LinkerPlaceholderClass extends Class { 
	static Load(ResourceName: string): LinkerPlaceholderClass;
	static Find(Outer: UObject, ResourceName: string): LinkerPlaceholderClass;
	static GetDefaultObject(): LinkerPlaceholderClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LinkerPlaceholderClass;
	static C(Other: UObject | any): LinkerPlaceholderClass;
}

declare class LinkerPlaceholderExportObject extends UObject { 
	static Load(ResourceName: string): LinkerPlaceholderExportObject;
	static Find(Outer: UObject, ResourceName: string): LinkerPlaceholderExportObject;
	static GetDefaultObject(): LinkerPlaceholderExportObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LinkerPlaceholderExportObject;
	static C(Other: UObject | any): LinkerPlaceholderExportObject;
}

declare class LinkerPlaceholderFunction extends UFunction { 
	static Load(ResourceName: string): LinkerPlaceholderFunction;
	static Find(Outer: UObject, ResourceName: string): LinkerPlaceholderFunction;
	static GetDefaultObject(): LinkerPlaceholderFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LinkerPlaceholderFunction;
	static C(Other: UObject | any): LinkerPlaceholderFunction;
}

declare class MetaData extends UObject { 
	static Load(ResourceName: string): MetaData;
	static Find(Outer: UObject, ResourceName: string): MetaData;
	static GetDefaultObject(): MetaData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetaData;
	static C(Other: UObject | any): MetaData;
}

declare class ObjectRedirector extends UObject { 
	static Load(ResourceName: string): ObjectRedirector;
	static Find(Outer: UObject, ResourceName: string): ObjectRedirector;
	static GetDefaultObject(): ObjectRedirector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ObjectRedirector;
	static C(Other: UObject | any): ObjectRedirector;
}

declare class Property extends Field { 
	static Load(ResourceName: string): Property;
	static Find(Outer: UObject, ResourceName: string): Property;
	static GetDefaultObject(): Property;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Property;
	static C(Other: UObject | any): Property;
}

declare class EnumProperty extends Property { 
	static Load(ResourceName: string): EnumProperty;
	static Find(Outer: UObject, ResourceName: string): EnumProperty;
	static GetDefaultObject(): EnumProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnumProperty;
	static C(Other: UObject | any): EnumProperty;
}

declare class ArrayProperty extends Property { 
	static Load(ResourceName: string): ArrayProperty;
	static Find(Outer: UObject, ResourceName: string): ArrayProperty;
	static GetDefaultObject(): ArrayProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ArrayProperty;
	static C(Other: UObject | any): ArrayProperty;
}

declare class ObjectPropertyBase extends Property { 
	static Load(ResourceName: string): ObjectPropertyBase;
	static Find(Outer: UObject, ResourceName: string): ObjectPropertyBase;
	static GetDefaultObject(): ObjectPropertyBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ObjectPropertyBase;
	static C(Other: UObject | any): ObjectPropertyBase;
}

declare class BoolProperty extends Property { 
	static Load(ResourceName: string): BoolProperty;
	static Find(Outer: UObject, ResourceName: string): BoolProperty;
	static GetDefaultObject(): BoolProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BoolProperty;
	static C(Other: UObject | any): BoolProperty;
}

declare class NumericProperty extends Property { 
	static Load(ResourceName: string): NumericProperty;
	static Find(Outer: UObject, ResourceName: string): NumericProperty;
	static GetDefaultObject(): NumericProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NumericProperty;
	static C(Other: UObject | any): NumericProperty;
}

declare class ByteProperty extends NumericProperty { 
	static Load(ResourceName: string): ByteProperty;
	static Find(Outer: UObject, ResourceName: string): ByteProperty;
	static GetDefaultObject(): ByteProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ByteProperty;
	static C(Other: UObject | any): ByteProperty;
}

declare class ObjectProperty extends ObjectPropertyBase { 
	static Load(ResourceName: string): ObjectProperty;
	static Find(Outer: UObject, ResourceName: string): ObjectProperty;
	static GetDefaultObject(): ObjectProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ObjectProperty;
	static C(Other: UObject | any): ObjectProperty;
}

declare class ClassProperty extends ObjectProperty { 
	static Load(ResourceName: string): ClassProperty;
	static Find(Outer: UObject, ResourceName: string): ClassProperty;
	static GetDefaultObject(): ClassProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClassProperty;
	static C(Other: UObject | any): ClassProperty;
}

declare class DelegateProperty extends Property { 
	static Load(ResourceName: string): DelegateProperty;
	static Find(Outer: UObject, ResourceName: string): DelegateProperty;
	static GetDefaultObject(): DelegateProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DelegateProperty;
	static C(Other: UObject | any): DelegateProperty;
}

declare class DoubleProperty extends NumericProperty { 
	static Load(ResourceName: string): DoubleProperty;
	static Find(Outer: UObject, ResourceName: string): DoubleProperty;
	static GetDefaultObject(): DoubleProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DoubleProperty;
	static C(Other: UObject | any): DoubleProperty;
}

declare class FloatProperty extends NumericProperty { 
	static Load(ResourceName: string): FloatProperty;
	static Find(Outer: UObject, ResourceName: string): FloatProperty;
	static GetDefaultObject(): FloatProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FloatProperty;
	static C(Other: UObject | any): FloatProperty;
}

declare class IntProperty extends NumericProperty { 
	static Load(ResourceName: string): IntProperty;
	static Find(Outer: UObject, ResourceName: string): IntProperty;
	static GetDefaultObject(): IntProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IntProperty;
	static C(Other: UObject | any): IntProperty;
}

declare class Int8Property extends NumericProperty { 
	static Load(ResourceName: string): Int8Property;
	static Find(Outer: UObject, ResourceName: string): Int8Property;
	static GetDefaultObject(): Int8Property;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Int8Property;
	static C(Other: UObject | any): Int8Property;
}

declare class Int16Property extends NumericProperty { 
	static Load(ResourceName: string): Int16Property;
	static Find(Outer: UObject, ResourceName: string): Int16Property;
	static GetDefaultObject(): Int16Property;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Int16Property;
	static C(Other: UObject | any): Int16Property;
}

declare class Int64Property extends NumericProperty { 
	static Load(ResourceName: string): Int64Property;
	static Find(Outer: UObject, ResourceName: string): Int64Property;
	static GetDefaultObject(): Int64Property;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Int64Property;
	static C(Other: UObject | any): Int64Property;
}

declare class InterfaceProperty extends Property { 
	static Load(ResourceName: string): InterfaceProperty;
	static Find(Outer: UObject, ResourceName: string): InterfaceProperty;
	static GetDefaultObject(): InterfaceProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterfaceProperty;
	static C(Other: UObject | any): InterfaceProperty;
}

declare class LazyObjectProperty extends ObjectPropertyBase { 
	static Load(ResourceName: string): LazyObjectProperty;
	static Find(Outer: UObject, ResourceName: string): LazyObjectProperty;
	static GetDefaultObject(): LazyObjectProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LazyObjectProperty;
	static C(Other: UObject | any): LazyObjectProperty;
}

declare class MapProperty extends Property { 
	static Load(ResourceName: string): MapProperty;
	static Find(Outer: UObject, ResourceName: string): MapProperty;
	static GetDefaultObject(): MapProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MapProperty;
	static C(Other: UObject | any): MapProperty;
}

declare class MulticastDelegateProperty extends Property { 
	static Load(ResourceName: string): MulticastDelegateProperty;
	static Find(Outer: UObject, ResourceName: string): MulticastDelegateProperty;
	static GetDefaultObject(): MulticastDelegateProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MulticastDelegateProperty;
	static C(Other: UObject | any): MulticastDelegateProperty;
}

declare class MulticastInlineDelegateProperty extends MulticastDelegateProperty { 
	static Load(ResourceName: string): MulticastInlineDelegateProperty;
	static Find(Outer: UObject, ResourceName: string): MulticastInlineDelegateProperty;
	static GetDefaultObject(): MulticastInlineDelegateProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MulticastInlineDelegateProperty;
	static C(Other: UObject | any): MulticastInlineDelegateProperty;
}

declare class MulticastSparseDelegateProperty extends MulticastDelegateProperty { 
	static Load(ResourceName: string): MulticastSparseDelegateProperty;
	static Find(Outer: UObject, ResourceName: string): MulticastSparseDelegateProperty;
	static GetDefaultObject(): MulticastSparseDelegateProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MulticastSparseDelegateProperty;
	static C(Other: UObject | any): MulticastSparseDelegateProperty;
}

declare class NameProperty extends Property { 
	static Load(ResourceName: string): NameProperty;
	static Find(Outer: UObject, ResourceName: string): NameProperty;
	static GetDefaultObject(): NameProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NameProperty;
	static C(Other: UObject | any): NameProperty;
}

declare class SetProperty extends Property { 
	static Load(ResourceName: string): SetProperty;
	static Find(Outer: UObject, ResourceName: string): SetProperty;
	static GetDefaultObject(): SetProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SetProperty;
	static C(Other: UObject | any): SetProperty;
}

declare class SoftObjectProperty extends ObjectPropertyBase { 
	static Load(ResourceName: string): SoftObjectProperty;
	static Find(Outer: UObject, ResourceName: string): SoftObjectProperty;
	static GetDefaultObject(): SoftObjectProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoftObjectProperty;
	static C(Other: UObject | any): SoftObjectProperty;
}

declare class SoftClassProperty extends SoftObjectProperty { 
	static Load(ResourceName: string): SoftClassProperty;
	static Find(Outer: UObject, ResourceName: string): SoftClassProperty;
	static GetDefaultObject(): SoftClassProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoftClassProperty;
	static C(Other: UObject | any): SoftClassProperty;
}

declare class StrProperty extends Property { 
	static Load(ResourceName: string): StrProperty;
	static Find(Outer: UObject, ResourceName: string): StrProperty;
	static GetDefaultObject(): StrProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StrProperty;
	static C(Other: UObject | any): StrProperty;
}

declare class StructProperty extends Property { 
	static Load(ResourceName: string): StructProperty;
	static Find(Outer: UObject, ResourceName: string): StructProperty;
	static GetDefaultObject(): StructProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StructProperty;
	static C(Other: UObject | any): StructProperty;
}

declare class UInt16Property extends NumericProperty { 
	static Load(ResourceName: string): UInt16Property;
	static Find(Outer: UObject, ResourceName: string): UInt16Property;
	static GetDefaultObject(): UInt16Property;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UInt16Property;
	static C(Other: UObject | any): UInt16Property;
}

declare class UInt32Property extends NumericProperty { 
	static Load(ResourceName: string): UInt32Property;
	static Find(Outer: UObject, ResourceName: string): UInt32Property;
	static GetDefaultObject(): UInt32Property;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UInt32Property;
	static C(Other: UObject | any): UInt32Property;
}

declare class UInt64Property extends NumericProperty { 
	static Load(ResourceName: string): UInt64Property;
	static Find(Outer: UObject, ResourceName: string): UInt64Property;
	static GetDefaultObject(): UInt64Property;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UInt64Property;
	static C(Other: UObject | any): UInt64Property;
}

declare class WeakObjectProperty extends ObjectPropertyBase { 
	static Load(ResourceName: string): WeakObjectProperty;
	static Find(Outer: UObject, ResourceName: string): WeakObjectProperty;
	static GetDefaultObject(): WeakObjectProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WeakObjectProperty;
	static C(Other: UObject | any): WeakObjectProperty;
}

declare class TextProperty extends Property { 
	static Load(ResourceName: string): TextProperty;
	static Find(Outer: UObject, ResourceName: string): TextProperty;
	static GetDefaultObject(): TextProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextProperty;
	static C(Other: UObject | any): TextProperty;
}

declare class PropertyWrapper extends UObject { 
	static Load(ResourceName: string): PropertyWrapper;
	static Find(Outer: UObject, ResourceName: string): PropertyWrapper;
	static GetDefaultObject(): PropertyWrapper;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PropertyWrapper;
	static C(Other: UObject | any): PropertyWrapper;
}

declare class MulticastDelegatePropertyWrapper extends PropertyWrapper { 
	static Load(ResourceName: string): MulticastDelegatePropertyWrapper;
	static Find(Outer: UObject, ResourceName: string): MulticastDelegatePropertyWrapper;
	static GetDefaultObject(): MulticastDelegatePropertyWrapper;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MulticastDelegatePropertyWrapper;
	static C(Other: UObject | any): MulticastDelegatePropertyWrapper;
}

declare class MulticastInlineDelegatePropertyWrapper extends MulticastDelegatePropertyWrapper { 
	static Load(ResourceName: string): MulticastInlineDelegatePropertyWrapper;
	static Find(Outer: UObject, ResourceName: string): MulticastInlineDelegatePropertyWrapper;
	static GetDefaultObject(): MulticastInlineDelegatePropertyWrapper;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MulticastInlineDelegatePropertyWrapper;
	static C(Other: UObject | any): MulticastInlineDelegatePropertyWrapper;
}

declare class InputCoreTypes extends UObject { 
	static Load(ResourceName: string): InputCoreTypes;
	static Find(Outer: UObject, ResourceName: string): InputCoreTypes;
	static GetDefaultObject(): InputCoreTypes;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputCoreTypes;
	static C(Other: UObject | any): InputCoreTypes;
}

declare class SlateWidgetStyleContainerBase extends UObject { 
	static Load(ResourceName: string): SlateWidgetStyleContainerBase;
	static Find(Outer: UObject, ResourceName: string): SlateWidgetStyleContainerBase;
	static GetDefaultObject(): SlateWidgetStyleContainerBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateWidgetStyleContainerBase;
	static C(Other: UObject | any): SlateWidgetStyleContainerBase;
}

declare class SlateWidgetStyleAsset extends UObject { 
	CustomStyle: SlateWidgetStyleContainerBase;
	static Load(ResourceName: string): SlateWidgetStyleAsset;
	static Find(Outer: UObject, ResourceName: string): SlateWidgetStyleAsset;
	static GetDefaultObject(): SlateWidgetStyleAsset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateWidgetStyleAsset;
	static C(Other: UObject | any): SlateWidgetStyleAsset;
}

declare class FontFaceInterface extends Interface { 
	static Load(ResourceName: string): FontFaceInterface;
	static Find(Outer: UObject, ResourceName: string): FontFaceInterface;
	static GetDefaultObject(): FontFaceInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FontFaceInterface;
	static C(Other: UObject | any): FontFaceInterface;
}

declare class FontProviderInterface extends Interface { 
	static Load(ResourceName: string): FontProviderInterface;
	static Find(Outer: UObject, ResourceName: string): FontProviderInterface;
	static GetDefaultObject(): FontProviderInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FontProviderInterface;
	static C(Other: UObject | any): FontProviderInterface;
}

declare class SlateTypes extends UObject { 
	static Load(ResourceName: string): SlateTypes;
	static Find(Outer: UObject, ResourceName: string): SlateTypes;
	static GetDefaultObject(): SlateTypes;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateTypes;
	static C(Other: UObject | any): SlateTypes;
}

declare class SlateWidgetStyleContainerInterface extends Interface { 
	static Load(ResourceName: string): SlateWidgetStyleContainerInterface;
	static Find(Outer: UObject, ResourceName: string): SlateWidgetStyleContainerInterface;
	static GetDefaultObject(): SlateWidgetStyleContainerInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateWidgetStyleContainerInterface;
	static C(Other: UObject | any): SlateWidgetStyleContainerInterface;
}

declare class StyleColorList { 
	StyleColors: LinearColor;
	clone() : StyleColorList;
	static C(Other: UObject | any): StyleColorList;
}

declare class SlateThemeManager extends UObject { 
	CurrentThemeId: Guid;
	ActiveColors: StyleColorList;
	static Load(ResourceName: string): SlateThemeManager;
	static Find(Outer: UObject, ResourceName: string): SlateThemeManager;
	static GetDefaultObject(): SlateThemeManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateThemeManager;
	static C(Other: UObject | any): SlateThemeManager;
}

declare class ToolMenuBase extends UObject { 
	static Load(ResourceName: string): ToolMenuBase;
	static Find(Outer: UObject, ResourceName: string): ToolMenuBase;
	static GetDefaultObject(): ToolMenuBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolMenuBase;
	static C(Other: UObject | any): ToolMenuBase;
}

declare class SlateSettings extends UObject { 
	bExplicitCanvasChildZOrder: boolean;
	static Load(ResourceName: string): SlateSettings;
	static Find(Outer: UObject, ResourceName: string): SlateSettings;
	static GetDefaultObject(): SlateSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateSettings;
	static C(Other: UObject | any): SlateSettings;
}

declare class SlateWidgetStyle { 
	clone() : SlateWidgetStyle;
	static C(Other: UObject | any): SlateWidgetStyle;
}

declare class SlateSound { 
	ResourceObject: UObject;
	clone() : SlateSound;
	static C(Other: UObject | any): SlateSound;
}

declare class ButtonStyle extends SlateWidgetStyle { 
	Normal: SlateBrush;
	Hovered: SlateBrush;
	Pressed: SlateBrush;
	Disabled: SlateBrush;
	NormalForeground: SlateColor;
	HoveredForeground: SlateColor;
	PressedForeground: SlateColor;
	DisabledForeground: SlateColor;
	NormalPadding: Margin;
	PressedPadding: Margin;
	PressedSlateSound: SlateSound;
	HoveredSlateSound: SlateSound;
	PressedSound: string;
	HoveredSound: string;
	clone() : ButtonStyle;
	static C(Other: UObject | any): ButtonStyle;
}

declare class ButtonWidgetStyle extends SlateWidgetStyleContainerBase { 
	ButtonStyle: ButtonStyle;
	static Load(ResourceName: string): ButtonWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): ButtonWidgetStyle;
	static GetDefaultObject(): ButtonWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ButtonWidgetStyle;
	static C(Other: UObject | any): ButtonWidgetStyle;
}

declare type ESlateCheckBoxType = 'CheckBox' | 'ToggleButton' | 'ESlateCheckBoxType_MAX';
declare var ESlateCheckBoxType : { CheckBox:'CheckBox',ToggleButton:'ToggleButton',ESlateCheckBoxType_MAX:'ESlateCheckBoxType_MAX', };
declare class CheckBoxStyle extends SlateWidgetStyle { 
	CheckBoxType: ESlateCheckBoxType;
	UncheckedImage: SlateBrush;
	UncheckedHoveredImage: SlateBrush;
	UncheckedPressedImage: SlateBrush;
	CheckedImage: SlateBrush;
	CheckedHoveredImage: SlateBrush;
	CheckedPressedImage: SlateBrush;
	UndeterminedImage: SlateBrush;
	UndeterminedHoveredImage: SlateBrush;
	UndeterminedPressedImage: SlateBrush;
	Padding: Margin;
	BackgroundImage: SlateBrush;
	BackgroundHoveredImage: SlateBrush;
	BackgroundPressedImage: SlateBrush;
	ForegroundColor: SlateColor;
	HoveredForeground: SlateColor;
	PressedForeground: SlateColor;
	CheckedForeground: SlateColor;
	CheckedHoveredForeground: SlateColor;
	CheckedPressedForeground: SlateColor;
	UndeterminedForeground: SlateColor;
	BorderBackgroundColor: SlateColor;
	CheckedSlateSound: SlateSound;
	UncheckedSlateSound: SlateSound;
	HoveredSlateSound: SlateSound;
	CheckedSound: string;
	UncheckedSound: string;
	HoveredSound: string;
	clone() : CheckBoxStyle;
	static C(Other: UObject | any): CheckBoxStyle;
}

declare class CheckBoxWidgetStyle extends SlateWidgetStyleContainerBase { 
	CheckBoxStyle: CheckBoxStyle;
	static Load(ResourceName: string): CheckBoxWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): CheckBoxWidgetStyle;
	static GetDefaultObject(): CheckBoxWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CheckBoxWidgetStyle;
	static C(Other: UObject | any): CheckBoxWidgetStyle;
}

declare class ComboButtonStyle extends SlateWidgetStyle { 
	ButtonStyle: ButtonStyle;
	DownArrowImage: SlateBrush;
	ShadowOffset: Vector2D;
	ShadowColorAndOpacity: LinearColor;
	MenuBorderBrush: SlateBrush;
	MenuBorderPadding: Margin;
	ContentPadding: Margin;
	DownArrowPadding: Margin;
	DownArrowAlign: EVerticalAlignment;
	clone() : ComboButtonStyle;
	static C(Other: UObject | any): ComboButtonStyle;
}

declare class ComboBoxStyle extends SlateWidgetStyle { 
	ComboButtonStyle: ComboButtonStyle;
	PressedSlateSound: SlateSound;
	SelectionChangeSlateSound: SlateSound;
	ContentPadding: Margin;
	MenuRowPadding: Margin;
	PressedSound: string;
	SelectionChangeSound: string;
	clone() : ComboBoxStyle;
	static C(Other: UObject | any): ComboBoxStyle;
}

declare class ComboBoxWidgetStyle extends SlateWidgetStyleContainerBase { 
	ComboBoxStyle: ComboBoxStyle;
	static Load(ResourceName: string): ComboBoxWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): ComboBoxWidgetStyle;
	static GetDefaultObject(): ComboBoxWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ComboBoxWidgetStyle;
	static C(Other: UObject | any): ComboBoxWidgetStyle;
}

declare class ComboButtonWidgetStyle extends SlateWidgetStyleContainerBase { 
	ComboButtonStyle: ComboButtonStyle;
	static Load(ResourceName: string): ComboButtonWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): ComboButtonWidgetStyle;
	static GetDefaultObject(): ComboButtonWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ComboButtonWidgetStyle;
	static C(Other: UObject | any): ComboButtonWidgetStyle;
}

declare class FontOutlineSettings { 
	OutlineSize: number;
	bSeparateFillAlpha: boolean;
	bApplyOutlineToDropShadows: boolean;
	OutlineMaterial: UObject;
	OutlineColor: LinearColor;
	clone() : FontOutlineSettings;
	static C(Other: UObject | any): FontOutlineSettings;
}

declare class SlateFontInfo { 
	FontObject: UObject;
	FontMaterial: UObject;
	OutlineSettings: FontOutlineSettings;
	TypefaceFontName: string;
	Size: number;
	LetterSpacing: number;
	SkewAmount: number;
	FontName: string;
	Hinting: EFontHinting;
	clone() : SlateFontInfo;
	static C(Other: UObject | any): SlateFontInfo;
}

declare type ETextTransformPolicy = 'None' | 'ToLower' | 'ToUpper' | 'ETextTransformPolicy_MAX';
declare var ETextTransformPolicy : { None:'None',ToLower:'ToLower',ToUpper:'ToUpper',ETextTransformPolicy_MAX:'ETextTransformPolicy_MAX', };
declare type ETextOverflowPolicy = 'Clip' | 'Ellipsis' | 'ETextOverflowPolicy_MAX';
declare var ETextOverflowPolicy : { Clip:'Clip',Ellipsis:'Ellipsis',ETextOverflowPolicy_MAX:'ETextOverflowPolicy_MAX', };
declare class TextBlockStyle extends SlateWidgetStyle { 
	Font: SlateFontInfo;
	ColorAndOpacity: SlateColor;
	ShadowOffset: Vector2D;
	ShadowColorAndOpacity: LinearColor;
	SelectedBackgroundColor: SlateColor;
	HighlightColor: SlateColor;
	HighlightShape: SlateBrush;
	StrikeBrush: SlateBrush;
	UnderlineBrush: SlateBrush;
	TransformPolicy: ETextTransformPolicy;
	OverflowPolicy: ETextOverflowPolicy;
	clone() : TextBlockStyle;
	static C(Other: UObject | any): TextBlockStyle;
}

declare class ScrollBarStyle extends SlateWidgetStyle { 
	HorizontalBackgroundImage: SlateBrush;
	VerticalBackgroundImage: SlateBrush;
	VerticalTopSlotImage: SlateBrush;
	HorizontalTopSlotImage: SlateBrush;
	VerticalBottomSlotImage: SlateBrush;
	HorizontalBottomSlotImage: SlateBrush;
	NormalThumbImage: SlateBrush;
	HoveredThumbImage: SlateBrush;
	DraggedThumbImage: SlateBrush;
	Thickness: number;
	clone() : ScrollBarStyle;
	static C(Other: UObject | any): ScrollBarStyle;
}

declare class EditableTextBoxStyle extends SlateWidgetStyle { 
	BackgroundImageNormal: SlateBrush;
	BackgroundImageHovered: SlateBrush;
	BackgroundImageFocused: SlateBrush;
	BackgroundImageReadOnly: SlateBrush;
	Padding: Margin;
	Font: SlateFontInfo;
	TextStyle: TextBlockStyle;
	ForegroundColor: SlateColor;
	BackgroundColor: SlateColor;
	ReadOnlyForegroundColor: SlateColor;
	FocusedForegroundColor: SlateColor;
	HScrollBarPadding: Margin;
	VScrollBarPadding: Margin;
	ScrollBarStyle: ScrollBarStyle;
	clone() : EditableTextBoxStyle;
	static C(Other: UObject | any): EditableTextBoxStyle;
}

declare class EditableTextBoxWidgetStyle extends SlateWidgetStyleContainerBase { 
	EditableTextBoxStyle: EditableTextBoxStyle;
	static Load(ResourceName: string): EditableTextBoxWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): EditableTextBoxWidgetStyle;
	static GetDefaultObject(): EditableTextBoxWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableTextBoxWidgetStyle;
	static C(Other: UObject | any): EditableTextBoxWidgetStyle;
}

declare class EditableTextStyle extends SlateWidgetStyle { 
	Font: SlateFontInfo;
	ColorAndOpacity: SlateColor;
	BackgroundImageSelected: SlateBrush;
	BackgroundImageComposing: SlateBrush;
	CaretImage: SlateBrush;
	clone() : EditableTextStyle;
	static C(Other: UObject | any): EditableTextStyle;
}

declare class EditableTextWidgetStyle extends SlateWidgetStyleContainerBase { 
	EditableTextStyle: EditableTextStyle;
	static Load(ResourceName: string): EditableTextWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): EditableTextWidgetStyle;
	static GetDefaultObject(): EditableTextWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableTextWidgetStyle;
	static C(Other: UObject | any): EditableTextWidgetStyle;
}

declare class ProgressBarStyle extends SlateWidgetStyle { 
	BackgroundImage: SlateBrush;
	FillImage: SlateBrush;
	MarqueeImage: SlateBrush;
	EnableFillAnimation: boolean;
	clone() : ProgressBarStyle;
	static C(Other: UObject | any): ProgressBarStyle;
}

declare class ProgressWidgetStyle extends SlateWidgetStyleContainerBase { 
	ProgressBarStyle: ProgressBarStyle;
	static Load(ResourceName: string): ProgressWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): ProgressWidgetStyle;
	static GetDefaultObject(): ProgressWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProgressWidgetStyle;
	static C(Other: UObject | any): ProgressWidgetStyle;
}

declare class ScrollBarWidgetStyle extends SlateWidgetStyleContainerBase { 
	ScrollBarStyle: ScrollBarStyle;
	static Load(ResourceName: string): ScrollBarWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): ScrollBarWidgetStyle;
	static GetDefaultObject(): ScrollBarWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScrollBarWidgetStyle;
	static C(Other: UObject | any): ScrollBarWidgetStyle;
}

declare class ScrollBoxStyle extends SlateWidgetStyle { 
	BarThickness: number;
	TopShadowBrush: SlateBrush;
	BottomShadowBrush: SlateBrush;
	LeftShadowBrush: SlateBrush;
	RightShadowBrush: SlateBrush;
	clone() : ScrollBoxStyle;
	static C(Other: UObject | any): ScrollBoxStyle;
}

declare class ScrollBoxWidgetStyle extends SlateWidgetStyleContainerBase { 
	ScrollBoxStyle: ScrollBoxStyle;
	static Load(ResourceName: string): ScrollBoxWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): ScrollBoxWidgetStyle;
	static GetDefaultObject(): ScrollBoxWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScrollBoxWidgetStyle;
	static C(Other: UObject | any): ScrollBoxWidgetStyle;
}

declare class SpinBoxStyle extends SlateWidgetStyle { 
	BackgroundBrush: SlateBrush;
	ActiveBackgroundBrush: SlateBrush;
	HoveredBackgroundBrush: SlateBrush;
	ActiveFillBrush: SlateBrush;
	HoveredFillBrush: SlateBrush;
	InactiveFillBrush: SlateBrush;
	ArrowsImage: SlateBrush;
	ForegroundColor: SlateColor;
	TextPadding: Margin;
	InsetPadding: Margin;
	clone() : SpinBoxStyle;
	static C(Other: UObject | any): SpinBoxStyle;
}

declare class SpinBoxWidgetStyle extends SlateWidgetStyleContainerBase { 
	SpinBoxStyle: SpinBoxStyle;
	static Load(ResourceName: string): SpinBoxWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): SpinBoxWidgetStyle;
	static GetDefaultObject(): SpinBoxWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SpinBoxWidgetStyle;
	static C(Other: UObject | any): SpinBoxWidgetStyle;
}

declare class TextBlockWidgetStyle extends SlateWidgetStyleContainerBase { 
	TextBlockStyle: TextBlockStyle;
	static Load(ResourceName: string): TextBlockWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): TextBlockWidgetStyle;
	static GetDefaultObject(): TextBlockWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextBlockWidgetStyle;
	static C(Other: UObject | any): TextBlockWidgetStyle;
}

declare class DeveloperSettings extends UObject { 
	static Load(ResourceName: string): DeveloperSettings;
	static Find(Outer: UObject, ResourceName: string): DeveloperSettings;
	static GetDefaultObject(): DeveloperSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DeveloperSettings;
	static C(Other: UObject | any): DeveloperSettings;
}

declare class DeveloperSettingsBackedByCVars extends DeveloperSettings { 
	static Load(ResourceName: string): DeveloperSettingsBackedByCVars;
	static Find(Outer: UObject, ResourceName: string): DeveloperSettingsBackedByCVars;
	static GetDefaultObject(): DeveloperSettingsBackedByCVars;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DeveloperSettingsBackedByCVars;
	static C(Other: UObject | any): DeveloperSettingsBackedByCVars;
}

declare class PlatformSettings extends UObject { 
	static Load(ResourceName: string): PlatformSettings;
	static Find(Outer: UObject, ResourceName: string): PlatformSettings;
	static GetDefaultObject(): PlatformSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlatformSettings;
	static C(Other: UObject | any): PlatformSettings;
}

declare class PlatformSettingsInstances { 
	PlatformInstance: PlatformSettings;
	OtherPlatforms: Map<string, PlatformSettings>;
	clone() : PlatformSettingsInstances;
	static C(Other: UObject | any): PlatformSettingsInstances;
}

declare class PlatformSettingsManager extends UObject { 
	SettingsMap: Map<UnrealEngineClass, PlatformSettingsInstances>;
	static Load(ResourceName: string): PlatformSettingsManager;
	static Find(Outer: UObject, ResourceName: string): PlatformSettingsManager;
	static GetDefaultObject(): PlatformSettingsManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlatformSettingsManager;
	static C(Other: UObject | any): PlatformSettingsManager;
}

declare class BlueprintFunctionLibrary extends UObject { 
	static Load(ResourceName: string): BlueprintFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): BlueprintFunctionLibrary;
	static GetDefaultObject(): BlueprintFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintFunctionLibrary;
	static C(Other: UObject | any): BlueprintFunctionLibrary;
}

declare class ImageWriteBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): ImageWriteBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): ImageWriteBlueprintLibrary;
	static GetDefaultObject(): ImageWriteBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ImageWriteBlueprintLibrary;
	static ExportToDisk(Texture: Texture,Filename: string,Options: ImageWriteOptions): void;
	static C(Other: UObject | any): ImageWriteBlueprintLibrary;
}

declare type EMultiBoxType = 'MenuBar' | 'ToolBar' | 'VerticalToolBar' | 'SlimHorizontalToolBar' | 'UniformToolBar' | 'Menu' | 'ButtonRow' | 'EMultiBoxType_MAX';
declare var EMultiBoxType : { MenuBar:'MenuBar',ToolBar:'ToolBar',VerticalToolBar:'VerticalToolBar',SlimHorizontalToolBar:'SlimHorizontalToolBar',UniformToolBar:'UniformToolBar',Menu:'Menu',ButtonRow:'ButtonRow',EMultiBoxType_MAX:'EMultiBoxType_MAX', };
declare class ToolMenuOwner { 
	clone() : ToolMenuOwner;
	static C(Other: UObject | any): ToolMenuOwner;
}

declare class ToolMenuContext { 
	ContextObjects: UObject[];
	clone() : ToolMenuContext;
	static C(Other: UObject | any): ToolMenuContext;
}

declare type EMultiBlockType = 'None' | 'ButtonRow' | 'EditableText' | 'Heading' | 'MenuEntry' | 'Separator' | 'ToolBarButton' | 'ToolBarComboButton' | 'Widget' | 'EMultiBlockType_MAX';
declare var EMultiBlockType : { None:'None',ButtonRow:'ButtonRow',EditableText:'EditableText',Heading:'Heading',MenuEntry:'MenuEntry',Separator:'Separator',ToolBarButton:'ToolBarButton',ToolBarComboButton:'ToolBarComboButton',Widget:'Widget',EMultiBlockType_MAX:'EMultiBlockType_MAX', };
declare type EUserInterfaceActionType = 'None' | 'Button' | 'ToggleButton' | 'RadioButton' | 'Check' | 'CollapsedButton' | 'EUserInterfaceActionType_MAX';
declare var EUserInterfaceActionType : { None:'None',Button:'Button',ToggleButton:'ToggleButton',RadioButton:'RadioButton',Check:'Check',CollapsedButton:'CollapsedButton',EUserInterfaceActionType_MAX:'EUserInterfaceActionType_MAX', };
declare type EToolMenuInsertType = 'Default' | 'Before' | 'After' | 'First' | 'EToolMenuInsertType_MAX';
declare var EToolMenuInsertType : { Default:'Default',Before:'Before',After:'After',First:'First',EToolMenuInsertType_MAX:'EToolMenuInsertType_MAX', };
declare class ToolMenuInsert { 
	Name: string;
	Position: EToolMenuInsertType;
	clone() : ToolMenuInsert;
	static C(Other: UObject | any): ToolMenuInsert;
}

declare class ScriptSlateIcon { 
	StyleSetName: string;
	StyleName: string;
	SmallStyleName: string;
	clone() : ScriptSlateIcon;
	static C(Other: UObject | any): ScriptSlateIcon;
}

declare class ToolMenuEntryScriptDataAdvanced { 
	TutorialHighlight: string;
	EntryType: EMultiBlockType;
	UserInterfaceActionType: EUserInterfaceActionType;
	StyleNameOverride: string;
	bIsSubMenu: boolean;
	bOpenSubMenuOnClick: boolean;
	bShouldCloseWindowAfterMenuSelection: boolean;
	bSimpleComboBox: boolean;
	clone() : ToolMenuEntryScriptDataAdvanced;
	static C(Other: UObject | any): ToolMenuEntryScriptDataAdvanced;
}

declare class ToolMenuEntryScriptData { 
	Menu: string;
	Section: string;
	Name: string;
	Label: string;
	Tooltip: string;
	Icon: ScriptSlateIcon;
	OwnerName: string;
	InsertPosition: ToolMenuInsert;
	Advanced: ToolMenuEntryScriptDataAdvanced;
	clone() : ToolMenuEntryScriptData;
	static C(Other: UObject | any): ToolMenuEntryScriptData;
}

declare type ECheckBoxState = 'Unchecked' | 'Checked' | 'Undetermined' | 'ECheckBoxState_MAX';
declare var ECheckBoxState : { Unchecked:'Unchecked',Checked:'Checked',Undetermined:'Undetermined',ECheckBoxState_MAX:'ECheckBoxState_MAX', };
declare class ToolMenuEntryScript extends UObject { 
	Data: ToolMenuEntryScriptData;
	static Load(ResourceName: string): ToolMenuEntryScript;
	static Find(Outer: UObject, ResourceName: string): ToolMenuEntryScript;
	static GetDefaultObject(): ToolMenuEntryScript;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolMenuEntryScript;
	RegisterMenuEntry(): void;
	IsVisible(Context: ToolMenuContext): boolean;
	InitEntry(OwnerName: string,Menu: string,Section: string,Name: string,Label: string,Tooltip: string): void;
	GetToolTip(Context: ToolMenuContext): string;
	GetLabel(Context: ToolMenuContext): string;
	GetIcon(Context: ToolMenuContext): ScriptSlateIcon;
	GetCheckState(Context: ToolMenuContext): ECheckBoxState;
	Execute(Context: ToolMenuContext): void;
	ConstructMenuEntry(Menu: ToolMenu,SectionName: string,Context: ToolMenuContext): void;
	CanExecute(Context: ToolMenuContext): boolean;
	static C(Other: UObject | any): ToolMenuEntryScript;
}

declare class ToolMenuEntry { 
	Name: string;
	Owner: ToolMenuOwner;
	Type: EMultiBlockType;
	UserInterfaceActionType: EUserInterfaceActionType;
	TutorialHighlightName: string;
	InsertPosition: ToolMenuInsert;
	bShouldCloseWindowAfterMenuSelection: boolean;
	ScriptObject: ToolMenuEntryScript;
	StyleNameOverride: string;
	bCommandIsKeybindOnly: boolean;
	clone() : ToolMenuEntry;
	static C(Other: UObject | any): ToolMenuEntry;
}

declare class ToolMenuSectionDynamic extends UObject { 
	static Load(ResourceName: string): ToolMenuSectionDynamic;
	static Find(Outer: UObject, ResourceName: string): ToolMenuSectionDynamic;
	static GetDefaultObject(): ToolMenuSectionDynamic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolMenuSectionDynamic;
	ConstructSections(Menu: ToolMenu,Context: ToolMenuContext): void;
	static C(Other: UObject | any): ToolMenuSectionDynamic;
}

declare class ToolMenuSection { 
	Name: string;
	Owner: ToolMenuOwner;
	Blocks: ToolMenuEntry[];
	InsertPosition: ToolMenuInsert;
	Context: ToolMenuContext;
	ToolMenuSectionDynamic: ToolMenuSectionDynamic;
	clone() : ToolMenuSection;
	static C(Other: UObject | any): ToolMenuSection;
}

declare class ToolMenu extends ToolMenuBase { 
	MenuName: string;
	MenuParent: string;
	StyleName: string;
	TutorialHighlightName: string;
	MenuType: EMultiBoxType;
	bShouldCleanupContextOnDestroy: boolean;
	bShouldCloseWindowAfterMenuSelection: boolean;
	bCloseSelfOnly: boolean;
	bSearchable: boolean;
	bToolBarIsFocusable: boolean;
	bToolBarForceSmallIcons: boolean;
	bPreventCustomization: boolean;
	MenuOwner: ToolMenuOwner;
	Context: ToolMenuContext;
	Sections: ToolMenuSection[];
	SubMenuParent: ToolMenu;
	SubMenuSourceEntryName: string;
	static Load(ResourceName: string): ToolMenu;
	static Find(Outer: UObject, ResourceName: string): ToolMenu;
	static GetDefaultObject(): ToolMenu;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolMenu;
	InitMenu(Owner: ToolMenuOwner,Name: string,Parent: string,Type: EMultiBoxType): void;
	AddSubMenuScript(Owner: string,SectionName: string,Name: string,Label: string,Tooltip: string): ToolMenu;
	AddSectionScript(SectionName: string,Label: string,InsertName: string,InsertType: EToolMenuInsertType): void;
	AddMenuEntryObject(InObject: ToolMenuEntryScript): void;
	AddMenuEntry(SectionName: string,Args: ToolMenuEntry): void;
	AddDynamicSectionScript(SectionName: string,UObject: ToolMenuSectionDynamic): void;
	static C(Other: UObject | any): ToolMenu;
}

declare class ToolMenuContextBase extends UObject { 
	static Load(ResourceName: string): ToolMenuContextBase;
	static Find(Outer: UObject, ResourceName: string): ToolMenuContextBase;
	static GetDefaultObject(): ToolMenuContextBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolMenuContextBase;
	static C(Other: UObject | any): ToolMenuContextBase;
}

declare class SlateTabManagerContext extends ToolMenuContextBase { 
	static Load(ResourceName: string): SlateTabManagerContext;
	static Find(Outer: UObject, ResourceName: string): SlateTabManagerContext;
	static GetDefaultObject(): SlateTabManagerContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateTabManagerContext;
	static C(Other: UObject | any): SlateTabManagerContext;
}

declare type ECustomizedToolMenuVisibility = 'None' | 'Visible' | 'Hidden' | 'ECustomizedToolMenuVisibility_MAX';
declare var ECustomizedToolMenuVisibility : { None:'None',Visible:'Visible',Hidden:'Hidden',ECustomizedToolMenuVisibility_MAX:'ECustomizedToolMenuVisibility_MAX', };
declare class CustomizedToolMenuEntry { 
	Visibility: ECustomizedToolMenuVisibility;
	clone() : CustomizedToolMenuEntry;
	static C(Other: UObject | any): CustomizedToolMenuEntry;
}

declare class CustomizedToolMenuSection { 
	Visibility: ECustomizedToolMenuVisibility;
	clone() : CustomizedToolMenuSection;
	static C(Other: UObject | any): CustomizedToolMenuSection;
}

declare class CustomizedToolMenuNameArray { 
	Names: string[];
	clone() : CustomizedToolMenuNameArray;
	static C(Other: UObject | any): CustomizedToolMenuNameArray;
}

declare class CustomizedToolMenu { 
	Name: string;
	Entries: Map<string, CustomizedToolMenuEntry>;
	Sections: Map<string, CustomizedToolMenuSection>;
	EntryOrder: Map<string, CustomizedToolMenuNameArray>;
	SectionOrder: string[];
	clone() : CustomizedToolMenu;
	static C(Other: UObject | any): CustomizedToolMenu;
}

declare class ToolMenus extends UObject { 
	CustomizedMenus: CustomizedToolMenu[];
	MenuSubstitutionsDuringGenerate: Map<string, string>;
	Menus: Map<string, ToolMenu>;
	static Load(ResourceName: string): ToolMenus;
	static Find(Outer: UObject, ResourceName: string): ToolMenus;
	static GetDefaultObject(): ToolMenus;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolMenus;
	UnregisterOwnerByName(InOwnerName: string): void;
	SetSectionPosition(MenuName: string,SectionName: string,OtherSectionName: string,PositionType: EToolMenuInsertType): void;
	SetSectionLabel(MenuName: string,SectionName: string,Label: string): void;
	RemoveSection(MenuName: string,Section: string): void;
	RemoveMenu(MenuName: string): void;
	RemoveEntry(MenuName: string,Section: string,Name: string): void;
	RegisterMenu(Name: string,Parent: string,Type: EMultiBoxType,bWarnIfAlreadyRegistered: boolean): ToolMenu;
	RefreshMenuWidget(Name: string): boolean;
	RefreshAllWidgets(): void;
	IsMenuRegistered(Name: string): boolean;
	static Get(): ToolMenus;
	FindMenu(Name: string): ToolMenu;
	static FindContext(InContext: ToolMenuContext,InClass: UnrealEngineClass): UObject;
	ExtendMenu(Name: string): ToolMenu;
	static AddMenuEntryObject(MenuEntryObject: ToolMenuEntryScript): boolean;
	static C(Other: UObject | any): ToolMenus;
}

declare class ToolMenuContextExtensions extends UObject { 
	static Load(ResourceName: string): ToolMenuContextExtensions;
	static Find(Outer: UObject, ResourceName: string): ToolMenuContextExtensions;
	static GetDefaultObject(): ToolMenuContextExtensions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolMenuContextExtensions;
	static FindByClass(Context: ToolMenuContext,InClass: UnrealEngineClass): UObject;
	static C(Other: UObject | any): ToolMenuContextExtensions;
}

declare type EToolMenuStringCommandType = 'Command' | 'Python' | 'Custom' | 'EToolMenuStringCommandType_MAX';
declare var EToolMenuStringCommandType : { Command:'Command',Python:'Python',Custom:'Custom',EToolMenuStringCommandType_MAX:'EToolMenuStringCommandType_MAX', };
declare class ToolMenuStringCommand { 
	Type: EToolMenuStringCommandType;
	CustomType: string;
	string: string;
	clone() : ToolMenuStringCommand;
	static C(Other: UObject | any): ToolMenuStringCommand;
}

declare class ToolMenuEntryExtensions extends UObject { 
	static Load(ResourceName: string): ToolMenuEntryExtensions;
	static Find(Outer: UObject, ResourceName: string): ToolMenuEntryExtensions;
	static GetDefaultObject(): ToolMenuEntryExtensions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolMenuEntryExtensions;
	static SetToolTip(Target?: ToolMenuEntry,Tooltip?: string): {Target: ToolMenuEntry};
	static SetStringCommand(Target?: ToolMenuEntry,Type?: EToolMenuStringCommandType,CustomType?: string,string?: string): {Target: ToolMenuEntry};
	static SetLabel(Target?: ToolMenuEntry,Label?: string): {Target: ToolMenuEntry};
	static SetIcon(Target?: ToolMenuEntry,StyleSetName?: string,StyleName?: string,SmallStyleName?: string): {Target: ToolMenuEntry};
	static MakeToolMenuOwner(Name: string): ToolMenuOwner;
	static MakeStringCommand(Type: EToolMenuStringCommandType,CustomType: string,string: string): ToolMenuStringCommand;
	static MakeScriptSlateIcon(StyleSetName: string,StyleName: string,SmallStyleName: string): ScriptSlateIcon;
	static InitMenuEntry(InOwner: string,InName: string,InLabel: string,InToolTip: string,CommandType: EToolMenuStringCommandType,CustomCommandType: string,CommandString: string): ToolMenuEntry;
	static GetToolTip(Target: ToolMenuEntry): string;
	static GetLabel(Target: ToolMenuEntry): string;
	static BreakToolMenuOwner(InValue: ToolMenuOwner,Name?: string): {Name: string};
	static BreakStringCommand(InValue: ToolMenuStringCommand,Type?: EToolMenuStringCommandType,CustomType?: string,string?: string): {Type: EToolMenuStringCommandType, CustomType: string, string: string};
	static BreakScriptSlateIcon(InValue: ScriptSlateIcon,StyleSetName?: string,StyleName?: string,SmallStyleName?: string): {StyleSetName: string, StyleName: string, SmallStyleName: string};
	static C(Other: UObject | any): ToolMenuEntryExtensions;
}

declare class ToolMenuSectionExtensions extends UObject { 
	static Load(ResourceName: string): ToolMenuSectionExtensions;
	static Find(Outer: UObject, ResourceName: string): ToolMenuSectionExtensions;
	static GetDefaultObject(): ToolMenuSectionExtensions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolMenuSectionExtensions;
	static SetLabel(Section?: ToolMenuSection,Label?: string): {Section: ToolMenuSection};
	static GetLabel(Section: ToolMenuSection): string;
	static AddEntryObject(Section?: ToolMenuSection,InObject?: ToolMenuEntryScript): {Section: ToolMenuSection};
	static AddEntry(Section?: ToolMenuSection,Args?: ToolMenuEntry): {Section: ToolMenuSection};
	static C(Other: UObject | any): ToolMenuSectionExtensions;
}

declare class FilterBarContext extends UObject { 
	static Load(ResourceName: string): FilterBarContext;
	static Find(Outer: UObject, ResourceName: string): FilterBarContext;
	static GetDefaultObject(): FilterBarContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FilterBarContext;
	static C(Other: UObject | any): FilterBarContext;
}

declare class ARFilter { 
	PackageNames: string[];
	PackagePaths: string[];
	ObjectPaths: string[];
	SoftObjectPaths: SoftObjectPath[];
	ClassNames: string[];
	ClassPaths: TopLevelAssetPath[];
	RecursiveClassesExclusionSet: Set<string>;
	RecursiveClassPathsExclusionSet: Set<TopLevelAssetPath>;
	bRecursivePaths: boolean;
	bRecursiveClasses: boolean;
	bIncludeOnlyOnDiskAssets: boolean;
	clone() : ARFilter;
	static C(Other: UObject | any): ARFilter;
	BreakARFilter(PackageNames?: string[],PackagePaths?: string[],SoftObjectPaths?: SoftObjectPath[],ClassPaths?: TopLevelAssetPath[],RecursiveClassPathsExclusionSet?: Set<TopLevelAssetPath>,ClassNames?: string[],RecursiveClassesExclusionSet?: Set<string>,bRecursivePaths?: boolean,bRecursiveClasses?: boolean,bIncludeOnlyOnDiskAssets?: boolean): {PackageNames: string[], PackagePaths: string[], SoftObjectPaths: SoftObjectPath[], ClassPaths: TopLevelAssetPath[], RecursiveClassPathsExclusionSet: Set<TopLevelAssetPath>, ClassNames: string[], RecursiveClassesExclusionSet: Set<string>, bRecursivePaths: boolean, bRecursiveClasses: boolean, bIncludeOnlyOnDiskAssets: boolean};
	static BreakARFilter(InARFilter: ARFilter,PackageNames?: string[],PackagePaths?: string[],SoftObjectPaths?: SoftObjectPath[],ClassPaths?: TopLevelAssetPath[],RecursiveClassPathsExclusionSet?: Set<TopLevelAssetPath>,ClassNames?: string[],RecursiveClassesExclusionSet?: Set<string>,bRecursivePaths?: boolean,bRecursiveClasses?: boolean,bIncludeOnlyOnDiskAssets?: boolean): {PackageNames: string[], PackagePaths: string[], SoftObjectPaths: SoftObjectPath[], ClassPaths: TopLevelAssetPath[], RecursiveClassPathsExclusionSet: Set<TopLevelAssetPath>, ClassNames: string[], RecursiveClassesExclusionSet: Set<string>, bRecursivePaths: boolean, bRecursiveClasses: boolean, bIncludeOnlyOnDiskAssets: boolean};
	static MakeARFilter(PackageNames: string[],PackagePaths: string[],SoftObjectPaths: SoftObjectPath[],ClassPaths: TopLevelAssetPath[],RecursiveClassPathsExclusionSet: Set<TopLevelAssetPath>,ClassNames: string[],RecursiveClassesExclusionSet: Set<string>,bRecursivePaths: boolean,bRecursiveClasses: boolean,bIncludeOnlyOnDiskAssets: boolean): ARFilter;
}

declare class TagAndValue { 
	Tag: string;
	Value: string;
	clone() : TagAndValue;
	static C(Other: UObject | any): TagAndValue;
}

declare class AssetRegistryHelpers extends UObject { 
	static Load(ResourceName: string): AssetRegistryHelpers;
	static Find(Outer: UObject, ResourceName: string): AssetRegistryHelpers;
	static GetDefaultObject(): AssetRegistryHelpers;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetRegistryHelpers;
	static ToSoftObjectPath(InAssetData: AssetData): SoftObjectPath;
	static SetFilterTagsAndValues(InFilter: ARFilter,InTagsAndValues: TagAndValue[]): ARFilter;
	static IsValid(InAssetData: AssetData): boolean;
	static IsUAsset(InAssetData: AssetData): boolean;
	static IsRedirector(InAssetData: AssetData): boolean;
	static IsAssetLoaded(InAssetData: AssetData): boolean;
	static GetTagValue(InAssetData: AssetData,InTagName: string,OutTagValue?: string): {OutTagValue: string, $: boolean};
	static GetFullName(InAssetData: AssetData): string;
	static GetExportTextName(InAssetData: AssetData): string;
	static GetClass(InAssetData: AssetData): UnrealEngineClass;
	static GetBlueprintAssets(InFilter: ARFilter,OutAssetData?: AssetData[]): {OutAssetData: AssetData[]};
	static GetAsset(InAssetData: AssetData): UObject;
	static CreateAssetData(InAsset: UObject,bAllowBlueprintClass: boolean): AssetData;
	static C(Other: UObject | any): AssetRegistryHelpers;
}

declare class AssetRegistryDependencyOptions { 
	bIncludeSoftPackageReferences: boolean;
	bIncludeHardPackageReferences: boolean;
	bIncludeSearchableNames: boolean;
	bIncludeSoftManagementReferences: boolean;
	bIncludeHardManagementReferences: boolean;
	clone() : AssetRegistryDependencyOptions;
	static C(Other: UObject | any): AssetRegistryDependencyOptions;
}

declare class AssetRegistry extends Interface { 
	static Load(ResourceName: string): AssetRegistry;
	static Find(Outer: UObject, ResourceName: string): AssetRegistry;
	static GetDefaultObject(): AssetRegistry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetRegistry;
	WaitForPackage(PackageName: string): void;
	WaitForCompletion(): void;
	UseFilterToExcludeAssets(AssetDataList?: AssetData[],Filter?: ARFilter): {AssetDataList: AssetData[]};
	SearchAllAssets(bSynchronousSearch: boolean): void;
	ScanPathsSynchronous(InPaths: string[],bForceRescan: boolean,bIgnoreDenyListScanFilters: boolean): void;
	ScanModifiedAssetFiles(InFilePaths: string[]): void;
	ScanFilesSynchronous(InFilePaths: string[],bForceRescan: boolean): void;
	RunAssetsThroughFilter(AssetDataList?: AssetData[],Filter?: ARFilter): {AssetDataList: AssetData[]};
	PrioritizeSearchPath(PathToPrioritize: string): void;
	K2_GetReferencers(PackageName: string,ReferenceOptions: AssetRegistryDependencyOptions,OutReferencers?: string[]): {OutReferencers: string[], $: boolean};
	K2_GetDependencies(PackageName: string,DependencyOptions: AssetRegistryDependencyOptions,OutDependencies?: string[]): {OutDependencies: string[], $: boolean};
	K2_GetAssetByObjectPath(ObjectPath: SoftObjectPath,bIncludeOnlyOnDiskAssets: boolean): AssetData;
	IsSearchAsync(): boolean;
	IsSearchAllAssets(): boolean;
	IsLoadingAssets(): boolean;
	HasAssets(PackagePath: string,bRecursive: boolean): boolean;
	GetSubPaths(InBasePath: string,OutPathList?: string[],bInRecurse?: boolean): {OutPathList: string[]};
	GetDerivedClassNames(ClassNames: TopLevelAssetPath[],ExcludedClassNames: Set<TopLevelAssetPath>,OutDerivedClassNames?: Set<TopLevelAssetPath>): {OutDerivedClassNames: Set<TopLevelAssetPath>};
	GetAssetsByPaths(PackagePaths: string[],OutAssetData?: AssetData[],bRecursive?: boolean,bIncludeOnlyOnDiskAssets?: boolean): {OutAssetData: AssetData[], $: boolean};
	GetAssetsByPath(PackagePath: string,OutAssetData?: AssetData[],bRecursive?: boolean,bIncludeOnlyOnDiskAssets?: boolean): {OutAssetData: AssetData[], $: boolean};
	GetAssetsByPackageName(PackageName: string,OutAssetData?: AssetData[],bIncludeOnlyOnDiskAssets?: boolean,bSkipARFilteredAssets?: boolean): {OutAssetData: AssetData[], $: boolean};
	GetAssetsByClass(ClassPathName: TopLevelAssetPath,OutAssetData?: AssetData[],bSearchSubClasses?: boolean): {OutAssetData: AssetData[], $: boolean};
	GetAssets(Filter: ARFilter,OutAssetData?: AssetData[],bSkipARFilteredAssets?: boolean): {OutAssetData: AssetData[], $: boolean};
	GetAssetByObjectPath(ObjectPath: string,bIncludeOnlyOnDiskAssets: boolean): AssetData;
	GetAncestorClassNames(ClassPathName: TopLevelAssetPath,OutAncestorClassNames?: TopLevelAssetPath[]): {OutAncestorClassNames: TopLevelAssetPath[], $: boolean};
	GetAllCachedPaths(OutPathList?: string[]): {OutPathList: string[]};
	GetAllAssets(OutAssetData?: AssetData[],bIncludeOnlyOnDiskAssets?: boolean): {OutAssetData: AssetData[], $: boolean};
	static C(Other: UObject | any): AssetRegistry;
}

declare class AssetRegistryImpl extends UObject { 
	static Load(ResourceName: string): AssetRegistryImpl;
	static Find(Outer: UObject, ResourceName: string): AssetRegistryImpl;
	static GetDefaultObject(): AssetRegistryImpl;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetRegistryImpl;
	static C(Other: UObject | any): AssetRegistryImpl;
}

declare class AudioParameterControllerInterface extends Interface { 
	static Load(ResourceName: string): AudioParameterControllerInterface;
	static Find(Outer: UObject, ResourceName: string): AudioParameterControllerInterface;
	static GetDefaultObject(): AudioParameterControllerInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioParameterControllerInterface;
	SetTriggerParameter(InName: string): void;
	SetStringParameter(InName: string,InValue: string): void;
	SetStringArrayParameter(InName: string,InValue: string[]): void;
	SetParameters_Blueprint(InParameters: AudioParameter[]): void;
	SetObjectParameter(InName: string,InValue: UObject): void;
	SetObjectArrayParameter(InName: string,InValue: UObject[]): void;
	SetIntParameter(InName: string,inInt: number): void;
	SetIntArrayParameter(InName: string,InValue: number[]): void;
	SetFloatParameter(InName: string,InFloat: number): void;
	SetFloatArrayParameter(InName: string,InValue: number[]): void;
	SetBoolParameter(InName: string,InBool: boolean): void;
	SetBoolArrayParameter(InName: string,InValue: boolean[]): void;
	ResetParameters(): void;
	static C(Other: UObject | any): AudioParameterControllerInterface;
}

declare class AudioCodecEncoderSettings extends UObject { 
	Version: number;
	static Load(ResourceName: string): AudioCodecEncoderSettings;
	static Find(Outer: UObject, ResourceName: string): AudioCodecEncoderSettings;
	static GetDefaultObject(): AudioCodecEncoderSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioCodecEncoderSettings;
	static C(Other: UObject | any): AudioCodecEncoderSettings;
}

declare class AudioEndpointSettingsBase extends UObject { 
	static Load(ResourceName: string): AudioEndpointSettingsBase;
	static Find(Outer: UObject, ResourceName: string): AudioEndpointSettingsBase;
	static GetDefaultObject(): AudioEndpointSettingsBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioEndpointSettingsBase;
	static C(Other: UObject | any): AudioEndpointSettingsBase;
}

declare class DummyEndpointSettings extends AudioEndpointSettingsBase { 
	static Load(ResourceName: string): DummyEndpointSettings;
	static Find(Outer: UObject, ResourceName: string): DummyEndpointSettings;
	static GetDefaultObject(): DummyEndpointSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DummyEndpointSettings;
	static C(Other: UObject | any): DummyEndpointSettings;
}

declare class SoundfieldEndpointSettingsBase extends UObject { 
	static Load(ResourceName: string): SoundfieldEndpointSettingsBase;
	static Find(Outer: UObject, ResourceName: string): SoundfieldEndpointSettingsBase;
	static GetDefaultObject(): SoundfieldEndpointSettingsBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundfieldEndpointSettingsBase;
	static C(Other: UObject | any): SoundfieldEndpointSettingsBase;
}

declare class SoundfieldEffectSettingsBase extends UObject { 
	static Load(ResourceName: string): SoundfieldEffectSettingsBase;
	static Find(Outer: UObject, ResourceName: string): SoundfieldEffectSettingsBase;
	static GetDefaultObject(): SoundfieldEffectSettingsBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundfieldEffectSettingsBase;
	static C(Other: UObject | any): SoundfieldEffectSettingsBase;
}

declare class SoundfieldEffectBase extends UObject { 
	Settings: SoundfieldEffectSettingsBase;
	static Load(ResourceName: string): SoundfieldEffectBase;
	static Find(Outer: UObject, ResourceName: string): SoundfieldEffectBase;
	static GetDefaultObject(): SoundfieldEffectBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundfieldEffectBase;
	static C(Other: UObject | any): SoundfieldEffectBase;
}

declare class WaveformTransformationChain extends UObject { 
	Transformations: WaveformTransformationBase[];
	static Load(ResourceName: string): WaveformTransformationChain;
	static Find(Outer: UObject, ResourceName: string): WaveformTransformationChain;
	static GetDefaultObject(): WaveformTransformationChain;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WaveformTransformationChain;
	static C(Other: UObject | any): WaveformTransformationChain;
}

declare type EPcmBitDepthConversion = 'SameAsSource' | 'Int16' | 'Float32' | 'EPcmBitDepthConversion_MAX';
declare var EPcmBitDepthConversion : { SameAsSource:'SameAsSource',Int16:'Int16',Float32:'Float32',EPcmBitDepthConversion_MAX:'EPcmBitDepthConversion_MAX', };
declare class AudioPcmEncoderSettings extends AudioCodecEncoderSettings { 
	BitDepthConversion: EPcmBitDepthConversion;
	static Load(ResourceName: string): AudioPcmEncoderSettings;
	static Find(Outer: UObject, ResourceName: string): AudioPcmEncoderSettings;
	static GetDefaultObject(): AudioPcmEncoderSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioPcmEncoderSettings;
	static C(Other: UObject | any): AudioPcmEncoderSettings;
}

declare class AudioLinkBlueprintInterface extends Interface { 
	static Load(ResourceName: string): AudioLinkBlueprintInterface;
	static Find(Outer: UObject, ResourceName: string): AudioLinkBlueprintInterface;
	static GetDefaultObject(): AudioLinkBlueprintInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioLinkBlueprintInterface;
	StopLink(): void;
	SetLinkSound(NewSound: SoundBase): void;
	PlayLink(StartTime: number): void;
	IsLinkPlaying(): boolean;
	static C(Other: UObject | any): AudioLinkBlueprintInterface;
}

declare class AutoCompleteCommand { 
	Command: string;
	Desc: string;
	clone() : AutoCompleteCommand;
	static C(Other: UObject | any): AutoCompleteCommand;
}

declare class ConsoleSettings extends UObject { 
	MaxScrollbackSize: number;
	ManualAutoCompleteList: AutoCompleteCommand[];
	AutoCompleteMapPaths: string[];
	BackgroundOpacityPercentage: number;
	bOrderTopToBottom: boolean;
	bDisplayHelpInAutoComplete: boolean;
	InputColor: Color;
	HistoryColor: Color;
	AutoCompleteCommandColor: Color;
	AutoCompleteCVarColor: Color;
	AutoCompleteFadedColor: Color;
	static Load(ResourceName: string): ConsoleSettings;
	static Find(Outer: UObject, ResourceName: string): ConsoleSettings;
	static GetDefaultObject(): ConsoleSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ConsoleSettings;
	static C(Other: UObject | any): ConsoleSettings;
}

declare class GeneralProjectSettings extends UObject { 
	CompanyName: string;
	CompanyDistinguishedName: string;
	CopyrightNotice: string;
	Description: string;
	Homepage: string;
	LicensingTerms: string;
	PrivacyPolicy: string;
	ProjectID: Guid;
	ProjectName: string;
	ProjectVersion: string;
	SupportContact: string;
	ProjectDisplayedTitle: string;
	ProjectDebugTitleInfo: string;
	bShouldWindowPreserveAspectRatio: boolean;
	bUseBorderlessWindow: boolean;
	bStartInVR: boolean;
	bAllowWindowResize: boolean;
	bAllowClose: boolean;
	bAllowMaximize: boolean;
	bAllowMinimize: boolean;
	EyeOffsetForFakeStereoRenderingDevice: number;
	FOVForFakeStereoRenderingDevice: number;
	static Load(ResourceName: string): GeneralProjectSettings;
	static Find(Outer: UObject, ResourceName: string): GeneralProjectSettings;
	static GetDefaultObject(): GeneralProjectSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeneralProjectSettings;
	static C(Other: UObject | any): GeneralProjectSettings;
}

declare class TemplateMapInfoOverride { 
	Thumbnail: SoftObjectPath;
	Map: SoftObjectPath;
	DisplayName: string;
	clone() : TemplateMapInfoOverride;
	static C(Other: UObject | any): TemplateMapInfoOverride;
}

declare type ETwoPlayerSplitScreenType = 'Horizontal' | 'Vertical' | 'ETwoPlayerSplitScreenType_MAX';
declare var ETwoPlayerSplitScreenType : { Horizontal:'Horizontal',Vertical:'Vertical',ETwoPlayerSplitScreenType_MAX:'ETwoPlayerSplitScreenType_MAX', };
declare type EThreePlayerSplitScreenType = 'FavorTop' | 'FavorBottom' | 'Vertical' | 'Horizontal' | 'EThreePlayerSplitScreenType_MAX';
declare var EThreePlayerSplitScreenType : { FavorTop:'FavorTop',FavorBottom:'FavorBottom',Vertical:'Vertical',Horizontal:'Horizontal',EThreePlayerSplitScreenType_MAX:'EThreePlayerSplitScreenType_MAX', };
declare type EFourPlayerSplitScreenType = 'Grid' | 'Vertical' | 'Horizontal' | 'EFourPlayerSplitScreenType_MAX';
declare var EFourPlayerSplitScreenType : { Grid:'Grid',Vertical:'Vertical',Horizontal:'Horizontal',EFourPlayerSplitScreenType_MAX:'EFourPlayerSplitScreenType_MAX', };
declare class GameModeName { 
	Name: string;
	GameMode: SoftClassPath;
	clone() : GameModeName;
	static C(Other: UObject | any): GameModeName;
}

declare class GameMapsSettings extends UObject { 
	EditorStartupMap: SoftObjectPath;
	EditorTemplateMapOverrides: TemplateMapInfoOverride[];
	LocalMapOptions: string;
	TransitionMap: SoftObjectPath;
	bUseSplitscreen: boolean;
	TwoPlayerSplitscreenLayout: ETwoPlayerSplitScreenType;
	ThreePlayerSplitscreenLayout: EThreePlayerSplitScreenType;
	FourPlayerSplitscreenLayout: EFourPlayerSplitScreenType;
	bOffsetPlayerGamepadIds: boolean;
	GameInstanceClass: SoftClassPath;
	GameDefaultMap: SoftObjectPath;
	ServerDefaultMap: SoftObjectPath;
	GlobalDefaultGameMode: SoftClassPath;
	GlobalDefaultServerGameMode: SoftClassPath;
	GameModeMapPrefixes: GameModeName[];
	GameModeClassAliases: GameModeName[];
	static Load(ResourceName: string): GameMapsSettings;
	static Find(Outer: UObject, ResourceName: string): GameMapsSettings;
	static GetDefaultObject(): GameMapsSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameMapsSettings;
	SetSkipAssigningGamepadToPlayer1(bSkipFirstPlayer: boolean): void;
	GetSkipAssigningGamepadToPlayer1(): boolean;
	static GetGameMapsSettings(): GameMapsSettings;
	static C(Other: UObject | any): GameMapsSettings;
}

declare class GameNetworkManagerSettings extends UObject { 
	MinDynamicBandwidth: number;
	MaxDynamicBandwidth: number;
	TotalNetBandwidth: number;
	BadPingThreshold: number;
	bIsStandbyCheckingEnabled: boolean;
	StandbyRxCheatTime: number;
	StandbyTxCheatTime: number;
	PercentMissingForRxStandby: number;
	PercentMissingForTxStandby: number;
	PercentForBadPing: number;
	JoinInProgressStandbyWaitTime: number;
	static Load(ResourceName: string): GameNetworkManagerSettings;
	static Find(Outer: UObject, ResourceName: string): GameNetworkManagerSettings;
	static GetDefaultObject(): GameNetworkManagerSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameNetworkManagerSettings;
	static C(Other: UObject | any): GameNetworkManagerSettings;
}

declare class GameSessionSettings extends UObject { 
	MaxSpectators: number;
	MaxPlayers: number;
	bRequiresPushToTalk: boolean;
	static Load(ResourceName: string): GameSessionSettings;
	static Find(Outer: UObject, ResourceName: string): GameSessionSettings;
	static GetDefaultObject(): GameSessionSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameSessionSettings;
	static C(Other: UObject | any): GameSessionSettings;
}

declare class HudSettings extends UObject { 
	bShowHUD: boolean;
	DebugDisplay: string[];
	static Load(ResourceName: string): HudSettings;
	static Find(Outer: UObject, ResourceName: string): HudSettings;
	static GetDefaultObject(): HudSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HudSettings;
	static C(Other: UObject | any): HudSettings;
}

declare class GeneralEngineSettings extends UObject { 
	static Load(ResourceName: string): GeneralEngineSettings;
	static Find(Outer: UObject, ResourceName: string): GeneralEngineSettings;
	static GetDefaultObject(): GeneralEngineSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeneralEngineSettings;
	static C(Other: UObject | any): GeneralEngineSettings;
}

declare class AssetBackedTarget extends Interface { 
	static Load(ResourceName: string): AssetBackedTarget;
	static Find(Outer: UObject, ResourceName: string): AssetBackedTarget;
	static GetDefaultObject(): AssetBackedTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetBackedTarget;
	static C(Other: UObject | any): AssetBackedTarget;
}

declare class GizmoViewContext extends UObject { 
	static Load(ResourceName: string): GizmoViewContext;
	static Find(Outer: UObject, ResourceName: string): GizmoViewContext;
	static GetDefaultObject(): GizmoViewContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoViewContext;
	static C(Other: UObject | any): GizmoViewContext;
}

declare class GizmoBaseComponent extends PrimitiveComponent { 
	Color: LinearColor;
	HoverSizeMultiplier: number;
	PixelHitDistanceThreshold: number;
	GizmoViewContext: GizmoViewContext;
	static Load(ResourceName: string): GizmoBaseComponent;
	static Find(Outer: UObject, ResourceName: string): GizmoBaseComponent;
	static GetDefaultObject(): GizmoBaseComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoBaseComponent;
	UpdateWorldLocalState(bWorldIn: boolean): void;
	UpdateHoverState(bHoveringIn: boolean): void;
	static C(Other: UObject | any): GizmoBaseComponent;
}

declare class GizmoElementMaterialAttribute { 
	Value: MaterialInterface;
	bOverridesChildState: boolean;
	clone() : GizmoElementMaterialAttribute;
	static C(Other: UObject | any): GizmoElementMaterialAttribute;
}

declare class GizmoElementColorAttribute { 
	Value: LinearColor;
	bHasValue: boolean;
	bOverridesChildState: boolean;
	clone() : GizmoElementColorAttribute;
	static C(Other: UObject | any): GizmoElementColorAttribute;
}

declare class GizmoElementMeshRenderStateAttributes { 
	Material: GizmoElementMaterialAttribute;
	HoverMaterial: GizmoElementMaterialAttribute;
	InteractMaterial: GizmoElementMaterialAttribute;
	VertexColor: GizmoElementColorAttribute;
	HoverVertexColor: GizmoElementColorAttribute;
	InteractVertexColor: GizmoElementColorAttribute;
	clone() : GizmoElementMeshRenderStateAttributes;
	static C(Other: UObject | any): GizmoElementMeshRenderStateAttributes;
}

declare type EGizmoElementState = 'None' | 'Visible' | 'Hittable' | 'VisibleAndHittable' | 'EGizmoElementState_MAX';
declare var EGizmoElementState : { None:'None',Visible:'Visible',Hittable:'Hittable',VisibleAndHittable:'VisibleAndHittable',EGizmoElementState_MAX:'EGizmoElementState_MAX', };
declare type EGizmoElementInteractionState = 'None' | 'Hovering' | 'Interacting' | 'EGizmoElementInteractionState_MAX';
declare var EGizmoElementInteractionState : { None:'None',Hovering:'Hovering',Interacting:'Interacting',EGizmoElementInteractionState_MAX:'EGizmoElementInteractionState_MAX', };
declare type EGizmoElementViewDependentType = 'None' | 'Axis' | 'Plane' | 'EGizmoElementViewDependentType_MAX';
declare var EGizmoElementViewDependentType : { None:'None',Axis:'Axis',Plane:'Plane',EGizmoElementViewDependentType_MAX:'EGizmoElementViewDependentType_MAX', };
declare type EGizmoElementViewAlignType = 'None' | 'PointOnly' | 'PointEye' | 'PointScreen' | 'Axial' | 'EGizmoElementViewAlignType_MAX';
declare var EGizmoElementViewAlignType : { None:'None',PointOnly:'PointOnly',PointEye:'PointEye',PointScreen:'PointScreen',Axial:'Axial',EGizmoElementViewAlignType_MAX:'EGizmoElementViewAlignType_MAX', };
declare class GizmoElementBase extends UObject { 
	bEnabled: boolean;
	bEnabledForPerspectiveProjection: boolean;
	bEnabledForOrthographicProjection: boolean;
	bEnabledForDefaultState: boolean;
	bEnabledForHoveringState: boolean;
	bEnabledForInteractingState: boolean;
	PartIdentifier: number;
	MeshRenderAttributes: GizmoElementMeshRenderStateAttributes;
	ElementState: EGizmoElementState;
	ElementInteractionState: EGizmoElementInteractionState;
	ViewDependentType: EGizmoElementViewDependentType;
	ViewDependentAxis: Vector;
	ViewDependentAngleTol: number;
	ViewDependentAxialMaxCosAngleTol: number;
	ViewDependentPlanarMinCosAngleTol: number;
	ViewAlignType: EGizmoElementViewAlignType;
	ViewAlignAxis: Vector;
	ViewAlignNormal: Vector;
	ViewAlignAxialAngleTol: number;
	ViewAlignAxialMaxCosAngleTol: number;
	PixelHitDistanceThreshold: number;
	static Load(ResourceName: string): GizmoElementBase;
	static Find(Outer: UObject, ResourceName: string): GizmoElementBase;
	static GetDefaultObject(): GizmoElementBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoElementBase;
	static C(Other: UObject | any): GizmoElementBase;
}

declare class GizmoElementLineRenderStateAttributes { 
	LineColor: GizmoElementColorAttribute;
	HoverLineColor: GizmoElementColorAttribute;
	InteractLineColor: GizmoElementColorAttribute;
	clone() : GizmoElementLineRenderStateAttributes;
	static C(Other: UObject | any): GizmoElementLineRenderStateAttributes;
}

declare class GizmoElementLineBase extends GizmoElementBase { 
	LineRenderAttributes: GizmoElementLineRenderStateAttributes;
	LineThickness: number;
	bScreenSpaceLine: boolean;
	HoverLineThicknessMultiplier: number;
	InteractLineThicknessMultiplier: number;
	static Load(ResourceName: string): GizmoElementLineBase;
	static Find(Outer: UObject, ResourceName: string): GizmoElementLineBase;
	static GetDefaultObject(): GizmoElementLineBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoElementLineBase;
	static C(Other: UObject | any): GizmoElementLineBase;
}

declare type EGizmoElementPartialType = 'None' | 'Partial' | 'PartialViewDependent' | 'EGizmoElementPartialType_MAX';
declare var EGizmoElementPartialType : { None:'None',Partial:'Partial',PartialViewDependent:'PartialViewDependent',EGizmoElementPartialType_MAX:'EGizmoElementPartialType_MAX', };
declare class GizmoElementCircleBase extends GizmoElementLineBase { 
	Center: Vector;
	Axis0: Vector;
	Axis1: Vector;
	Radius: number;
	NumSegments: number;
	PartialType: EGizmoElementPartialType;
	PartialStartAngle: number;
	PartialEndAngle: number;
	PartialViewDependentMaxCosTol: number;
	static Load(ResourceName: string): GizmoElementCircleBase;
	static Find(Outer: UObject, ResourceName: string): GizmoElementCircleBase;
	static GetDefaultObject(): GizmoElementCircleBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoElementCircleBase;
	static C(Other: UObject | any): GizmoElementCircleBase;
}

declare class GizmoElementArc extends GizmoElementCircleBase { 
	InnerRadius: number;
	static Load(ResourceName: string): GizmoElementArc;
	static Find(Outer: UObject, ResourceName: string): GizmoElementArc;
	static GetDefaultObject(): GizmoElementArc;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoElementArc;
	static C(Other: UObject | any): GizmoElementArc;
}

declare class InteractiveCommandArguments extends UObject { 
	static Load(ResourceName: string): InteractiveCommandArguments;
	static Find(Outer: UObject, ResourceName: string): InteractiveCommandArguments;
	static GetDefaultObject(): InteractiveCommandArguments;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveCommandArguments;
	static C(Other: UObject | any): InteractiveCommandArguments;
}

declare class InteractiveCommand extends UObject { 
	static Load(ResourceName: string): InteractiveCommand;
	static Find(Outer: UObject, ResourceName: string): InteractiveCommand;
	static GetDefaultObject(): InteractiveCommand;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveCommand;
	static C(Other: UObject | any): InteractiveCommand;
}

declare class InteractiveGizmoBuilder extends UObject { 
	static Load(ResourceName: string): InteractiveGizmoBuilder;
	static Find(Outer: UObject, ResourceName: string): InteractiveGizmoBuilder;
	static GetDefaultObject(): InteractiveGizmoBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveGizmoBuilder;
	static C(Other: UObject | any): InteractiveGizmoBuilder;
}

declare class ToolContextTransactionProvider extends Interface { 
	static Load(ResourceName: string): ToolContextTransactionProvider;
	static Find(Outer: UObject, ResourceName: string): ToolContextTransactionProvider;
	static GetDefaultObject(): ToolContextTransactionProvider;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolContextTransactionProvider;
	static C(Other: UObject | any): ToolContextTransactionProvider;
}

declare class InternalToolFrameworkActor extends Actor { 
	bIsSelectableInEditor: boolean;
	static GetDefaultObject(): InternalToolFrameworkActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InternalToolFrameworkActor;
	static C(Other: UObject | any): InternalToolFrameworkActor;
}

declare class ToolFrameworkComponent extends Interface { 
	static Load(ResourceName: string): ToolFrameworkComponent;
	static Find(Outer: UObject, ResourceName: string): ToolFrameworkComponent;
	static GetDefaultObject(): ToolFrameworkComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolFrameworkComponent;
	static C(Other: UObject | any): ToolFrameworkComponent;
}

declare class InteractiveToolCameraFocusAPI extends Interface { 
	static Load(ResourceName: string): InteractiveToolCameraFocusAPI;
	static Find(Outer: UObject, ResourceName: string): InteractiveToolCameraFocusAPI;
	static GetDefaultObject(): InteractiveToolCameraFocusAPI;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveToolCameraFocusAPI;
	static C(Other: UObject | any): InteractiveToolCameraFocusAPI;
}

declare class InteractiveToolNestedAcceptCancelAPI extends Interface { 
	static Load(ResourceName: string): InteractiveToolNestedAcceptCancelAPI;
	static Find(Outer: UObject, ResourceName: string): InteractiveToolNestedAcceptCancelAPI;
	static GetDefaultObject(): InteractiveToolNestedAcceptCancelAPI;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveToolNestedAcceptCancelAPI;
	static C(Other: UObject | any): InteractiveToolNestedAcceptCancelAPI;
}

declare class InteractiveToolExclusiveToolAPI extends Interface { 
	static Load(ResourceName: string): InteractiveToolExclusiveToolAPI;
	static Find(Outer: UObject, ResourceName: string): InteractiveToolExclusiveToolAPI;
	static GetDefaultObject(): InteractiveToolExclusiveToolAPI;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveToolExclusiveToolAPI;
	static C(Other: UObject | any): InteractiveToolExclusiveToolAPI;
}

declare class MaterialProvider extends Interface { 
	static Load(ResourceName: string): MaterialProvider;
	static Find(Outer: UObject, ResourceName: string): MaterialProvider;
	static GetDefaultObject(): MaterialProvider;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialProvider;
	static C(Other: UObject | any): MaterialProvider;
}

declare class MeshDescriptionCommitter extends Interface { 
	static Load(ResourceName: string): MeshDescriptionCommitter;
	static Find(Outer: UObject, ResourceName: string): MeshDescriptionCommitter;
	static GetDefaultObject(): MeshDescriptionCommitter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MeshDescriptionCommitter;
	static C(Other: UObject | any): MeshDescriptionCommitter;
}

declare class MeshDescriptionProvider extends Interface { 
	static Load(ResourceName: string): MeshDescriptionProvider;
	static Find(Outer: UObject, ResourceName: string): MeshDescriptionProvider;
	static GetDefaultObject(): MeshDescriptionProvider;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MeshDescriptionProvider;
	static C(Other: UObject | any): MeshDescriptionProvider;
}

declare class GizmoBaseVec2ParameterSource extends UObject { 
	static Load(ResourceName: string): GizmoBaseVec2ParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoBaseVec2ParameterSource;
	static GetDefaultObject(): GizmoBaseVec2ParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoBaseVec2ParameterSource;
	static C(Other: UObject | any): GizmoBaseVec2ParameterSource;
}

declare class GizmoVec2ParameterChange { 
	InitialValue: Vector2D;
	CurrentValue: Vector2D;
	clone() : GizmoVec2ParameterChange;
	static C(Other: UObject | any): GizmoVec2ParameterChange;
}

declare class GizmoLocalVec2ParameterSource extends GizmoBaseVec2ParameterSource { 
	Value: Vector2D;
	LastChange: GizmoVec2ParameterChange;
	static Load(ResourceName: string): GizmoLocalVec2ParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoLocalVec2ParameterSource;
	static GetDefaultObject(): GizmoLocalVec2ParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoLocalVec2ParameterSource;
	static C(Other: UObject | any): GizmoLocalVec2ParameterSource;
}

declare class GizmoBaseFloatParameterSource extends UObject { 
	static Load(ResourceName: string): GizmoBaseFloatParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoBaseFloatParameterSource;
	static GetDefaultObject(): GizmoBaseFloatParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoBaseFloatParameterSource;
	static C(Other: UObject | any): GizmoBaseFloatParameterSource;
}

declare class GizmoAxisSource extends Interface { 
	static Load(ResourceName: string): GizmoAxisSource;
	static Find(Outer: UObject, ResourceName: string): GizmoAxisSource;
	static GetDefaultObject(): GizmoAxisSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoAxisSource;
	HasTangentVectors(): boolean;
	GetTangentVectors(TangentXOut?: Vector,TangentYOut?: Vector): {TangentXOut: Vector, TangentYOut: Vector};
	GetOrigin(): Vector;
	GetDirection(): Vector;
	static C(Other: UObject | any): GizmoAxisSource;
}

declare class GizmoTransformSource extends Interface { 
	static Load(ResourceName: string): GizmoTransformSource;
	static Find(Outer: UObject, ResourceName: string): GizmoTransformSource;
	static GetDefaultObject(): GizmoTransformSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoTransformSource;
	SetTransform(NewTransform: Transform): void;
	GetTransform(): Transform;
	static C(Other: UObject | any): GizmoTransformSource;
}

declare class GizmoFloatParameterChange { 
	InitialValue: number;
	CurrentValue: number;
	clone() : GizmoFloatParameterChange;
	static C(Other: UObject | any): GizmoFloatParameterChange;
}

declare class GizmoAxisTranslationParameterSource extends GizmoBaseFloatParameterSource { 
	AxisSource: GizmoAxisSource;
	TransformSource: GizmoTransformSource;
	Parameter: number;
	LastChange: GizmoFloatParameterChange;
	CurTranslationAxis: Vector;
	CurTranslationOrigin: Vector;
	InitialTransform: Transform;
	static Load(ResourceName: string): GizmoAxisTranslationParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoAxisTranslationParameterSource;
	static GetDefaultObject(): GizmoAxisTranslationParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoAxisTranslationParameterSource;
	static C(Other: UObject | any): GizmoAxisTranslationParameterSource;
}

declare class GizmoPlaneTranslationParameterSource extends GizmoBaseVec2ParameterSource { 
	AxisSource: GizmoAxisSource;
	TransformSource: GizmoTransformSource;
	Parameter: Vector2D;
	LastChange: GizmoVec2ParameterChange;
	CurTranslationOrigin: Vector;
	CurTranslationNormal: Vector;
	CurTranslationAxisX: Vector;
	CurTranslationAxisY: Vector;
	InitialTransform: Transform;
	static Load(ResourceName: string): GizmoPlaneTranslationParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoPlaneTranslationParameterSource;
	static GetDefaultObject(): GizmoPlaneTranslationParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoPlaneTranslationParameterSource;
	static C(Other: UObject | any): GizmoPlaneTranslationParameterSource;
}

declare class GizmoAxisRotationParameterSource extends GizmoBaseFloatParameterSource { 
	AxisSource: GizmoAxisSource;
	TransformSource: GizmoTransformSource;
	Angle: number;
	LastChange: GizmoFloatParameterChange;
	CurRotationAxis: Vector;
	CurRotationOrigin: Vector;
	InitialTransform: Transform;
	static Load(ResourceName: string): GizmoAxisRotationParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoAxisRotationParameterSource;
	static GetDefaultObject(): GizmoAxisRotationParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoAxisRotationParameterSource;
	static C(Other: UObject | any): GizmoAxisRotationParameterSource;
}

declare class GizmoUniformScaleParameterSource extends GizmoBaseVec2ParameterSource { 
	AxisSource: GizmoAxisSource;
	TransformSource: GizmoTransformSource;
	ScaleMultiplier: number;
	Parameter: Vector2D;
	LastChange: GizmoVec2ParameterChange;
	CurScaleOrigin: Vector;
	CurScaleNormal: Vector;
	CurScaleAxisX: Vector;
	CurScaleAxisY: Vector;
	InitialTransform: Transform;
	static Load(ResourceName: string): GizmoUniformScaleParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoUniformScaleParameterSource;
	static GetDefaultObject(): GizmoUniformScaleParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoUniformScaleParameterSource;
	static C(Other: UObject | any): GizmoUniformScaleParameterSource;
}

declare class GizmoAxisScaleParameterSource extends GizmoBaseFloatParameterSource { 
	AxisSource: GizmoAxisSource;
	TransformSource: GizmoTransformSource;
	ScaleMultiplier: number;
	bClampToZero: boolean;
	Parameter: number;
	LastChange: GizmoFloatParameterChange;
	CurScaleAxis: Vector;
	CurScaleOrigin: Vector;
	InitialTransform: Transform;
	static Load(ResourceName: string): GizmoAxisScaleParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoAxisScaleParameterSource;
	static GetDefaultObject(): GizmoAxisScaleParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoAxisScaleParameterSource;
	static C(Other: UObject | any): GizmoAxisScaleParameterSource;
}

declare class GizmoPlaneScaleParameterSource extends GizmoBaseVec2ParameterSource { 
	AxisSource: GizmoAxisSource;
	TransformSource: GizmoTransformSource;
	ScaleMultiplier: number;
	bUseEqualScaling: boolean;
	bClampToZero: boolean;
	Parameter: Vector2D;
	LastChange: GizmoVec2ParameterChange;
	CurScaleOrigin: Vector;
	CurScaleNormal: Vector;
	CurScaleAxisX: Vector;
	CurScaleAxisY: Vector;
	InitialTransform: Transform;
	static Load(ResourceName: string): GizmoPlaneScaleParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoPlaneScaleParameterSource;
	static GetDefaultObject(): GizmoPlaneScaleParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoPlaneScaleParameterSource;
	static C(Other: UObject | any): GizmoPlaneScaleParameterSource;
}

declare class PhysicsDataSource extends Interface { 
	static Load(ResourceName: string): PhysicsDataSource;
	static Find(Outer: UObject, ResourceName: string): PhysicsDataSource;
	static GetDefaultObject(): PhysicsDataSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsDataSource;
	static C(Other: UObject | any): PhysicsDataSource;
}

declare class PrimitiveComponentBackedTarget extends Interface { 
	static Load(ResourceName: string): PrimitiveComponentBackedTarget;
	static Find(Outer: UObject, ResourceName: string): PrimitiveComponentBackedTarget;
	static GetDefaultObject(): PrimitiveComponentBackedTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PrimitiveComponentBackedTarget;
	static C(Other: UObject | any): PrimitiveComponentBackedTarget;
}

declare class SkeletalMeshBackedTarget extends AssetBackedTarget { 
	static Load(ResourceName: string): SkeletalMeshBackedTarget;
	static Find(Outer: UObject, ResourceName: string): SkeletalMeshBackedTarget;
	static GetDefaultObject(): SkeletalMeshBackedTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkeletalMeshBackedTarget;
	static C(Other: UObject | any): SkeletalMeshBackedTarget;
}

declare class StaticMeshBackedTarget extends AssetBackedTarget { 
	static Load(ResourceName: string): StaticMeshBackedTarget;
	static Find(Outer: UObject, ResourceName: string): StaticMeshBackedTarget;
	static GetDefaultObject(): StaticMeshBackedTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StaticMeshBackedTarget;
	static C(Other: UObject | any): StaticMeshBackedTarget;
}

declare class InputBehavior extends UObject { 
	static Load(ResourceName: string): InputBehavior;
	static Find(Outer: UObject, ResourceName: string): InputBehavior;
	static GetDefaultObject(): InputBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputBehavior;
	static C(Other: UObject | any): InputBehavior;
}

declare class AnyButtonInputBehavior extends InputBehavior { 
	static Load(ResourceName: string): AnyButtonInputBehavior;
	static Find(Outer: UObject, ResourceName: string): AnyButtonInputBehavior;
	static GetDefaultObject(): AnyButtonInputBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnyButtonInputBehavior;
	static C(Other: UObject | any): AnyButtonInputBehavior;
}

declare class ClickDragInputBehavior extends AnyButtonInputBehavior { 
	bUpdateModifiersDuringDrag: boolean;
	static Load(ResourceName: string): ClickDragInputBehavior;
	static Find(Outer: UObject, ResourceName: string): ClickDragInputBehavior;
	static GetDefaultObject(): ClickDragInputBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClickDragInputBehavior;
	static C(Other: UObject | any): ClickDragInputBehavior;
}

declare class LocalClickDragInputBehavior extends ClickDragInputBehavior { 
	static Load(ResourceName: string): LocalClickDragInputBehavior;
	static Find(Outer: UObject, ResourceName: string): LocalClickDragInputBehavior;
	static GetDefaultObject(): LocalClickDragInputBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalClickDragInputBehavior;
	static C(Other: UObject | any): LocalClickDragInputBehavior;
}

declare class KeyAsModifierInputBehavior extends InputBehavior { 
	static Load(ResourceName: string): KeyAsModifierInputBehavior;
	static Find(Outer: UObject, ResourceName: string): KeyAsModifierInputBehavior;
	static GetDefaultObject(): KeyAsModifierInputBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): KeyAsModifierInputBehavior;
	static C(Other: UObject | any): KeyAsModifierInputBehavior;
}

declare class MouseHoverBehavior extends InputBehavior { 
	static Load(ResourceName: string): MouseHoverBehavior;
	static Find(Outer: UObject, ResourceName: string): MouseHoverBehavior;
	static GetDefaultObject(): MouseHoverBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MouseHoverBehavior;
	static C(Other: UObject | any): MouseHoverBehavior;
}

declare class LocalMouseHoverBehavior extends MouseHoverBehavior { 
	static Load(ResourceName: string): LocalMouseHoverBehavior;
	static Find(Outer: UObject, ResourceName: string): LocalMouseHoverBehavior;
	static GetDefaultObject(): LocalMouseHoverBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalMouseHoverBehavior;
	static C(Other: UObject | any): LocalMouseHoverBehavior;
}

declare class MouseWheelInputBehavior extends AnyButtonInputBehavior { 
	static Load(ResourceName: string): MouseWheelInputBehavior;
	static Find(Outer: UObject, ResourceName: string): MouseWheelInputBehavior;
	static GetDefaultObject(): MouseWheelInputBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MouseWheelInputBehavior;
	static C(Other: UObject | any): MouseWheelInputBehavior;
}

declare class MultiClickSequenceInputBehavior extends AnyButtonInputBehavior { 
	static Load(ResourceName: string): MultiClickSequenceInputBehavior;
	static Find(Outer: UObject, ResourceName: string): MultiClickSequenceInputBehavior;
	static GetDefaultObject(): MultiClickSequenceInputBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MultiClickSequenceInputBehavior;
	static C(Other: UObject | any): MultiClickSequenceInputBehavior;
}

declare class SingleClickInputBehavior extends AnyButtonInputBehavior { 
	HitTestOnRelease: boolean;
	static Load(ResourceName: string): SingleClickInputBehavior;
	static Find(Outer: UObject, ResourceName: string): SingleClickInputBehavior;
	static GetDefaultObject(): SingleClickInputBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SingleClickInputBehavior;
	static C(Other: UObject | any): SingleClickInputBehavior;
}

declare class LocalSingleClickInputBehavior extends SingleClickInputBehavior { 
	static Load(ResourceName: string): LocalSingleClickInputBehavior;
	static Find(Outer: UObject, ResourceName: string): LocalSingleClickInputBehavior;
	static GetDefaultObject(): LocalSingleClickInputBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalSingleClickInputBehavior;
	static C(Other: UObject | any): LocalSingleClickInputBehavior;
}

declare class SingleClickOrDragInputBehavior extends AnyButtonInputBehavior { 
	bBeginDragIfClickTargetNotHit: boolean;
	ClickDistanceThreshold: number;
	static Load(ResourceName: string): SingleClickOrDragInputBehavior;
	static Find(Outer: UObject, ResourceName: string): SingleClickOrDragInputBehavior;
	static GetDefaultObject(): SingleClickOrDragInputBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SingleClickOrDragInputBehavior;
	static C(Other: UObject | any): SingleClickOrDragInputBehavior;
}

declare class SingleKeyCaptureBehavior extends InputBehavior { 
	static Load(ResourceName: string): SingleKeyCaptureBehavior;
	static Find(Outer: UObject, ResourceName: string): SingleKeyCaptureBehavior;
	static GetDefaultObject(): SingleKeyCaptureBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SingleKeyCaptureBehavior;
	static C(Other: UObject | any): SingleKeyCaptureBehavior;
}

declare class WidgetBaseBehavior extends Interface { 
	static Load(ResourceName: string): WidgetBaseBehavior;
	static Find(Outer: UObject, ResourceName: string): WidgetBaseBehavior;
	static GetDefaultObject(): WidgetBaseBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetBaseBehavior;
	static C(Other: UObject | any): WidgetBaseBehavior;
}

declare class AxisAngleGizmoBuilder extends InteractiveGizmoBuilder { 
	static Load(ResourceName: string): AxisAngleGizmoBuilder;
	static Find(Outer: UObject, ResourceName: string): AxisAngleGizmoBuilder;
	static GetDefaultObject(): AxisAngleGizmoBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AxisAngleGizmoBuilder;
	static C(Other: UObject | any): AxisAngleGizmoBuilder;
}

declare class BehaviorInfo { 
	Behavior: InputBehavior;
	clone() : BehaviorInfo;
	static C(Other: UObject | any): BehaviorInfo;
}

declare class InputBehaviorSet extends UObject { 
	Behaviors: BehaviorInfo[];
	static Load(ResourceName: string): InputBehaviorSet;
	static Find(Outer: UObject, ResourceName: string): InputBehaviorSet;
	static GetDefaultObject(): InputBehaviorSet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputBehaviorSet;
	static C(Other: UObject | any): InputBehaviorSet;
}

declare class InteractiveGizmo extends UObject { 
	InputBehaviors: InputBehaviorSet;
	static Load(ResourceName: string): InteractiveGizmo;
	static Find(Outer: UObject, ResourceName: string): InteractiveGizmo;
	static GetDefaultObject(): InteractiveGizmo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveGizmo;
	static C(Other: UObject | any): InteractiveGizmo;
}

declare class GizmoFloatParameterSource extends Interface { 
	static Load(ResourceName: string): GizmoFloatParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoFloatParameterSource;
	static GetDefaultObject(): GizmoFloatParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoFloatParameterSource;
	SetParameter(NewValue: number): void;
	GetParameter(): number;
	EndModify(): void;
	BeginModify(): void;
	static C(Other: UObject | any): GizmoFloatParameterSource;
}

declare class GizmoClickTarget extends Interface { 
	static Load(ResourceName: string): GizmoClickTarget;
	static Find(Outer: UObject, ResourceName: string): GizmoClickTarget;
	static GetDefaultObject(): GizmoClickTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoClickTarget;
	UpdateInteractingState(bInteracting: boolean): void;
	UpdateHoverState(bHovering: boolean): void;
	static C(Other: UObject | any): GizmoClickTarget;
}

declare class GizmoStateTarget extends Interface { 
	static Load(ResourceName: string): GizmoStateTarget;
	static Find(Outer: UObject, ResourceName: string): GizmoStateTarget;
	static GetDefaultObject(): GizmoStateTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoStateTarget;
	EndUpdate(): void;
	BeginUpdate(): void;
	static C(Other: UObject | any): GizmoStateTarget;
}

declare class AxisAngleGizmo extends InteractiveGizmo { 
	AxisSource: GizmoAxisSource;
	AngleSource: GizmoFloatParameterSource;
	HitTarget: GizmoClickTarget;
	StateTarget: GizmoStateTarget;
	MouseBehavior: ClickDragInputBehavior;
	bInInteraction: boolean;
	RotationOrigin: Vector;
	RotationAxis: Vector;
	RotationPlaneX: Vector;
	RotationPlaneY: Vector;
	InteractionStartPoint: Vector;
	InteractionCurPoint: Vector;
	InteractionStartAngle: number;
	InteractionCurAngle: number;
	static Load(ResourceName: string): AxisAngleGizmo;
	static Find(Outer: UObject, ResourceName: string): AxisAngleGizmo;
	static GetDefaultObject(): AxisAngleGizmo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AxisAngleGizmo;
	static C(Other: UObject | any): AxisAngleGizmo;
}

declare class AxisPositionGizmoBuilder extends InteractiveGizmoBuilder { 
	static Load(ResourceName: string): AxisPositionGizmoBuilder;
	static Find(Outer: UObject, ResourceName: string): AxisPositionGizmoBuilder;
	static GetDefaultObject(): AxisPositionGizmoBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AxisPositionGizmoBuilder;
	static C(Other: UObject | any): AxisPositionGizmoBuilder;
}

declare class AxisPositionGizmo extends InteractiveGizmo { 
	AxisSource: GizmoAxisSource;
	ParameterSource: GizmoFloatParameterSource;
	GizmoViewContext: GizmoViewContext;
	HitTarget: GizmoClickTarget;
	StateTarget: GizmoStateTarget;
	MouseBehavior: ClickDragInputBehavior;
	bEnableSignedAxis: boolean;
	bInInteraction: boolean;
	InteractionOrigin: Vector;
	InteractionAxis: Vector;
	InteractionStartPoint: Vector;
	InteractionCurPoint: Vector;
	InteractionStartParameter: number;
	InteractionCurParameter: number;
	ParameterSign: number;
	static Load(ResourceName: string): AxisPositionGizmo;
	static Find(Outer: UObject, ResourceName: string): AxisPositionGizmo;
	static GetDefaultObject(): AxisPositionGizmo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AxisPositionGizmo;
	static C(Other: UObject | any): AxisPositionGizmo;
}

declare class GizmoConstantAxisSource extends UObject { 
	Origin: Vector;
	Direction: Vector;
	static Load(ResourceName: string): GizmoConstantAxisSource;
	static Find(Outer: UObject, ResourceName: string): GizmoConstantAxisSource;
	static GetDefaultObject(): GizmoConstantAxisSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoConstantAxisSource;
	static C(Other: UObject | any): GizmoConstantAxisSource;
}

declare class GizmoConstantFrameAxisSource extends UObject { 
	Origin: Vector;
	Direction: Vector;
	TangentX: Vector;
	TangentY: Vector;
	static Load(ResourceName: string): GizmoConstantFrameAxisSource;
	static Find(Outer: UObject, ResourceName: string): GizmoConstantFrameAxisSource;
	static GetDefaultObject(): GizmoConstantFrameAxisSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoConstantFrameAxisSource;
	static C(Other: UObject | any): GizmoConstantFrameAxisSource;
}

declare class GizmoWorldAxisSource extends UObject { 
	Origin: Vector;
	AxisIndex: number;
	static Load(ResourceName: string): GizmoWorldAxisSource;
	static Find(Outer: UObject, ResourceName: string): GizmoWorldAxisSource;
	static GetDefaultObject(): GizmoWorldAxisSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoWorldAxisSource;
	static C(Other: UObject | any): GizmoWorldAxisSource;
}

declare class GizmoComponentAxisSource extends UObject { 
	Component: SceneComponent;
	AxisIndex: number;
	bLocalAxes: boolean;
	static Load(ResourceName: string): GizmoComponentAxisSource;
	static Find(Outer: UObject, ResourceName: string): GizmoComponentAxisSource;
	static GetDefaultObject(): GizmoComponentAxisSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoComponentAxisSource;
	static C(Other: UObject | any): GizmoComponentAxisSource;
}

declare class BrushStampIndicatorBuilder extends InteractiveGizmoBuilder { 
	static Load(ResourceName: string): BrushStampIndicatorBuilder;
	static Find(Outer: UObject, ResourceName: string): BrushStampIndicatorBuilder;
	static GetDefaultObject(): BrushStampIndicatorBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BrushStampIndicatorBuilder;
	static C(Other: UObject | any): BrushStampIndicatorBuilder;
}

declare class BrushStampIndicator extends InteractiveGizmo { 
	bVisible: boolean;
	BrushRadius: number;
	BrushFalloff: number;
	BrushPosition: Vector;
	BrushNormal: Vector;
	bDrawIndicatorLines: boolean;
	bDrawRadiusCircle: boolean;
	SampleStepCount: number;
	LineColor: LinearColor;
	LineThickness: number;
	bDepthTested: boolean;
	bDrawSecondaryLines: boolean;
	SecondaryLineThickness: number;
	SecondaryLineColor: LinearColor;
	AttachedComponent: PrimitiveComponent;
	static Load(ResourceName: string): BrushStampIndicator;
	static Find(Outer: UObject, ResourceName: string): BrushStampIndicator;
	static GetDefaultObject(): BrushStampIndicator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BrushStampIndicator;
	static C(Other: UObject | any): BrushStampIndicator;
}

declare class GizmoActor extends InternalToolFrameworkActor { 
	static GetDefaultObject(): GizmoActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoActor;
	static C(Other: UObject | any): GizmoActor;
}

declare class CombinedTransformGizmoActor extends GizmoActor { 
	TranslateX: PrimitiveComponent;
	TranslateY: PrimitiveComponent;
	TranslateZ: PrimitiveComponent;
	TranslateYZ: PrimitiveComponent;
	TranslateXZ: PrimitiveComponent;
	TranslateXY: PrimitiveComponent;
	RotateX: PrimitiveComponent;
	RotateY: PrimitiveComponent;
	RotateZ: PrimitiveComponent;
	UniformScale: PrimitiveComponent;
	AxisScaleX: PrimitiveComponent;
	AxisScaleY: PrimitiveComponent;
	AxisScaleZ: PrimitiveComponent;
	PlaneScaleYZ: PrimitiveComponent;
	PlaneScaleXZ: PrimitiveComponent;
	PlaneScaleXY: PrimitiveComponent;
	static GetDefaultObject(): CombinedTransformGizmoActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CombinedTransformGizmoActor;
	static C(Other: UObject | any): CombinedTransformGizmoActor;
}

declare class CombinedTransformGizmoBuilder extends InteractiveGizmoBuilder { 
	static Load(ResourceName: string): CombinedTransformGizmoBuilder;
	static Find(Outer: UObject, ResourceName: string): CombinedTransformGizmoBuilder;
	static GetDefaultObject(): CombinedTransformGizmoBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CombinedTransformGizmoBuilder;
	static C(Other: UObject | any): CombinedTransformGizmoBuilder;
}

declare class TransformProxy extends UObject { 
	bRotatePerObject: boolean;
	bSetPivotMode: boolean;
	SharedTransform: Transform;
	InitialSharedTransform: Transform;
	static Load(ResourceName: string): TransformProxy;
	static Find(Outer: UObject, ResourceName: string): TransformProxy;
	static GetDefaultObject(): TransformProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TransformProxy;
	static C(Other: UObject | any): TransformProxy;
}

declare type EToolContextCoordinateSystem = 'World' | 'Local' | 'EToolContextCoordinateSystem_MAX';
declare var EToolContextCoordinateSystem : { World:'World',Local:'Local',EToolContextCoordinateSystem_MAX:'EToolContextCoordinateSystem_MAX', };
declare class GizmoTransformChangeStateTarget extends UObject { 
	TransactionManager: ToolContextTransactionProvider;
	static Load(ResourceName: string): GizmoTransformChangeStateTarget;
	static Find(Outer: UObject, ResourceName: string): GizmoTransformChangeStateTarget;
	static GetDefaultObject(): GizmoTransformChangeStateTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoTransformChangeStateTarget;
	static C(Other: UObject | any): GizmoTransformChangeStateTarget;
}

declare class CombinedTransformGizmo extends InteractiveGizmo { 
	ActiveTarget: TransformProxy;
	bSnapToWorldGrid: boolean;
	bGridSizeIsExplicit: boolean;
	ExplicitGridSize: Vector;
	bRotationGridSizeIsExplicit: boolean;
	ExplicitRotationGridSize: Rotator;
	bSnapToWorldRotGrid: boolean;
	bUseContextCoordinateSystem: boolean;
	CurrentCoordinateSystem: EToolContextCoordinateSystem;
	ActiveComponents: PrimitiveComponent[];
	NonuniformScaleComponents: PrimitiveComponent[];
	ActiveGizmos: InteractiveGizmo[];
	CameraAxisSource: GizmoConstantFrameAxisSource;
	AxisXSource: GizmoComponentAxisSource;
	AxisYSource: GizmoComponentAxisSource;
	AxisZSource: GizmoComponentAxisSource;
	UnitAxisXSource: GizmoComponentAxisSource;
	UnitAxisYSource: GizmoComponentAxisSource;
	UnitAxisZSource: GizmoComponentAxisSource;
	StateTarget: GizmoTransformChangeStateTarget;
	static Load(ResourceName: string): CombinedTransformGizmo;
	static Find(Outer: UObject, ResourceName: string): CombinedTransformGizmo;
	static GetDefaultObject(): CombinedTransformGizmo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CombinedTransformGizmo;
	static C(Other: UObject | any): CombinedTransformGizmo;
}

declare class GizmoArrowComponent extends GizmoBaseComponent { 
	Direction: Vector;
	Gap: number;
	Length: number;
	Thickness: number;
	static Load(ResourceName: string): GizmoArrowComponent;
	static Find(Outer: UObject, ResourceName: string): GizmoArrowComponent;
	static GetDefaultObject(): GizmoArrowComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoArrowComponent;
	static C(Other: UObject | any): GizmoArrowComponent;
}

declare class GizmoBoxComponent extends GizmoBaseComponent { 
	Origin: Vector;
	Rotation: Quat;
	Dimensions: Vector;
	LineThickness: number;
	bRemoveHiddenLines: boolean;
	bEnableAxisFlip: boolean;
	static Load(ResourceName: string): GizmoBoxComponent;
	static Find(Outer: UObject, ResourceName: string): GizmoBoxComponent;
	static GetDefaultObject(): GizmoBoxComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoBoxComponent;
	static C(Other: UObject | any): GizmoBoxComponent;
}

declare class GizmoCircleComponent extends GizmoBaseComponent { 
	Normal: Vector;
	Radius: number;
	Thickness: number;
	NumSides: number;
	bViewAligned: boolean;
	bDrawFullCircle: boolean;
	bOnlyAllowFrontFacingHits: boolean;
	static Load(ResourceName: string): GizmoCircleComponent;
	static Find(Outer: UObject, ResourceName: string): GizmoCircleComponent;
	static GetDefaultObject(): GizmoCircleComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoCircleComponent;
	static C(Other: UObject | any): GizmoCircleComponent;
}

declare class GizmoElementCylinder extends GizmoElementBase { 
	Base: Vector;
	Direction: Vector;
	Height: number;
	Radius: number;
	NumSides: number;
	static Load(ResourceName: string): GizmoElementCylinder;
	static Find(Outer: UObject, ResourceName: string): GizmoElementCylinder;
	static GetDefaultObject(): GizmoElementCylinder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoElementCylinder;
	static C(Other: UObject | any): GizmoElementCylinder;
}

declare class GizmoElementCone extends GizmoElementBase { 
	Origin: Vector;
	Direction: Vector;
	Height: number;
	Radius: number;
	NumSides: number;
	static Load(ResourceName: string): GizmoElementCone;
	static Find(Outer: UObject, ResourceName: string): GizmoElementCone;
	static GetDefaultObject(): GizmoElementCone;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoElementCone;
	static C(Other: UObject | any): GizmoElementCone;
}

declare class GizmoElementBox extends GizmoElementBase { 
	Center: Vector;
	Dimensions: Vector;
	UpDirection: Vector;
	SideDirection: Vector;
	static Load(ResourceName: string): GizmoElementBox;
	static Find(Outer: UObject, ResourceName: string): GizmoElementBox;
	static GetDefaultObject(): GizmoElementBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoElementBox;
	static C(Other: UObject | any): GizmoElementBox;
}

declare type EGizmoElementArrowHeadType = 'Cone' | 'Cube' | 'EGizmoElementArrowHeadType_MAX';
declare var EGizmoElementArrowHeadType : { Cone:'Cone',Cube:'Cube',EGizmoElementArrowHeadType_MAX:'EGizmoElementArrowHeadType_MAX', };
declare class GizmoElementArrow extends GizmoElementBase { 
	CylinderElement: GizmoElementCylinder;
	ConeElement: GizmoElementCone;
	BoxElement: GizmoElementBox;
	Base: Vector;
	Direction: Vector;
	SideDirection: Vector;
	BodyLength: number;
	BodyRadius: number;
	HeadLength: number;
	HeadRadius: number;
	NumSides: number;
	HeadType: EGizmoElementArrowHeadType;
	static Load(ResourceName: string): GizmoElementArrow;
	static Find(Outer: UObject, ResourceName: string): GizmoElementArrow;
	static GetDefaultObject(): GizmoElementArrow;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoElementArrow;
	static C(Other: UObject | any): GizmoElementArrow;
}

declare class GizmoElementCircle extends GizmoElementCircleBase { 
	bDrawMesh: boolean;
	bDrawLine: boolean;
	bHitMesh: boolean;
	bHitLine: boolean;
	static Load(ResourceName: string): GizmoElementCircle;
	static Find(Outer: UObject, ResourceName: string): GizmoElementCircle;
	static GetDefaultObject(): GizmoElementCircle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoElementCircle;
	static C(Other: UObject | any): GizmoElementCircle;
}

declare class GizmoElementGroup extends GizmoElementLineBase { 
	bConstantScale: boolean;
	bHitOwner: boolean;
	Elements: GizmoElementBase[];
	static Load(ResourceName: string): GizmoElementGroup;
	static Find(Outer: UObject, ResourceName: string): GizmoElementGroup;
	static GetDefaultObject(): GizmoElementGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoElementGroup;
	static C(Other: UObject | any): GizmoElementGroup;
}

declare class GizmoElementHitTarget extends UObject { 
	GizmoElement: GizmoElementBase;
	GizmoViewContext: GizmoViewContext;
	GizmoTransformProxy: TransformProxy;
	static Load(ResourceName: string): GizmoElementHitTarget;
	static Find(Outer: UObject, ResourceName: string): GizmoElementHitTarget;
	static GetDefaultObject(): GizmoElementHitTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoElementHitTarget;
	static C(Other: UObject | any): GizmoElementHitTarget;
}

declare class GizmoElementHitMultiTarget extends UObject { 
	GizmoElement: GizmoElementBase;
	GizmoViewContext: GizmoViewContext;
	GizmoTransformProxy: TransformProxy;
	static Load(ResourceName: string): GizmoElementHitMultiTarget;
	static Find(Outer: UObject, ResourceName: string): GizmoElementHitMultiTarget;
	static GetDefaultObject(): GizmoElementHitMultiTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoElementHitMultiTarget;
	static C(Other: UObject | any): GizmoElementHitMultiTarget;
}

declare class GizmoElementRectangle extends GizmoElementLineBase { 
	Center: Vector;
	Width: number;
	Height: number;
	UpDirection: Vector;
	SideDirection: Vector;
	bDrawMesh: boolean;
	bDrawLine: boolean;
	bHitMesh: boolean;
	bHitLine: boolean;
	static Load(ResourceName: string): GizmoElementRectangle;
	static Find(Outer: UObject, ResourceName: string): GizmoElementRectangle;
	static GetDefaultObject(): GizmoElementRectangle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoElementRectangle;
	static C(Other: UObject | any): GizmoElementRectangle;
}

declare class GizmoElementTorus extends GizmoElementCircleBase { 
	InnerRadius: number;
	NumInnerSlices: number;
	bEndCaps: boolean;
	static Load(ResourceName: string): GizmoElementTorus;
	static Find(Outer: UObject, ResourceName: string): GizmoElementTorus;
	static GetDefaultObject(): GizmoElementTorus;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoElementTorus;
	static C(Other: UObject | any): GizmoElementTorus;
}

declare class GizmoClickMultiTarget extends Interface { 
	static Load(ResourceName: string): GizmoClickMultiTarget;
	static Find(Outer: UObject, ResourceName: string): GizmoClickMultiTarget;
	static GetDefaultObject(): GizmoClickMultiTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoClickMultiTarget;
	UpdateInteractingState(bInteracting: boolean,InPartIdentifier: number): void;
	UpdateHoverState(bHovering: boolean,InPartIdentifier: number): void;
	UpdateHittableState(bHittable: boolean,InPartIdentifier: number): void;
	static C(Other: UObject | any): GizmoClickMultiTarget;
}

declare class GizmoRenderTarget extends Interface { 
	static Load(ResourceName: string): GizmoRenderTarget;
	static Find(Outer: UObject, ResourceName: string): GizmoRenderTarget;
	static GetDefaultObject(): GizmoRenderTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoRenderTarget;
	static C(Other: UObject | any): GizmoRenderTarget;
}

declare class GizmoRenderMultiTarget extends Interface { 
	static Load(ResourceName: string): GizmoRenderMultiTarget;
	static Find(Outer: UObject, ResourceName: string): GizmoRenderMultiTarget;
	static GetDefaultObject(): GizmoRenderMultiTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoRenderMultiTarget;
	UpdateVisibilityState(bVisible: boolean,InPartIdentifier: number): void;
	static C(Other: UObject | any): GizmoRenderMultiTarget;
}

declare class GizmoVec2ParameterSource extends Interface { 
	static Load(ResourceName: string): GizmoVec2ParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoVec2ParameterSource;
	static GetDefaultObject(): GizmoVec2ParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoVec2ParameterSource;
	SetParameter(NewValue: Vector2D): void;
	GetParameter(): Vector2D;
	EndModify(): void;
	BeginModify(): void;
	static C(Other: UObject | any): GizmoVec2ParameterSource;
}

declare class GizmoLineHandleComponent extends GizmoBaseComponent { 
	Normal: Vector;
	HandleSize: number;
	Thickness: number;
	Direction: Vector;
	Length: number;
	bImageScale: boolean;
	static Load(ResourceName: string): GizmoLineHandleComponent;
	static Find(Outer: UObject, ResourceName: string): GizmoLineHandleComponent;
	static GetDefaultObject(): GizmoLineHandleComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoLineHandleComponent;
	static C(Other: UObject | any): GizmoLineHandleComponent;
}

declare class GizmoRectangleComponent extends GizmoBaseComponent { 
	DirectionX: Vector;
	DirectionY: Vector;
	bOrientYAccordingToCamera: boolean;
	OffsetX: number;
	OffsetY: number;
	LengthX: number;
	LengthY: number;
	Thickness: number;
	SegmentFlags: number;
	static Load(ResourceName: string): GizmoRectangleComponent;
	static Find(Outer: UObject, ResourceName: string): GizmoRectangleComponent;
	static GetDefaultObject(): GizmoRectangleComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoRectangleComponent;
	static C(Other: UObject | any): GizmoRectangleComponent;
}

declare class GizmoLambdaHitTarget extends UObject { 
	static Load(ResourceName: string): GizmoLambdaHitTarget;
	static Find(Outer: UObject, ResourceName: string): GizmoLambdaHitTarget;
	static GetDefaultObject(): GizmoLambdaHitTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoLambdaHitTarget;
	static C(Other: UObject | any): GizmoLambdaHitTarget;
}

declare class GizmoComponentHitTarget extends UObject { 
	Component: PrimitiveComponent;
	static Load(ResourceName: string): GizmoComponentHitTarget;
	static Find(Outer: UObject, ResourceName: string): GizmoComponentHitTarget;
	static GetDefaultObject(): GizmoComponentHitTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoComponentHitTarget;
	static C(Other: UObject | any): GizmoComponentHitTarget;
}

declare class IntervalGizmoActor extends GizmoActor { 
	UpIntervalComponent: GizmoLineHandleComponent;
	DownIntervalComponent: GizmoLineHandleComponent;
	ForwardIntervalComponent: GizmoLineHandleComponent;
	static GetDefaultObject(): IntervalGizmoActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IntervalGizmoActor;
	static C(Other: UObject | any): IntervalGizmoActor;
}

declare class IntervalGizmoBuilder extends InteractiveGizmoBuilder { 
	static Load(ResourceName: string): IntervalGizmoBuilder;
	static Find(Outer: UObject, ResourceName: string): IntervalGizmoBuilder;
	static GetDefaultObject(): IntervalGizmoBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IntervalGizmoBuilder;
	static C(Other: UObject | any): IntervalGizmoBuilder;
}

declare class IntervalGizmo extends InteractiveGizmo { 
	StateTarget: GizmoTransformChangeStateTarget;
	TransformProxy: TransformProxy;
	ActiveComponents: PrimitiveComponent[];
	ActiveGizmos: InteractiveGizmo[];
	AxisYSource: GizmoComponentAxisSource;
	AxisZSource: GizmoComponentAxisSource;
	static Load(ResourceName: string): IntervalGizmo;
	static Find(Outer: UObject, ResourceName: string): IntervalGizmo;
	static GetDefaultObject(): IntervalGizmo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IntervalGizmo;
	static C(Other: UObject | any): IntervalGizmo;
}

declare class GizmoAxisIntervalParameterSource extends GizmoBaseFloatParameterSource { 
	FloatParameterSource: GizmoFloatParameterSource;
	MinParameter: number;
	MaxParameter: number;
	static Load(ResourceName: string): GizmoAxisIntervalParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoAxisIntervalParameterSource;
	static GetDefaultObject(): GizmoAxisIntervalParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoAxisIntervalParameterSource;
	static C(Other: UObject | any): GizmoAxisIntervalParameterSource;
}

declare class GizmoLocalFloatParameterSource extends GizmoBaseFloatParameterSource { 
	Value: number;
	LastChange: GizmoFloatParameterChange;
	static Load(ResourceName: string): GizmoLocalFloatParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoLocalFloatParameterSource;
	static GetDefaultObject(): GizmoLocalFloatParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoLocalFloatParameterSource;
	static C(Other: UObject | any): GizmoLocalFloatParameterSource;
}

declare class PlanePositionGizmoBuilder extends InteractiveGizmoBuilder { 
	static Load(ResourceName: string): PlanePositionGizmoBuilder;
	static Find(Outer: UObject, ResourceName: string): PlanePositionGizmoBuilder;
	static GetDefaultObject(): PlanePositionGizmoBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlanePositionGizmoBuilder;
	static C(Other: UObject | any): PlanePositionGizmoBuilder;
}

declare class PlanePositionGizmo extends InteractiveGizmo { 
	AxisSource: GizmoAxisSource;
	ParameterSource: GizmoVec2ParameterSource;
	HitTarget: GizmoClickTarget;
	StateTarget: GizmoStateTarget;
	MouseBehavior: ClickDragInputBehavior;
	bEnableSignedAxis: boolean;
	bFlipX: boolean;
	bFlipY: boolean;
	bInInteraction: boolean;
	InteractionOrigin: Vector;
	InteractionNormal: Vector;
	InteractionAxisX: Vector;
	InteractionAxisY: Vector;
	InteractionStartPoint: Vector;
	InteractionCurPoint: Vector;
	InteractionStartParameter: Vector2D;
	InteractionCurParameter: Vector2D;
	ParameterSigns: Vector2D;
	static Load(ResourceName: string): PlanePositionGizmo;
	static Find(Outer: UObject, ResourceName: string): PlanePositionGizmo;
	static GetDefaultObject(): PlanePositionGizmo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlanePositionGizmo;
	static C(Other: UObject | any): PlanePositionGizmo;
}

declare class RepositionableTransformGizmoBuilder extends CombinedTransformGizmoBuilder { 
	static Load(ResourceName: string): RepositionableTransformGizmoBuilder;
	static Find(Outer: UObject, ResourceName: string): RepositionableTransformGizmoBuilder;
	static GetDefaultObject(): RepositionableTransformGizmoBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RepositionableTransformGizmoBuilder;
	static C(Other: UObject | any): RepositionableTransformGizmoBuilder;
}

declare class RepositionableTransformGizmo extends CombinedTransformGizmo { 
	RepositionStateTarget: GizmoTransformChangeStateTarget;
	static Load(ResourceName: string): RepositionableTransformGizmo;
	static Find(Outer: UObject, ResourceName: string): RepositionableTransformGizmo;
	static GetDefaultObject(): RepositionableTransformGizmo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RepositionableTransformGizmo;
	static C(Other: UObject | any): RepositionableTransformGizmo;
}

declare class ScalableSphereGizmoBuilder extends InteractiveGizmoBuilder { 
	static Load(ResourceName: string): ScalableSphereGizmoBuilder;
	static Find(Outer: UObject, ResourceName: string): ScalableSphereGizmoBuilder;
	static GetDefaultObject(): ScalableSphereGizmoBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScalableSphereGizmoBuilder;
	static C(Other: UObject | any): ScalableSphereGizmoBuilder;
}

declare class ScalableSphereGizmo extends InteractiveGizmo { 
	HitErrorThreshold: number;
	TransactionDescription: string;
	Radius: number;
	bIsHovering: boolean;
	bIsDragging: boolean;
	ActiveTarget: TransformProxy;
	ActiveAxis: Vector;
	DragStartWorldPosition: Vector;
	DragCurrentPositionProjected: Vector;
	InteractionStartParameter: number;
	static Load(ResourceName: string): ScalableSphereGizmo;
	static Find(Outer: UObject, ResourceName: string): ScalableSphereGizmo;
	static GetDefaultObject(): ScalableSphereGizmo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScalableSphereGizmo;
	static C(Other: UObject | any): ScalableSphereGizmo;
}

declare class ScalableSphereGizmoInputBehavior extends AnyButtonInputBehavior { 
	static Load(ResourceName: string): ScalableSphereGizmoInputBehavior;
	static Find(Outer: UObject, ResourceName: string): ScalableSphereGizmoInputBehavior;
	static GetDefaultObject(): ScalableSphereGizmoInputBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScalableSphereGizmoInputBehavior;
	static C(Other: UObject | any): ScalableSphereGizmoInputBehavior;
}

declare class GizmoNilStateTarget extends UObject { 
	static Load(ResourceName: string): GizmoNilStateTarget;
	static Find(Outer: UObject, ResourceName: string): GizmoNilStateTarget;
	static GetDefaultObject(): GizmoNilStateTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoNilStateTarget;
	static C(Other: UObject | any): GizmoNilStateTarget;
}

declare class GizmoLambdaStateTarget extends UObject { 
	static Load(ResourceName: string): GizmoLambdaStateTarget;
	static Find(Outer: UObject, ResourceName: string): GizmoLambdaStateTarget;
	static GetDefaultObject(): GizmoLambdaStateTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoLambdaStateTarget;
	static C(Other: UObject | any): GizmoLambdaStateTarget;
}

declare class GizmoObjectModifyStateTarget extends UObject { 
	TransactionManager: ToolContextTransactionProvider;
	static Load(ResourceName: string): GizmoObjectModifyStateTarget;
	static Find(Outer: UObject, ResourceName: string): GizmoObjectModifyStateTarget;
	static GetDefaultObject(): GizmoObjectModifyStateTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoObjectModifyStateTarget;
	static C(Other: UObject | any): GizmoObjectModifyStateTarget;
}

declare class CombinedTransformGizmoContextObject extends UObject { 
	static Load(ResourceName: string): CombinedTransformGizmoContextObject;
	static Find(Outer: UObject, ResourceName: string): CombinedTransformGizmoContextObject;
	static GetDefaultObject(): CombinedTransformGizmoContextObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CombinedTransformGizmoContextObject;
	static C(Other: UObject | any): CombinedTransformGizmoContextObject;
}

declare class GizmoBaseTransformSource extends UObject { 
	static Load(ResourceName: string): GizmoBaseTransformSource;
	static Find(Outer: UObject, ResourceName: string): GizmoBaseTransformSource;
	static GetDefaultObject(): GizmoBaseTransformSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoBaseTransformSource;
	static C(Other: UObject | any): GizmoBaseTransformSource;
}

declare class GizmoComponentWorldTransformSource extends GizmoBaseTransformSource { 
	Component: SceneComponent;
	bModifyComponentOnTransform: boolean;
	static Load(ResourceName: string): GizmoComponentWorldTransformSource;
	static Find(Outer: UObject, ResourceName: string): GizmoComponentWorldTransformSource;
	static GetDefaultObject(): GizmoComponentWorldTransformSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoComponentWorldTransformSource;
	static C(Other: UObject | any): GizmoComponentWorldTransformSource;
}

declare class GizmoScaledTransformSource extends GizmoBaseTransformSource { 
	ChildTransformSource: GizmoTransformSource;
	static Load(ResourceName: string): GizmoScaledTransformSource;
	static Find(Outer: UObject, ResourceName: string): GizmoScaledTransformSource;
	static GetDefaultObject(): GizmoScaledTransformSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoScaledTransformSource;
	static C(Other: UObject | any): GizmoScaledTransformSource;
}

declare class GizmoTransformProxyTransformSource extends GizmoBaseTransformSource { 
	Proxy: TransformProxy;
	static Load(ResourceName: string): GizmoTransformProxyTransformSource;
	static Find(Outer: UObject, ResourceName: string): GizmoTransformProxyTransformSource;
	static GetDefaultObject(): GizmoTransformProxyTransformSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoTransformProxyTransformSource;
	static C(Other: UObject | any): GizmoTransformProxyTransformSource;
}

declare class GizmoScaledAndUnscaledTransformSources extends GizmoBaseTransformSource { 
	ScaledTransformSource: GizmoTransformSource;
	UnscaledTransformSource: GizmoTransformSource;
	static Load(ResourceName: string): GizmoScaledAndUnscaledTransformSources;
	static Find(Outer: UObject, ResourceName: string): GizmoScaledAndUnscaledTransformSources;
	static GetDefaultObject(): GizmoScaledAndUnscaledTransformSources;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoScaledAndUnscaledTransformSources;
	static C(Other: UObject | any): GizmoScaledAndUnscaledTransformSources;
}

declare class InteractiveToolPropertySet extends UObject { 
	CachedPropertiesMap: Map<string, InteractiveToolPropertySet>;
	bIsPropertySetEnabled: boolean;
	static Load(ResourceName: string): InteractiveToolPropertySet;
	static Find(Outer: UObject, ResourceName: string): InteractiveToolPropertySet;
	static GetDefaultObject(): InteractiveToolPropertySet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveToolPropertySet;
	static C(Other: UObject | any): InteractiveToolPropertySet;
}

declare class BrushBaseProperties extends InteractiveToolPropertySet { 
	BrushSize: number;
	bSpecifyRadius: boolean;
	BrushRadius: number;
	BrushStrength: number;
	BrushFalloffAmount: number;
	bShowStrength: boolean;
	bShowFalloff: boolean;
	static Load(ResourceName: string): BrushBaseProperties;
	static Find(Outer: UObject, ResourceName: string): BrushBaseProperties;
	static GetDefaultObject(): BrushBaseProperties;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BrushBaseProperties;
	static C(Other: UObject | any): BrushBaseProperties;
}

declare class InteractiveTool extends UObject { 
	InputBehaviors: InputBehaviorSet;
	ToolPropertyObjects: UObject[];
	static Load(ResourceName: string): InteractiveTool;
	static Find(Outer: UObject, ResourceName: string): InteractiveTool;
	static GetDefaultObject(): InteractiveTool;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveTool;
	static C(Other: UObject | any): InteractiveTool;
}

declare class ToolTarget extends UObject { 
	static Load(ResourceName: string): ToolTarget;
	static Find(Outer: UObject, ResourceName: string): ToolTarget;
	static GetDefaultObject(): ToolTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolTarget;
	static C(Other: UObject | any): ToolTarget;
}

declare class SingleSelectionTool extends InteractiveTool { 
	Target: ToolTarget;
	static Load(ResourceName: string): SingleSelectionTool;
	static Find(Outer: UObject, ResourceName: string): SingleSelectionTool;
	static GetDefaultObject(): SingleSelectionTool;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SingleSelectionTool;
	static C(Other: UObject | any): SingleSelectionTool;
}

declare class MeshSurfacePointTool extends SingleSelectionTool { 
	TargetWorld: World;
	static Load(ResourceName: string): MeshSurfacePointTool;
	static Find(Outer: UObject, ResourceName: string): MeshSurfacePointTool;
	static GetDefaultObject(): MeshSurfacePointTool;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MeshSurfacePointTool;
	static C(Other: UObject | any): MeshSurfacePointTool;
}

declare class BrushStampData { 
	clone() : BrushStampData;
	static C(Other: UObject | any): BrushStampData;
}

declare class BaseBrushTool extends MeshSurfacePointTool { 
	BrushProperties: BrushBaseProperties;
	bInBrushStroke: boolean;
	WorldToLocalScale: number;
	LastBrushStamp: BrushStampData;
	PropertyClass: Class;
	BrushStampIndicator: BrushStampIndicator;
	static Load(ResourceName: string): BaseBrushTool;
	static Find(Outer: UObject, ResourceName: string): BaseBrushTool;
	static GetDefaultObject(): BaseBrushTool;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BaseBrushTool;
	static C(Other: UObject | any): BaseBrushTool;
}

declare class InteractiveToolBuilder extends UObject { 
	static Load(ResourceName: string): InteractiveToolBuilder;
	static Find(Outer: UObject, ResourceName: string): InteractiveToolBuilder;
	static GetDefaultObject(): InteractiveToolBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveToolBuilder;
	static C(Other: UObject | any): InteractiveToolBuilder;
}

declare class ClickDragToolBuilder extends InteractiveToolBuilder { 
	static Load(ResourceName: string): ClickDragToolBuilder;
	static Find(Outer: UObject, ResourceName: string): ClickDragToolBuilder;
	static GetDefaultObject(): ClickDragToolBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClickDragToolBuilder;
	static C(Other: UObject | any): ClickDragToolBuilder;
}

declare class ClickDragTool extends InteractiveTool { 
	static Load(ResourceName: string): ClickDragTool;
	static Find(Outer: UObject, ResourceName: string): ClickDragTool;
	static GetDefaultObject(): ClickDragTool;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClickDragTool;
	static C(Other: UObject | any): ClickDragTool;
}

declare class InteractiveToolWithToolTargetsBuilder extends InteractiveToolBuilder { 
	static Load(ResourceName: string): InteractiveToolWithToolTargetsBuilder;
	static Find(Outer: UObject, ResourceName: string): InteractiveToolWithToolTargetsBuilder;
	static GetDefaultObject(): InteractiveToolWithToolTargetsBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveToolWithToolTargetsBuilder;
	static C(Other: UObject | any): InteractiveToolWithToolTargetsBuilder;
}

declare class MeshSurfacePointToolBuilder extends InteractiveToolWithToolTargetsBuilder { 
	static Load(ResourceName: string): MeshSurfacePointToolBuilder;
	static Find(Outer: UObject, ResourceName: string): MeshSurfacePointToolBuilder;
	static GetDefaultObject(): MeshSurfacePointToolBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MeshSurfacePointToolBuilder;
	static C(Other: UObject | any): MeshSurfacePointToolBuilder;
}

declare class SingleClickToolBuilder extends InteractiveToolBuilder { 
	static Load(ResourceName: string): SingleClickToolBuilder;
	static Find(Outer: UObject, ResourceName: string): SingleClickToolBuilder;
	static GetDefaultObject(): SingleClickToolBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SingleClickToolBuilder;
	static C(Other: UObject | any): SingleClickToolBuilder;
}

declare class SingleClickTool extends InteractiveTool { 
	static Load(ResourceName: string): SingleClickTool;
	static Find(Outer: UObject, ResourceName: string): SingleClickTool;
	static GetDefaultObject(): SingleClickTool;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SingleClickTool;
	static C(Other: UObject | any): SingleClickTool;
}

declare class ContextObjectStore extends UObject { 
	ContextObjects: UObject[];
	static Load(ResourceName: string): ContextObjectStore;
	static Find(Outer: UObject, ResourceName: string): ContextObjectStore;
	static GetDefaultObject(): ContextObjectStore;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContextObjectStore;
	static C(Other: UObject | any): ContextObjectStore;
}

declare class InputBehaviorSource extends Interface { 
	static Load(ResourceName: string): InputBehaviorSource;
	static Find(Outer: UObject, ResourceName: string): InputBehaviorSource;
	static GetDefaultObject(): InputBehaviorSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputBehaviorSource;
	static C(Other: UObject | any): InputBehaviorSource;
}

declare class LocalInputBehaviorSource extends UObject { 
	static Load(ResourceName: string): LocalInputBehaviorSource;
	static Find(Outer: UObject, ResourceName: string): LocalInputBehaviorSource;
	static GetDefaultObject(): LocalInputBehaviorSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalInputBehaviorSource;
	static C(Other: UObject | any): LocalInputBehaviorSource;
}

declare class InputRouter extends UObject { 
	bAutoInvalidateOnHover: boolean;
	bAutoInvalidateOnCapture: boolean;
	ActiveInputBehaviors: InputBehaviorSet;
	static Load(ResourceName: string): InputRouter;
	static Find(Outer: UObject, ResourceName: string): InputRouter;
	static GetDefaultObject(): InputRouter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputRouter;
	static C(Other: UObject | any): InputRouter;
}

declare class InteractionMechanic extends UObject { 
	static Load(ResourceName: string): InteractionMechanic;
	static Find(Outer: UObject, ResourceName: string): InteractionMechanic;
	static GetDefaultObject(): InteractionMechanic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractionMechanic;
	static C(Other: UObject | any): InteractionMechanic;
}

declare class ActiveGizmo { 
	Gizmo: InteractiveGizmo;
	clone() : ActiveGizmo;
	static C(Other: UObject | any): ActiveGizmo;
}

declare class InteractiveGizmoManager extends UObject { 
	ActiveGizmos: ActiveGizmo[];
	GizmoBuilders: Map<string, InteractiveGizmoBuilder>;
	static Load(ResourceName: string): InteractiveGizmoManager;
	static Find(Outer: UObject, ResourceName: string): InteractiveGizmoManager;
	static GetDefaultObject(): InteractiveGizmoManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveGizmoManager;
	static C(Other: UObject | any): InteractiveGizmoManager;
}

declare class InteractiveToolManager extends UObject { 
	ActiveLeftTool: InteractiveTool;
	ActiveRightTool: InteractiveTool;
	ToolBuilders: Map<string, InteractiveToolBuilder>;
	static Load(ResourceName: string): InteractiveToolManager;
	static Find(Outer: UObject, ResourceName: string): InteractiveToolManager;
	static GetDefaultObject(): InteractiveToolManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveToolManager;
	static C(Other: UObject | any): InteractiveToolManager;
}

declare class ToolTargetFactory extends UObject { 
	static Load(ResourceName: string): ToolTargetFactory;
	static Find(Outer: UObject, ResourceName: string): ToolTargetFactory;
	static GetDefaultObject(): ToolTargetFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolTargetFactory;
	static C(Other: UObject | any): ToolTargetFactory;
}

declare class ToolTargetManager extends UObject { 
	Factories: ToolTargetFactory[];
	static Load(ResourceName: string): ToolTargetManager;
	static Find(Outer: UObject, ResourceName: string): ToolTargetManager;
	static GetDefaultObject(): ToolTargetManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolTargetManager;
	static C(Other: UObject | any): ToolTargetManager;
}

declare class InteractiveToolsContext extends UObject { 
	InputRouter: InputRouter;
	TargetManager: ToolTargetManager;
	ToolManager: InteractiveToolManager;
	GizmoManager: InteractiveGizmoManager;
	ContextObjectStore: ContextObjectStore;
	ToolManagerClass: Class;
	static Load(ResourceName: string): InteractiveToolsContext;
	static Find(Outer: UObject, ResourceName: string): InteractiveToolsContext;
	static GetDefaultObject(): InteractiveToolsContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveToolsContext;
	static C(Other: UObject | any): InteractiveToolsContext;
}

declare class MultiSelectionTool extends InteractiveTool { 
	Targets: ToolTarget[];
	static Load(ResourceName: string): MultiSelectionTool;
	static Find(Outer: UObject, ResourceName: string): MultiSelectionTool;
	static GetDefaultObject(): MultiSelectionTool;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MultiSelectionTool;
	static C(Other: UObject | any): MultiSelectionTool;
}

declare class SceneSnappingManager extends UObject { 
	static Load(ResourceName: string): SceneSnappingManager;
	static Find(Outer: UObject, ResourceName: string): SceneSnappingManager;
	static GetDefaultObject(): SceneSnappingManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SceneSnappingManager;
	static C(Other: UObject | any): SceneSnappingManager;
}

declare class SelectionSet extends UObject { 
	static Load(ResourceName: string): SelectionSet;
	static Find(Outer: UObject, ResourceName: string): SelectionSet;
	static GetDefaultObject(): SelectionSet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SelectionSet;
	static C(Other: UObject | any): SelectionSet;
}

declare class MeshSelectionSet extends SelectionSet { 
	Vertices: number[];
	Edges: number[];
	Faces: number[];
	Groups: number[];
	static Load(ResourceName: string): MeshSelectionSet;
	static Find(Outer: UObject, ResourceName: string): MeshSelectionSet;
	static GetDefaultObject(): MeshSelectionSet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MeshSelectionSet;
	static C(Other: UObject | any): MeshSelectionSet;
}

declare class PrimitiveComponentToolTarget extends ToolTarget { 
	static Load(ResourceName: string): PrimitiveComponentToolTarget;
	static Find(Outer: UObject, ResourceName: string): PrimitiveComponentToolTarget;
	static GetDefaultObject(): PrimitiveComponentToolTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PrimitiveComponentToolTarget;
	static C(Other: UObject | any): PrimitiveComponentToolTarget;
}

declare class PrimitiveComponentToolTargetFactory extends ToolTargetFactory { 
	static Load(ResourceName: string): PrimitiveComponentToolTargetFactory;
	static Find(Outer: UObject, ResourceName: string): PrimitiveComponentToolTargetFactory;
	static GetDefaultObject(): PrimitiveComponentToolTargetFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PrimitiveComponentToolTargetFactory;
	static C(Other: UObject | any): PrimitiveComponentToolTargetFactory;
}

declare class TypedElementHandleLibrary extends UObject { 
	static Load(ResourceName: string): TypedElementHandleLibrary;
	static Find(Outer: UObject, ResourceName: string): TypedElementHandleLibrary;
	static GetDefaultObject(): TypedElementHandleLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementHandleLibrary;
	static Release(ElementHandle?: ScriptTypedElementHandle): {ElementHandle: ScriptTypedElementHandle};
	static NotEqual(LHS: ScriptTypedElementHandle,RHS: ScriptTypedElementHandle): boolean;
	static IsSet(ElementHandle: ScriptTypedElementHandle): boolean;
	static Equal(LHS: ScriptTypedElementHandle,RHS: ScriptTypedElementHandle): boolean;
	static C(Other: UObject | any): TypedElementHandleLibrary;
}

declare class ScriptTypedElementListProxy { 
	clone() : ScriptTypedElementListProxy;
	static C(Other: UObject | any): ScriptTypedElementListProxy;
}

declare class TypedElementRegistry extends UObject { 
	static Load(ResourceName: string): TypedElementRegistry;
	static Find(Outer: UObject, ResourceName: string): TypedElementRegistry;
	static GetDefaultObject(): TypedElementRegistry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementRegistry;
	static GetInstance(): TypedElementRegistry;
	GetElementInterface(InElementHandle: ScriptTypedElementHandle,InBaseInterfaceType: UnrealEngineClass): UObject;
	static C(Other: UObject | any): TypedElementRegistry;
}

declare class TypedElementListLibrary extends UObject { 
	static Load(ResourceName: string): TypedElementListLibrary;
	static Find(Outer: UObject, ResourceName: string): TypedElementListLibrary;
	static GetDefaultObject(): TypedElementListLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementListLibrary;
	static Shrink(ElementList: ScriptTypedElementListProxy): void;
	static Reset(ElementList: ScriptTypedElementListProxy): void;
	static Reserve(ElementList: ScriptTypedElementListProxy,Size: number): void;
	static Remove(ElementList: ScriptTypedElementListProxy,ElementHandle: ScriptTypedElementHandle): boolean;
	static Num(ElementList: ScriptTypedElementListProxy): number;
	static IsValidIndex(ElementList: ScriptTypedElementListProxy,Index: number): boolean;
	static HasElementsOfType(ElementList: ScriptTypedElementListProxy,ElementTypeName: string): boolean;
	static HasElements(ElementList: ScriptTypedElementListProxy,BaseInterfaceType: UnrealEngineClass): boolean;
	static GetElementInterface(ElementList: ScriptTypedElementListProxy,ElementHandle: ScriptTypedElementHandle,BaseInterfaceType: UnrealEngineClass): UObject;
	static GetElementHandles(ElementList: ScriptTypedElementListProxy,BaseInterfaceType: UnrealEngineClass): ScriptTypedElementHandle[];
	static GetElementHandleAt(ElementList: ScriptTypedElementListProxy,Index: number): ScriptTypedElementHandle;
	static Empty(ElementList: ScriptTypedElementListProxy,Slack: number): void;
	static CreateScriptElementList(Registry: TypedElementRegistry): ScriptTypedElementListProxy;
	static CountElementsOfType(ElementList: ScriptTypedElementListProxy,ElementTypeName: string): number;
	static CountElements(ElementList: ScriptTypedElementListProxy,BaseInterfaceType: UnrealEngineClass): number;
	static Contains(ElementList: ScriptTypedElementListProxy,ElementHandle: ScriptTypedElementHandle): boolean;
	static Clone(ElementList: ScriptTypedElementListProxy): ScriptTypedElementListProxy;
	static AppendList(ElementList: ScriptTypedElementListProxy,OtherElementList: ScriptTypedElementListProxy): void;
	static Append(ElementList: ScriptTypedElementListProxy,ElementHandles: ScriptTypedElementHandle[]): void;
	static Add(ElementList: ScriptTypedElementListProxy,ElementHandle: ScriptTypedElementHandle): boolean;
	static C(Other: UObject | any): TypedElementListLibrary;
}

declare class TypedElementCounterInterface extends Interface { 
	static Load(ResourceName: string): TypedElementCounterInterface;
	static Find(Outer: UObject, ResourceName: string): TypedElementCounterInterface;
	static GetDefaultObject(): TypedElementCounterInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementCounterInterface;
	static C(Other: UObject | any): TypedElementCounterInterface;
}

declare class TestTypedElementInterfaceA extends Interface { 
	static Load(ResourceName: string): TestTypedElementInterfaceA;
	static Find(Outer: UObject, ResourceName: string): TestTypedElementInterfaceA;
	static GetDefaultObject(): TestTypedElementInterfaceA;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestTypedElementInterfaceA;
	SetDisplayName(InElementHandle: ScriptTypedElementHandle,InNewName: string,bNotify: boolean): boolean;
	GetDisplayName(InElementHandle: ScriptTypedElementHandle): string;
	static C(Other: UObject | any): TestTypedElementInterfaceA;
}

declare class TestTypedElementInterfaceB extends Interface { 
	static Load(ResourceName: string): TestTypedElementInterfaceB;
	static Find(Outer: UObject, ResourceName: string): TestTypedElementInterfaceB;
	static GetDefaultObject(): TestTypedElementInterfaceB;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestTypedElementInterfaceB;
	MarkAsTested(InElementHandle: ScriptTypedElementHandle): boolean;
	static C(Other: UObject | any): TestTypedElementInterfaceB;
}

declare class TestTypedElementInterfaceC extends Interface { 
	static Load(ResourceName: string): TestTypedElementInterfaceC;
	static Find(Outer: UObject, ResourceName: string): TestTypedElementInterfaceC;
	static GetDefaultObject(): TestTypedElementInterfaceC;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestTypedElementInterfaceC;
	GetIsTested(InElementHandle: ScriptTypedElementHandle): boolean;
	static C(Other: UObject | any): TestTypedElementInterfaceC;
}

declare class TestTypedElementInterfaceA_ImplTyped extends UObject { 
	static Load(ResourceName: string): TestTypedElementInterfaceA_ImplTyped;
	static Find(Outer: UObject, ResourceName: string): TestTypedElementInterfaceA_ImplTyped;
	static GetDefaultObject(): TestTypedElementInterfaceA_ImplTyped;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestTypedElementInterfaceA_ImplTyped;
	static C(Other: UObject | any): TestTypedElementInterfaceA_ImplTyped;
}

declare class TestTypedElementInterfaceA_ImplUntyped extends UObject { 
	static Load(ResourceName: string): TestTypedElementInterfaceA_ImplUntyped;
	static Find(Outer: UObject, ResourceName: string): TestTypedElementInterfaceA_ImplUntyped;
	static GetDefaultObject(): TestTypedElementInterfaceA_ImplUntyped;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestTypedElementInterfaceA_ImplUntyped;
	static C(Other: UObject | any): TestTypedElementInterfaceA_ImplUntyped;
}

declare class TestTypedElementInterfaceBAndC_Typed extends UObject { 
	static Load(ResourceName: string): TestTypedElementInterfaceBAndC_Typed;
	static Find(Outer: UObject, ResourceName: string): TestTypedElementInterfaceBAndC_Typed;
	static GetDefaultObject(): TestTypedElementInterfaceBAndC_Typed;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestTypedElementInterfaceBAndC_Typed;
	static C(Other: UObject | any): TestTypedElementInterfaceBAndC_Typed;
}

declare type ETypedElementChildInclusionMethod = 'None' | 'Immediate' | 'Recursive' | 'ETypedElementChildInclusionMethod_MAX';
declare var ETypedElementChildInclusionMethod : { None:'None',Immediate:'Immediate',Recursive:'Recursive',ETypedElementChildInclusionMethod_MAX:'ETypedElementChildInclusionMethod_MAX', };
declare class TypedElementSelectionOptions { 
	bAllowHidden: boolean;
	bAllowGroups: boolean;
	bAllowLegacyNotifications: boolean;
	bWarnIfLocked: boolean;
	ChildElementInclusionMethod: ETypedElementChildInclusionMethod;
	clone() : TypedElementSelectionOptions;
	static C(Other: UObject | any): TypedElementSelectionOptions;
}

declare class TypedElementSelectionSetState { 
	CreatedFromSelectionSet: TypedElementSelectionSet;
	clone() : TypedElementSelectionSetState;
	static C(Other: UObject | any): TypedElementSelectionSetState;
}

declare class TypedElementIsSelectedOptions { 
	bAllowIndirect: boolean;
	clone() : TypedElementIsSelectedOptions;
	static C(Other: UObject | any): TypedElementIsSelectedOptions;
}

declare type ETypedElementSelectionMethod = 'Primary' | 'Secondary' | 'ETypedElementSelectionMethod_MAX';
declare var ETypedElementSelectionMethod : { Primary:'Primary',Secondary:'Secondary',ETypedElementSelectionMethod_MAX:'ETypedElementSelectionMethod_MAX', };
declare class TypedElementSelectionSet extends UObject { 
	OnPreSelectionChange: UnrealEngineMulticastDelegate<(SelectionSet: TypedElementSelectionSet) => void>;
	OnSelectionChange: UnrealEngineMulticastDelegate<(SelectionSet: TypedElementSelectionSet) => void>;
	static Load(ResourceName: string): TypedElementSelectionSet;
	static Find(Outer: UObject, ResourceName: string): TypedElementSelectionSet;
	static GetDefaultObject(): TypedElementSelectionSet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementSelectionSet;
	SetSelection(InElementHandles: ScriptTypedElementHandle[],InSelectionOptions: TypedElementSelectionOptions): boolean;
	SelectElements(InElementHandles: ScriptTypedElementHandle[],InSelectionOptions: TypedElementSelectionOptions): boolean;
	SelectElement(InElementHandle: ScriptTypedElementHandle,InSelectionOptions: TypedElementSelectionOptions): boolean;
	RestoreSelectionState(InSelectionState: TypedElementSelectionSetState): void;
	K2_GetSelectedElementHandles(InBaseInterfaceType: UnrealEngineClass): ScriptTypedElementHandle[];
	IsElementSelected(InElementHandle: ScriptTypedElementHandle,InSelectionOptions: TypedElementIsSelectedOptions): boolean;
	HasSelectedObjects(InRequiredClass: UnrealEngineClass): boolean;
	HasSelectedElements(InBaseInterfaceType: UnrealEngineClass): boolean;
	GetTopSelectedObject(InRequiredClass: UnrealEngineClass): UObject;
	GetSelectionElement(InElementHandle: ScriptTypedElementHandle,InSelectionMethod: ETypedElementSelectionMethod): ScriptTypedElementHandle;
	GetSelectedObjects(InRequiredClass: UnrealEngineClass): UObject[];
	GetNumSelectedElements(): number;
	GetCurrentSelectionState(): TypedElementSelectionSetState;
	GetBottomSelectedObject(InRequiredClass: UnrealEngineClass): UObject;
	DeselectElements(InElementHandles: ScriptTypedElementHandle[],InSelectionOptions: TypedElementSelectionOptions): boolean;
	DeselectElement(InElementHandle: ScriptTypedElementHandle,InSelectionOptions: TypedElementSelectionOptions): boolean;
	CountSelectedObjects(InRequiredClass: UnrealEngineClass): number;
	CountSelectedElements(InBaseInterfaceType: UnrealEngineClass): number;
	ClearSelection(InSelectionOptions: TypedElementSelectionOptions): boolean;
	CanSelectElement(InElementHandle: ScriptTypedElementHandle,InSelectionOptions: TypedElementSelectionOptions): boolean;
	CanDeselectElement(InElementHandle: ScriptTypedElementHandle,InSelectionOptions: TypedElementSelectionOptions): boolean;
	AllowSelectionModifiers(InElementHandle: ScriptTypedElementHandle): boolean;
	static C(Other: UObject | any): TypedElementSelectionSet;
}

declare class TypedElementSelectionNormalizationOptions { 
	bExpandGroups: boolean;
	bFollowAttachment: boolean;
	clone() : TypedElementSelectionNormalizationOptions;
	static C(Other: UObject | any): TypedElementSelectionNormalizationOptions;
}

declare class TypedElementSelectionSetLibrary extends UObject { 
	static Load(ResourceName: string): TypedElementSelectionSetLibrary;
	static Find(Outer: UObject, ResourceName: string): TypedElementSelectionSetLibrary;
	static GetDefaultObject(): TypedElementSelectionSetLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementSelectionSetLibrary;
	static SetSelectionFromList(SelectionSet: TypedElementSelectionSet,ElementList: ScriptTypedElementListProxy,SelectionOptions: TypedElementSelectionOptions): boolean;
	static SelectElementsFromList(SelectionSet: TypedElementSelectionSet,ElementList: ScriptTypedElementListProxy,SelectionOptions: TypedElementSelectionOptions): boolean;
	static GetNormalizedSelection(SelectionSet: TypedElementSelectionSet,NormalizationOptions: TypedElementSelectionNormalizationOptions): ScriptTypedElementListProxy;
	static GetNormalizedElementList(SelectionSet: TypedElementSelectionSet,ElementList: ScriptTypedElementListProxy,NormalizationOptions: TypedElementSelectionNormalizationOptions): ScriptTypedElementListProxy;
	static DeselectElementsFromList(SelectionSet: TypedElementSelectionSet,ElementList: ScriptTypedElementListProxy,SelectionOptions: TypedElementSelectionOptions): boolean;
	static C(Other: UObject | any): TypedElementSelectionSetLibrary;
}

declare class TypedElementAssetDataInterface extends Interface { 
	static Load(ResourceName: string): TypedElementAssetDataInterface;
	static Find(Outer: UObject, ResourceName: string): TypedElementAssetDataInterface;
	static GetDefaultObject(): TypedElementAssetDataInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementAssetDataInterface;
	GetAssetData(InElementHandle: ScriptTypedElementHandle): AssetData;
	GetAllReferencedAssetDatas(InElementHandle: ScriptTypedElementHandle): AssetData[];
	static C(Other: UObject | any): TypedElementAssetDataInterface;
}

declare class TypedElementHierarchyInterface extends Interface { 
	static Load(ResourceName: string): TypedElementHierarchyInterface;
	static Find(Outer: UObject, ResourceName: string): TypedElementHierarchyInterface;
	static GetDefaultObject(): TypedElementHierarchyInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementHierarchyInterface;
	GetParentElement(InElementHandle: ScriptTypedElementHandle,bAllowCreate: boolean): ScriptTypedElementHandle;
	GetChildElements(InElementHandle: ScriptTypedElementHandle,OutElementHandles?: ScriptTypedElementHandle[],bAllowCreate?: boolean): {OutElementHandles: ScriptTypedElementHandle[]};
	static C(Other: UObject | any): TypedElementHierarchyInterface;
}

declare class TypedElementObjectInterface extends Interface { 
	static Load(ResourceName: string): TypedElementObjectInterface;
	static Find(Outer: UObject, ResourceName: string): TypedElementObjectInterface;
	static GetDefaultObject(): TypedElementObjectInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementObjectInterface;
	GetObjectClass(InElementHandle: ScriptTypedElementHandle): UnrealEngineClass;
	GetObject(InElementHandle: ScriptTypedElementHandle): UObject;
	static C(Other: UObject | any): TypedElementObjectInterface;
}

declare class TypedElementSelectionInterface extends Interface { 
	static Load(ResourceName: string): TypedElementSelectionInterface;
	static Find(Outer: UObject, ResourceName: string): TypedElementSelectionInterface;
	static GetDefaultObject(): TypedElementSelectionInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementSelectionInterface;
	SelectElement(InElementHandle: ScriptTypedElementHandle,InSelectionSet: ScriptTypedElementListProxy,InSelectionOptions: TypedElementSelectionOptions): boolean;
	IsElementSelected(InElementHandle: ScriptTypedElementHandle,InSelectionSet: ScriptTypedElementListProxy,InSelectionOptions: TypedElementIsSelectedOptions): boolean;
	GetSelectionElement(InElementHandle: ScriptTypedElementHandle,InCurrentSelection: ScriptTypedElementListProxy,InSelectionMethod: ETypedElementSelectionMethod): ScriptTypedElementHandle;
	DeselectElement(InElementHandle: ScriptTypedElementHandle,InSelectionSet: ScriptTypedElementListProxy,InSelectionOptions: TypedElementSelectionOptions): boolean;
	CanSelectElement(InElementHandle: ScriptTypedElementHandle,InSelectionOptions: TypedElementSelectionOptions): boolean;
	CanDeselectElement(InElementHandle: ScriptTypedElementHandle,InSelectionOptions: TypedElementSelectionOptions): boolean;
	AllowSelectionModifiers(InElementHandle: ScriptTypedElementHandle,InSelectionSet: ScriptTypedElementListProxy): boolean;
	static C(Other: UObject | any): TypedElementSelectionInterface;
}

declare class AssetEditorContextInterface extends Interface { 
	static Load(ResourceName: string): AssetEditorContextInterface;
	static Find(Outer: UObject, ResourceName: string): AssetEditorContextInterface;
	static GetDefaultObject(): AssetEditorContextInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetEditorContextInterface;
	static C(Other: UObject | any): AssetEditorContextInterface;
}

declare class AssetEditorUISubsystem extends EditorSubsystem { 
	static Load(ResourceName: string): AssetEditorUISubsystem;
	static Find(Outer: UObject, ResourceName: string): AssetEditorUISubsystem;
	static GetDefaultObject(): AssetEditorUISubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetEditorUISubsystem;
	static C(Other: UObject | any): AssetEditorUISubsystem;
}

declare class AssetFactoryInterface extends Interface { 
	static Load(ResourceName: string): AssetFactoryInterface;
	static Find(Outer: UObject, ResourceName: string): AssetFactoryInterface;
	static GetDefaultObject(): AssetFactoryInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetFactoryInterface;
	static C(Other: UObject | any): AssetFactoryInterface;
}

declare class EditorElementSubsystem extends EditorSubsystem { 
	static Load(ResourceName: string): EditorElementSubsystem;
	static Find(Outer: UObject, ResourceName: string): EditorElementSubsystem;
	static GetDefaultObject(): EditorElementSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorElementSubsystem;
	static C(Other: UObject | any): EditorElementSubsystem;
}

declare class PlacementSubsystem extends EditorSubsystem { 
	AssetFactories: AssetFactoryInterface[];
	static Load(ResourceName: string): PlacementSubsystem;
	static Find(Outer: UObject, ResourceName: string): PlacementSubsystem;
	static GetDefaultObject(): PlacementSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlacementSubsystem;
	static C(Other: UObject | any): PlacementSubsystem;
}

declare class TypedElementDetailsInterface extends Interface { 
	static Load(ResourceName: string): TypedElementDetailsInterface;
	static Find(Outer: UObject, ResourceName: string): TypedElementDetailsInterface;
	static GetDefaultObject(): TypedElementDetailsInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementDetailsInterface;
	static C(Other: UObject | any): TypedElementDetailsInterface;
}

declare class TypedElementViewportInteraction extends UObject { 
	static Load(ResourceName: string): TypedElementViewportInteraction;
	static Find(Outer: UObject, ResourceName: string): TypedElementViewportInteraction;
	static GetDefaultObject(): TypedElementViewportInteraction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementViewportInteraction;
	static C(Other: UObject | any): TypedElementViewportInteraction;
}

declare class ChaosPhysicalMaterial extends UObject { 
	Friction: number;
	StaticFriction: number;
	Restitution: number;
	LinearEtherDrag: number;
	AngularEtherDrag: number;
	SleepingLinearVelocityThreshold: number;
	SleepingAngularVelocityThreshold: number;
	static Load(ResourceName: string): ChaosPhysicalMaterial;
	static Find(Outer: UObject, ResourceName: string): ChaosPhysicalMaterial;
	static GetDefaultObject(): ChaosPhysicalMaterial;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosPhysicalMaterial;
	static C(Other: UObject | any): ChaosPhysicalMaterial;
}

declare type EClusterUnionMethod = 'PointImplicit' | 'DelaunayTriangulation' | 'MinimalSpanningSubsetDelaunayTriangulation' | 'PointImplicitAugmentedWithMinimalDelaunay' | 'BoundsOverlapFilteredDelaunayTriangulation' | 'None' | 'EClusterUnionMethod_MAX';
declare var EClusterUnionMethod : { PointImplicit:'PointImplicit',DelaunayTriangulation:'DelaunayTriangulation',MinimalSpanningSubsetDelaunayTriangulation:'MinimalSpanningSubsetDelaunayTriangulation',PointImplicitAugmentedWithMinimalDelaunay:'PointImplicitAugmentedWithMinimalDelaunay',BoundsOverlapFilteredDelaunayTriangulation:'BoundsOverlapFilteredDelaunayTriangulation',None:'None',EClusterUnionMethod_MAX:'EClusterUnionMethod_MAX', };
declare class SolverCollisionFilterSettings { 
	FilterEnabled: boolean;
	MinMass: number;
	MinSpeed: number;
	MinImpulse: number;
	clone() : SolverCollisionFilterSettings;
	static C(Other: UObject | any): SolverCollisionFilterSettings;
}

declare class SolverBreakingFilterSettings { 
	FilterEnabled: boolean;
	MinMass: number;
	MinSpeed: number;
	MinVolume: number;
	clone() : SolverBreakingFilterSettings;
	static C(Other: UObject | any): SolverBreakingFilterSettings;
}

declare class SolverTrailingFilterSettings { 
	FilterEnabled: boolean;
	MinMass: number;
	MinSpeed: number;
	MinVolume: number;
	clone() : SolverTrailingFilterSettings;
	static C(Other: UObject | any): SolverTrailingFilterSettings;
}

declare class ChaosSolverConfiguration { 
	PositionIterations: number;
	VelocityIterations: number;
	ProjectionIterations: number;
	CollisionMarginFraction: number;
	CollisionMarginMax: number;
	CollisionCullDistance: number;
	CollisionMaxPushOutVelocity: number;
	ClusterConnectionFactor: number;
	ClusterUnionConnectionType: EClusterUnionMethod;
	bGenerateCollisionData: boolean;
	CollisionFilterSettings: SolverCollisionFilterSettings;
	bGenerateBreakData: boolean;
	BreakingFilterSettings: SolverBreakingFilterSettings;
	bGenerateTrailingData: boolean;
	TrailingFilterSettings: SolverTrailingFilterSettings;
	Iterations: number;
	PushOutIterations: number;
	bGenerateContactGraph: boolean;
	clone() : ChaosSolverConfiguration;
	static C(Other: UObject | any): ChaosSolverConfiguration;
}

declare class PhysicsSettingsCore extends DeveloperSettings { 
	DefaultGravityZ: number;
	DefaultTerminalVelocity: number;
	DefaultFluidFriction: number;
	SimulateScratchMemorySize: number;
	RagdollAggregateThreshold: number;
	TriangleMeshTriangleMinAreaThreshold: number;
	bEnableShapeSharing: boolean;
	bEnablePCM: boolean;
	bEnableStabilization: boolean;
	bWarnMissingLocks: boolean;
	bEnable2DPhysics: boolean;
	bDefaultHasComplexCollision: boolean;
	BounceThresholdVelocity: number;
	FrictionCombineMode: EFrictionCombineMode;
	RestitutionCombineMode: EFrictionCombineMode;
	MaxAngularVelocity: number;
	MaxDepenetrationVelocity: number;
	ContactOffsetMultiplier: number;
	MinContactOffset: number;
	MaxContactOffset: number;
	bSimulateSkeletalMeshOnDedicatedServer: boolean;
	DefaultShapeComplexity: ECollisionTraceFlag;
	SolverOptions: ChaosSolverConfiguration;
	static Load(ResourceName: string): PhysicsSettingsCore;
	static Find(Outer: UObject, ResourceName: string): PhysicsSettingsCore;
	static GetDefaultObject(): PhysicsSettingsCore;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsSettingsCore;
	static C(Other: UObject | any): PhysicsSettingsCore;
}

declare type EMeshTrackerVertexColorMode = 'None' | 'Confidence' | 'Block' | 'EMeshTrackerVertexColorMode_MAX';
declare var EMeshTrackerVertexColorMode : { None:'None',Confidence:'Confidence',Block:'Block',EMeshTrackerVertexColorMode_MAX:'EMeshTrackerVertexColorMode_MAX', };
declare class MockDataMeshTrackerComponent extends SceneComponent { 
	OnMeshTrackerUpdated: UnrealEngineMulticastDelegate<(Index: number, Vertices: Vector[], Triangles: number[], Normals: Vector[], Confidence: number[]) => void>;
	ScanWorld: boolean;
	RequestNormals: boolean;
	RequestVertexConfidence: boolean;
	VertexColorMode: EMeshTrackerVertexColorMode;
	BlockVertexColors: Color[];
	VertexColorFromConfidenceZero: LinearColor;
	VertexColorFromConfidenceOne: LinearColor;
	UpdateInterval: number;
	MRMesh: MRMeshComponent;
	static Load(ResourceName: string): MockDataMeshTrackerComponent;
	static Find(Outer: UObject, ResourceName: string): MockDataMeshTrackerComponent;
	static GetDefaultObject(): MockDataMeshTrackerComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MockDataMeshTrackerComponent;
	DisconnectMRMesh(InMRMeshPtr: MRMeshComponent): void;
	ConnectMRMesh(InMRMeshPtr: MRMeshComponent): void;
	static C(Other: UObject | any): MockDataMeshTrackerComponent;
}

declare class MeshReconstructorBase extends UObject { 
	static Load(ResourceName: string): MeshReconstructorBase;
	static Find(Outer: UObject, ResourceName: string): MeshReconstructorBase;
	static GetDefaultObject(): MeshReconstructorBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MeshReconstructorBase;
	StopReconstruction(): void;
	StartReconstruction(): void;
	PauseReconstruction(): void;
	IsReconstructionStarted(): boolean;
	IsReconstructionPaused(): boolean;
	DisconnectMRMesh(): void;
	ConnectMRMesh(Mesh: MRMeshComponent): void;
	static C(Other: UObject | any): MeshReconstructorBase;
}

declare class ARComponent extends SceneComponent { 
	NativeID: Guid;
	bUseDefaultReplication: boolean;
	DefaultMeshMaterial: MaterialInterface;
	DefaultWireframeMeshMaterial: MaterialInterface;
	MRMeshComponent: MRMeshComponent;
	MyTrackedGeometry: ARTrackedGeometry;
	static Load(ResourceName: string): ARComponent;
	static Find(Outer: UObject, ResourceName: string): ARComponent;
	static GetDefaultObject(): ARComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARComponent;
	UpdateVisualization(): void;
	SetNativeID(NativeID: Guid): void;
	ReceiveRemove(): void;
	OnRep_Payload(): void;
	GetMRMesh(): MRMeshComponent;
	static C(Other: UObject | any): ARComponent;
}

declare class ARActor extends Actor { 
	static GetDefaultObject(): ARActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARActor;
	AddARComponent(InComponentClass: UnrealEngineClass,NativeID: Guid): ARComponent;
	static C(Other: UObject | any): ARActor;
}

declare type EARCaptureType = 'Camera' | 'QRCode' | 'SpatialMapping' | 'SceneUnderstanding' | 'HandMesh' | 'EARCaptureType_MAX';
declare var EARCaptureType : { Camera:'Camera',QRCode:'QRCode',SpatialMapping:'SpatialMapping',SceneUnderstanding:'SceneUnderstanding',HandMesh:'HandMesh',EARCaptureType_MAX:'EARCaptureType_MAX', };
declare type EARWorldAlignment = 'Gravity' | 'GravityAndHeading' | 'Camera' | 'EARWorldAlignment_MAX';
declare var EARWorldAlignment : { Gravity:'Gravity',GravityAndHeading:'GravityAndHeading',Camera:'Camera',EARWorldAlignment_MAX:'EARWorldAlignment_MAX', };
declare type EARSessionType = 'None' | 'Orientation' | 'World' | 'Face' | 'Image' | 'ObjectScanning' | 'PoseTracking' | 'GeoTracking' | 'EARSessionType_MAX';
declare var EARSessionType : { None:'None',Orientation:'Orientation',World:'World',Face:'Face',Image:'Image',ObjectScanning:'ObjectScanning',PoseTracking:'PoseTracking',GeoTracking:'GeoTracking',EARSessionType_MAX:'EARSessionType_MAX', };
declare type EARPlaneDetectionMode = 'None' | 'HorizontalPlaneDetection' | 'VerticalPlaneDetection' | 'EARPlaneDetectionMode_MAX';
declare var EARPlaneDetectionMode : { None:'None',HorizontalPlaneDetection:'HorizontalPlaneDetection',VerticalPlaneDetection:'VerticalPlaneDetection',EARPlaneDetectionMode_MAX:'EARPlaneDetectionMode_MAX', };
declare type EARLightEstimationMode = 'None' | 'AmbientLightEstimate' | 'DirectionalLightEstimate' | 'EARLightEstimationMode_MAX';
declare var EARLightEstimationMode : { None:'None',AmbientLightEstimate:'AmbientLightEstimate',DirectionalLightEstimate:'DirectionalLightEstimate',EARLightEstimationMode_MAX:'EARLightEstimationMode_MAX', };
declare type EARFrameSyncMode = 'SyncTickWithCameraImage' | 'SyncTickWithoutCameraImage' | 'EARFrameSyncMode_MAX';
declare var EARFrameSyncMode : { SyncTickWithCameraImage:'SyncTickWithCameraImage',SyncTickWithoutCameraImage:'SyncTickWithoutCameraImage',EARFrameSyncMode_MAX:'EARFrameSyncMode_MAX', };
declare type EARCandidateImageOrientation = 'Landscape' | 'Portrait' | 'EARCandidateImageOrientation_MAX';
declare var EARCandidateImageOrientation : { Landscape:'Landscape',Portrait:'Portrait',EARCandidateImageOrientation_MAX:'EARCandidateImageOrientation_MAX', };
declare class ARCandidateImage extends DataAsset { 
	CandidateTexture: Texture2D;
	FriendlyName: string;
	Width: number;
	Height: number;
	Orientation: EARCandidateImageOrientation;
	static Load(ResourceName: string): ARCandidateImage;
	static Find(Outer: UObject, ResourceName: string): ARCandidateImage;
	static GetDefaultObject(): ARCandidateImage;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARCandidateImage;
	GetPhysicalWidth(): number;
	GetPhysicalHeight(): number;
	GetOrientation(): EARCandidateImageOrientation;
	GetFriendlyName(): string;
	GetCandidateTexture(): Texture2D;
	static C(Other: UObject | any): ARCandidateImage;
}

declare type EAREnvironmentCaptureProbeType = 'None' | 'Manual' | 'Automatic' | 'EAREnvironmentCaptureProbeType_MAX';
declare var EAREnvironmentCaptureProbeType : { None:'None',Manual:'Manual',Automatic:'Automatic',EAREnvironmentCaptureProbeType_MAX:'EAREnvironmentCaptureProbeType_MAX', };
declare class ARCandidateObject extends DataAsset { 
	CandidateObjectData: number[];
	FriendlyName: string;
	BoundingBox: Box;
	static Load(ResourceName: string): ARCandidateObject;
	static Find(Outer: UObject, ResourceName: string): ARCandidateObject;
	static GetDefaultObject(): ARCandidateObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARCandidateObject;
	SetFriendlyName(NewName: string): void;
	SetCandidateObjectData(InCandidateObject: number[]): void;
	SetBoundingBox(InBoundingBox: Box): void;
	GetFriendlyName(): string;
	GetCandidateObjectData(): number[];
	GetBoundingBox(): Box;
	static C(Other: UObject | any): ARCandidateObject;
}

declare class ARVideoFormat { 
	FPS: number;
	Width: number;
	Height: number;
	clone() : ARVideoFormat;
	static C(Other: UObject | any): ARVideoFormat;
}

declare type EARFaceTrackingDirection = 'FaceRelative' | 'FaceMirrored' | 'EARFaceTrackingDirection_MAX';
declare var EARFaceTrackingDirection : { FaceRelative:'FaceRelative',FaceMirrored:'FaceMirrored',EARFaceTrackingDirection_MAX:'EARFaceTrackingDirection_MAX', };
declare type EARFaceTrackingUpdate = 'CurvesAndGeo' | 'CurvesOnly' | 'EARFaceTrackingUpdate_MAX';
declare var EARFaceTrackingUpdate : { CurvesAndGeo:'CurvesAndGeo',CurvesOnly:'CurvesOnly',EARFaceTrackingUpdate_MAX:'EARFaceTrackingUpdate_MAX', };
declare type EARSessionTrackingFeature = 'None' | 'PoseDetection2D' | 'PersonSegmentation' | 'PersonSegmentationWithDepth' | 'SceneDepth' | 'SmoothedSceneDepth' | 'EARSessionTrackingFeature_MAX';
declare var EARSessionTrackingFeature : { None:'None',PoseDetection2D:'PoseDetection2D',PersonSegmentation:'PersonSegmentation',PersonSegmentationWithDepth:'PersonSegmentationWithDepth',SceneDepth:'SceneDepth',SmoothedSceneDepth:'SmoothedSceneDepth',EARSessionTrackingFeature_MAX:'EARSessionTrackingFeature_MAX', };
declare type EARSceneReconstruction = 'None' | 'MeshOnly' | 'MeshWithClassification' | 'EARSceneReconstruction_MAX';
declare var EARSceneReconstruction : { None:'None',MeshOnly:'MeshOnly',MeshWithClassification:'MeshWithClassification',EARSceneReconstruction_MAX:'EARSceneReconstruction_MAX', };
declare class ARSessionPayload { 
	ConfigFlags: number;
	DefaultMeshMaterial: MaterialInterface;
	DefaultWireframeMeshMaterial: MaterialInterface;
	clone() : ARSessionPayload;
	static C(Other: UObject | any): ARSessionPayload;
}

declare class ARPlaneUpdatePayload { 
	SessionPayload: ARSessionPayload;
	WorldTransform: Transform;
	Center: Vector;
	Extents: Vector;
	BoundaryVertices: Vector[];
	ObjectClassification: EARObjectClassification;
	clone() : ARPlaneUpdatePayload;
	static C(Other: UObject | any): ARPlaneUpdatePayload;
}

declare type EPlaneComponentDebugMode = 'None' | 'ShowNetworkRole' | 'ShowClassification' | 'EPlaneComponentDebugMode_MAX';
declare var EPlaneComponentDebugMode : { None:'None',ShowNetworkRole:'ShowNetworkRole',ShowClassification:'ShowClassification',EPlaneComponentDebugMode_MAX:'EPlaneComponentDebugMode_MAX', };
declare class ARPlaneComponent extends ARComponent { 
	ReplicatedPayload: ARPlaneUpdatePayload;
	static Load(ResourceName: string): ARPlaneComponent;
	static Find(Outer: UObject, ResourceName: string): ARPlaneComponent;
	static GetDefaultObject(): ARPlaneComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARPlaneComponent;
	static SetPlaneComponentDebugMode(NewDebugMode: EPlaneComponentDebugMode): void;
	static SetObjectClassificationDebugColors(InColors: Map<EARObjectClassification, LinearColor>): void;
	ServerUpdatePayload(NewPayload: ARPlaneUpdatePayload): void;
	ReceiveUpdate(Payload: ARPlaneUpdatePayload): void;
	ReceiveAdd(Payload: ARPlaneUpdatePayload): void;
	static GetObjectClassificationDebugColors(): Map<EARObjectClassification, LinearColor>;
	static C(Other: UObject | any): ARPlaneComponent;
}

declare class ARPointUpdatePayload { 
	clone() : ARPointUpdatePayload;
	static C(Other: UObject | any): ARPointUpdatePayload;
}

declare class ARPointComponent extends ARComponent { 
	ReplicatedPayload: ARPointUpdatePayload;
	static Load(ResourceName: string): ARPointComponent;
	static Find(Outer: UObject, ResourceName: string): ARPointComponent;
	static GetDefaultObject(): ARPointComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARPointComponent;
	ServerUpdatePayload(NewPayload: ARPointUpdatePayload): void;
	ReceiveUpdate(Payload: ARPointUpdatePayload): void;
	ReceiveAdd(Payload: ARPointUpdatePayload): void;
	static C(Other: UObject | any): ARPointComponent;
}

declare type EARFaceTransformMixing = 'ComponentOnly' | 'ComponentLocationTrackedRotation' | 'ComponentWithTracked' | 'TrackingOnly' | 'EARFaceTransformMixing_MAX';
declare var EARFaceTransformMixing : { ComponentOnly:'ComponentOnly',ComponentLocationTrackedRotation:'ComponentLocationTrackedRotation',ComponentWithTracked:'ComponentWithTracked',TrackingOnly:'TrackingOnly',EARFaceTransformMixing_MAX:'EARFaceTransformMixing_MAX', };
declare class ARFaceUpdatePayload { 
	SessionPayload: ARSessionPayload;
	LeftEyePosition: Vector;
	RightEyePosition: Vector;
	LookAtTarget: Vector;
	clone() : ARFaceUpdatePayload;
	static C(Other: UObject | any): ARFaceUpdatePayload;
}

declare type EFaceComponentDebugMode = 'None' | 'ShowEyeVectors' | 'ShowFaceMesh' | 'EFaceComponentDebugMode_MAX';
declare var EFaceComponentDebugMode : { None:'None',ShowEyeVectors:'ShowEyeVectors',ShowFaceMesh:'ShowFaceMesh',EFaceComponentDebugMode_MAX:'EFaceComponentDebugMode_MAX', };
declare class ARFaceComponent extends ARComponent { 
	TransformSetting: EARFaceTransformMixing;
	bUpdateVertexNormal: boolean;
	bFaceOutOfScreen: boolean;
	ReplicatedPayload: ARFaceUpdatePayload;
	static Load(ResourceName: string): ARFaceComponent;
	static Find(Outer: UObject, ResourceName: string): ARFaceComponent;
	static GetDefaultObject(): ARFaceComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARFaceComponent;
	static SetFaceComponentDebugMode(NewDebugMode: EFaceComponentDebugMode): void;
	ServerUpdatePayload(NewPayload: ARFaceUpdatePayload): void;
	ReceiveUpdate(Payload: ARFaceUpdatePayload): void;
	ReceiveAdd(Payload: ARFaceUpdatePayload): void;
	static C(Other: UObject | any): ARFaceComponent;
}

declare class ARImageUpdatePayload { 
	SessionPayload: ARSessionPayload;
	WorldTransform: Transform;
	DetectedImage: ARCandidateImage;
	EstimatedSize: Vector2D;
	clone() : ARImageUpdatePayload;
	static C(Other: UObject | any): ARImageUpdatePayload;
}

declare type EImageComponentDebugMode = 'None' | 'ShowDetectedImage' | 'EImageComponentDebugMode_MAX';
declare var EImageComponentDebugMode : { None:'None',ShowDetectedImage:'ShowDetectedImage',EImageComponentDebugMode_MAX:'EImageComponentDebugMode_MAX', };
declare class ARImageComponent extends ARComponent { 
	ReplicatedPayload: ARImageUpdatePayload;
	static Load(ResourceName: string): ARImageComponent;
	static Find(Outer: UObject, ResourceName: string): ARImageComponent;
	static GetDefaultObject(): ARImageComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARImageComponent;
	static SetImageComponentDebugMode(NewDebugMode: EImageComponentDebugMode): void;
	ServerUpdatePayload(NewPayload: ARImageUpdatePayload): void;
	ReceiveUpdate(Payload: ARImageUpdatePayload): void;
	ReceiveAdd(Payload: ARImageUpdatePayload): void;
	static C(Other: UObject | any): ARImageComponent;
}

declare class ARQRCodeUpdatePayload { 
	SessionPayload: ARSessionPayload;
	WorldTransform: Transform;
	Extents: Vector;
	QRCode: string;
	clone() : ARQRCodeUpdatePayload;
	static C(Other: UObject | any): ARQRCodeUpdatePayload;
}

declare type EQRCodeComponentDebugMode = 'None' | 'ShowQRCode' | 'EQRCodeComponentDebugMode_MAX';
declare var EQRCodeComponentDebugMode : { None:'None',ShowQRCode:'ShowQRCode',EQRCodeComponentDebugMode_MAX:'EQRCodeComponentDebugMode_MAX', };
declare class ARQRCodeComponent extends ARComponent { 
	ReplicatedPayload: ARQRCodeUpdatePayload;
	static Load(ResourceName: string): ARQRCodeComponent;
	static Find(Outer: UObject, ResourceName: string): ARQRCodeComponent;
	static GetDefaultObject(): ARQRCodeComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARQRCodeComponent;
	static SetQRCodeComponentDebugMode(NewDebugMode: EQRCodeComponentDebugMode): void;
	ServerUpdatePayload(NewPayload: ARQRCodeUpdatePayload): void;
	ReceiveUpdate(Payload: ARQRCodeUpdatePayload): void;
	ReceiveAdd(Payload: ARQRCodeUpdatePayload): void;
	static C(Other: UObject | any): ARQRCodeComponent;
}

declare class ARPoseUpdatePayload { 
	WorldTransform: Transform;
	JointTransforms: Transform[];
	clone() : ARPoseUpdatePayload;
	static C(Other: UObject | any): ARPoseUpdatePayload;
}

declare type EPoseComponentDebugMode = 'None' | 'ShowSkeleton' | 'EPoseComponentDebugMode_MAX';
declare var EPoseComponentDebugMode : { None:'None',ShowSkeleton:'ShowSkeleton',EPoseComponentDebugMode_MAX:'EPoseComponentDebugMode_MAX', };
declare class ARPoseComponent extends ARComponent { 
	ReplicatedPayload: ARPoseUpdatePayload;
	static Load(ResourceName: string): ARPoseComponent;
	static Find(Outer: UObject, ResourceName: string): ARPoseComponent;
	static GetDefaultObject(): ARPoseComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARPoseComponent;
	static SetPoseComponentDebugMode(NewDebugMode: EPoseComponentDebugMode): void;
	ServerUpdatePayload(NewPayload: ARPoseUpdatePayload): void;
	ReceiveUpdate(Payload: ARPoseUpdatePayload): void;
	ReceiveAdd(Payload: ARPoseUpdatePayload): void;
	static C(Other: UObject | any): ARPoseComponent;
}

declare class AREnvironmentProbeUpdatePayload { 
	WorldTransform: Transform;
	clone() : AREnvironmentProbeUpdatePayload;
	static C(Other: UObject | any): AREnvironmentProbeUpdatePayload;
}

declare class AREnvironmentProbeComponent extends ARComponent { 
	ReplicatedPayload: AREnvironmentProbeUpdatePayload;
	static Load(ResourceName: string): AREnvironmentProbeComponent;
	static Find(Outer: UObject, ResourceName: string): AREnvironmentProbeComponent;
	static GetDefaultObject(): AREnvironmentProbeComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AREnvironmentProbeComponent;
	ServerUpdatePayload(NewPayload: AREnvironmentProbeUpdatePayload): void;
	ReceiveUpdate(Payload: AREnvironmentProbeUpdatePayload): void;
	ReceiveAdd(Payload: AREnvironmentProbeUpdatePayload): void;
	static C(Other: UObject | any): AREnvironmentProbeComponent;
}

declare class ARObjectUpdatePayload { 
	WorldTransform: Transform;
	clone() : ARObjectUpdatePayload;
	static C(Other: UObject | any): ARObjectUpdatePayload;
}

declare class ARObjectComponent extends ARComponent { 
	ReplicatedPayload: ARObjectUpdatePayload;
	static Load(ResourceName: string): ARObjectComponent;
	static Find(Outer: UObject, ResourceName: string): ARObjectComponent;
	static GetDefaultObject(): ARObjectComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARObjectComponent;
	ServerUpdatePayload(NewPayload: ARObjectUpdatePayload): void;
	ReceiveUpdate(Payload: ARObjectUpdatePayload): void;
	ReceiveAdd(Payload: ARObjectUpdatePayload): void;
	static C(Other: UObject | any): ARObjectComponent;
}

declare class ARMeshUpdatePayload { 
	SessionPayload: ARSessionPayload;
	WorldTransform: Transform;
	ObjectClassification: EARObjectClassification;
	clone() : ARMeshUpdatePayload;
	static C(Other: UObject | any): ARMeshUpdatePayload;
}

declare class ARMeshComponent extends ARComponent { 
	ReplicatedPayload: ARMeshUpdatePayload;
	static Load(ResourceName: string): ARMeshComponent;
	static Find(Outer: UObject, ResourceName: string): ARMeshComponent;
	static GetDefaultObject(): ARMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARMeshComponent;
	ServerUpdatePayload(NewPayload: ARMeshUpdatePayload): void;
	ReceiveUpdate(Payload: ARMeshUpdatePayload): void;
	ReceiveAdd(Payload: ARMeshUpdatePayload): void;
	static C(Other: UObject | any): ARMeshComponent;
}

declare type EARAltitudeSource = 'Precise' | 'Coarse' | 'UserDefined' | 'Unknown' | 'EARAltitudeSource_MAX';
declare var EARAltitudeSource : { Precise:'Precise',Coarse:'Coarse',UserDefined:'UserDefined',Unknown:'Unknown',EARAltitudeSource_MAX:'EARAltitudeSource_MAX', };
declare class ARGeoAnchorUpdatePayload { 
	SessionPayload: ARSessionPayload;
	WorldTransform: Transform;
	Longitude: number;
	Latitude: number;
	AltitudeMeters: number;
	AltitudeSource: EARAltitudeSource;
	AnchorName: string;
	clone() : ARGeoAnchorUpdatePayload;
	static C(Other: UObject | any): ARGeoAnchorUpdatePayload;
}

declare type EGeoAnchorComponentDebugMode = 'None' | 'ShowGeoData' | 'EGeoAnchorComponentDebugMode_MAX';
declare var EGeoAnchorComponentDebugMode : { None:'None',ShowGeoData:'ShowGeoData',EGeoAnchorComponentDebugMode_MAX:'EGeoAnchorComponentDebugMode_MAX', };
declare class ARGeoAnchorComponent extends ARComponent { 
	ReplicatedPayload: ARGeoAnchorUpdatePayload;
	static Load(ResourceName: string): ARGeoAnchorComponent;
	static Find(Outer: UObject, ResourceName: string): ARGeoAnchorComponent;
	static GetDefaultObject(): ARGeoAnchorComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARGeoAnchorComponent;
	static SetGeoAnchorComponentDebugMode(NewDebugMode: EGeoAnchorComponentDebugMode): void;
	ServerUpdatePayload(NewPayload: ARGeoAnchorUpdatePayload): void;
	ReceiveUpdate(Payload: ARGeoAnchorUpdatePayload): void;
	ReceiveAdd(Payload: ARGeoAnchorUpdatePayload): void;
	static C(Other: UObject | any): ARGeoAnchorComponent;
}

declare class ARSessionConfig extends DataAsset { 
	bGenerateMeshDataFromTrackedGeometry: boolean;
	bGenerateCollisionForMeshData: boolean;
	bGenerateNavMeshForMeshData: boolean;
	bUseMeshDataForOcclusion: boolean;
	bRenderMeshDataInWireframe: boolean;
	bTrackSceneObjects: boolean;
	bUsePersonSegmentationForOcclusion: boolean;
	bUseSceneDepthForOcclusion: boolean;
	bUseAutomaticImageScaleEstimation: boolean;
	bUseStandardOnboardingUX: boolean;
	WorldAlignment: EARWorldAlignment;
	SessionType: EARSessionType;
	PlaneDetectionMode: EARPlaneDetectionMode;
	bHorizontalPlaneDetection: boolean;
	bVerticalPlaneDetection: boolean;
	bEnableAutoFocus: boolean;
	LightEstimationMode: EARLightEstimationMode;
	FrameSyncMode: EARFrameSyncMode;
	bEnableAutomaticCameraOverlay: boolean;
	bEnableAutomaticCameraTracking: boolean;
	bResetCameraTracking: boolean;
	bResetTrackedObjects: boolean;
	CandidateImages: ARCandidateImage[];
	MaxNumSimultaneousImagesTracked: number;
	EnvironmentCaptureProbeType: EAREnvironmentCaptureProbeType;
	WorldMapData: number[];
	CandidateObjects: ARCandidateObject[];
	DesiredVideoFormat: ARVideoFormat;
	bUseOptimalVideoFormat: boolean;
	FaceTrackingDirection: EARFaceTrackingDirection;
	FaceTrackingUpdate: EARFaceTrackingUpdate;
	MaxNumberOfTrackedFaces: number;
	SerializedARCandidateImageDatabase: number[];
	EnabledSessionTrackingFeature: EARSessionTrackingFeature;
	SceneReconstructionMethod: EARSceneReconstruction;
	PlaneComponentClass: UnrealEngineClass;
	PointComponentClass: UnrealEngineClass;
	FaceComponentClass: UnrealEngineClass;
	ImageComponentClass: UnrealEngineClass;
	QRCodeComponentClass: UnrealEngineClass;
	PoseComponentClass: UnrealEngineClass;
	EnvironmentProbeComponentClass: UnrealEngineClass;
	ObjectComponentClass: UnrealEngineClass;
	MeshComponentClass: UnrealEngineClass;
	GeoAnchorComponentClass: UnrealEngineClass;
	DefaultMeshMaterial: MaterialInterface;
	DefaultWireframeMeshMaterial: MaterialInterface;
	static Load(ResourceName: string): ARSessionConfig;
	static Find(Outer: UObject, ResourceName: string): ARSessionConfig;
	static GetDefaultObject(): ARSessionConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARSessionConfig;
	ShouldResetTrackedObjects(): boolean;
	ShouldResetCameraTracking(): boolean;
	ShouldRenderCameraOverlay(): boolean;
	ShouldEnableCameraTracking(): boolean;
	ShouldEnableAutoFocus(): boolean;
	SetWorldMapData(WorldMapData: number[]): void;
	SetSessionTrackingFeatureToEnable(InSessionTrackingFeature: EARSessionTrackingFeature): void;
	SetSceneReconstructionMethod(InSceneReconstructionMethod: EARSceneReconstruction): void;
	SetResetTrackedObjects(bNewValue: boolean): void;
	SetResetCameraTracking(bNewValue: boolean): void;
	SetFaceTrackingUpdate(InUpdate: EARFaceTrackingUpdate): void;
	SetFaceTrackingDirection(InDirection: EARFaceTrackingDirection): void;
	SetEnableAutoFocus(bNewValue: boolean): void;
	SetDesiredVideoFormat(NewFormat: ARVideoFormat): void;
	SetCandidateObjectList(InCandidateObjects: ARCandidateObject[]): void;
	GetWorldMapData(): number[];
	GetWorldAlignment(): EARWorldAlignment;
	GetSessionType(): EARSessionType;
	GetSceneReconstructionMethod(): EARSceneReconstruction;
	GetPlaneDetectionMode(): EARPlaneDetectionMode;
	GetMaxNumSimultaneousImagesTracked(): number;
	GetLightEstimationMode(): EARLightEstimationMode;
	GetFrameSyncMode(): EARFrameSyncMode;
	GetFaceTrackingUpdate(): EARFaceTrackingUpdate;
	GetFaceTrackingDirection(): EARFaceTrackingDirection;
	GetEnvironmentCaptureProbeType(): EAREnvironmentCaptureProbeType;
	GetEnabledSessionTrackingFeature(): EARSessionTrackingFeature;
	GetDesiredVideoFormat(): ARVideoFormat;
	GetCandidateObjectList(): ARCandidateObject[];
	GetCandidateImageList(): ARCandidateImage[];
	AddCandidateObject(CandidateObject: ARCandidateObject): void;
	AddCandidateImage(NewCandidateImage: ARCandidateImage): void;
	static C(Other: UObject | any): ARSessionConfig;
	AddRuntimeCandidateImage(CandidateTexture: Texture2D,FriendlyName: string,PhysicalWidth: number): ARCandidateImage;
	StartARSession(): void;
	static AddRuntimeCandidateImage(SessionConfig: ARSessionConfig,CandidateTexture: Texture2D,FriendlyName: string,PhysicalWidth: number): ARCandidateImage;
	static StartARSession(SessionConfig: ARSessionConfig): void;
}

declare type EARWorldMappingState = 'NotAvailable' | 'StillMappingNotRelocalizable' | 'StillMappingRelocalizable' | 'Mapped' | 'EARWorldMappingState_MAX';
declare var EARWorldMappingState : { NotAvailable:'NotAvailable',StillMappingNotRelocalizable:'StillMappingNotRelocalizable',StillMappingRelocalizable:'StillMappingRelocalizable',Mapped:'Mapped',EARWorldMappingState_MAX:'EARWorldMappingState_MAX', };
declare type EARTrackingQualityReason = 'None' | 'Initializing' | 'Relocalizing' | 'ExcessiveMotion' | 'InsufficientFeatures' | 'InsufficientLight' | 'BadState' | 'EARTrackingQualityReason_MAX';
declare var EARTrackingQualityReason : { None:'None',Initializing:'Initializing',Relocalizing:'Relocalizing',ExcessiveMotion:'ExcessiveMotion',InsufficientFeatures:'InsufficientFeatures',InsufficientLight:'InsufficientLight',BadState:'BadState',EARTrackingQualityReason_MAX:'EARTrackingQualityReason_MAX', };
declare type EARTrackingQuality = 'NotTracking' | 'OrientationOnly' | 'OrientationAndPosition' | 'EARTrackingQuality_MAX';
declare var EARTrackingQuality : { NotTracking:'NotTracking',OrientationOnly:'OrientationOnly',OrientationAndPosition:'OrientationAndPosition',EARTrackingQuality_MAX:'EARTrackingQuality_MAX', };
declare type EARTextureType = 'Unknown' | 'CameraImage' | 'CameraDepth' | 'EnvironmentCapture' | 'PersonSegmentationImage' | 'PersonSegmentationDepth' | 'SceneDepthMap' | 'SceneDepthConfidenceMap' | 'EARTextureType_MAX';
declare var EARTextureType : { Unknown:'Unknown',CameraImage:'CameraImage',CameraDepth:'CameraDepth',EnvironmentCapture:'EnvironmentCapture',PersonSegmentationImage:'PersonSegmentationImage',PersonSegmentationDepth:'PersonSegmentationDepth',SceneDepthMap:'SceneDepthMap',SceneDepthConfidenceMap:'SceneDepthConfidenceMap',EARTextureType_MAX:'EARTextureType_MAX', };
declare class ARTexture extends Texture { 
	TextureType: EARTextureType;
	Timestamp: number;
	ExternalTextureGuid: Guid;
	Size: Vector2D;
	static Load(ResourceName: string): ARTexture;
	static Find(Outer: UObject, ResourceName: string): ARTexture;
	static GetDefaultObject(): ARTexture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTexture;
	static C(Other: UObject | any): ARTexture;
}

declare class ARLightEstimate extends UObject { 
	static Load(ResourceName: string): ARLightEstimate;
	static Find(Outer: UObject, ResourceName: string): ARLightEstimate;
	static GetDefaultObject(): ARLightEstimate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARLightEstimate;
	static C(Other: UObject | any): ARLightEstimate;
}

declare class ARCameraIntrinsics { 
	ImageResolution: IntPoint;
	FocalLength: Vector2D;
	PrincipalPoint: Vector2D;
	clone() : ARCameraIntrinsics;
	static C(Other: UObject | any): ARCameraIntrinsics;
	GetCameraIntrinsics(): {OutCameraIntrinsics: ARCameraIntrinsics, $: boolean};
	static GetCameraIntrinsics(OutCameraIntrinsics?: ARCameraIntrinsics): {OutCameraIntrinsics: ARCameraIntrinsics, $: boolean};
}

declare class ARTextureCameraImage extends ARTexture { 
	static Load(ResourceName: string): ARTextureCameraImage;
	static Find(Outer: UObject, ResourceName: string): ARTextureCameraImage;
	static GetDefaultObject(): ARTextureCameraImage;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTextureCameraImage;
	static C(Other: UObject | any): ARTextureCameraImage;
}

declare type EARDepthQuality = 'Unkown' | 'Low' | 'High' | 'EARDepthQuality_MAX';
declare var EARDepthQuality : { Unkown:'Unkown',Low:'Low',High:'High',EARDepthQuality_MAX:'EARDepthQuality_MAX', };
declare type EARDepthAccuracy = 'Unkown' | 'Approximate' | 'Accurate' | 'EARDepthAccuracy_MAX';
declare var EARDepthAccuracy : { Unkown:'Unkown',Approximate:'Approximate',Accurate:'Accurate',EARDepthAccuracy_MAX:'EARDepthAccuracy_MAX', };
declare class ARTextureCameraDepth extends ARTexture { 
	DepthQuality: EARDepthQuality;
	DepthAccuracy: EARDepthAccuracy;
	bIsTemporallySmoothed: boolean;
	static Load(ResourceName: string): ARTextureCameraDepth;
	static Find(Outer: UObject, ResourceName: string): ARTextureCameraDepth;
	static GetDefaultObject(): ARTextureCameraDepth;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTextureCameraDepth;
	static C(Other: UObject | any): ARTextureCameraDepth;
}

declare type EARSessionStatus = 'NotStarted' | 'Running' | 'NotSupported' | 'FatalError' | 'PermissionNotGranted' | 'UnsupportedConfiguration' | 'Other' | 'EARSessionStatus_MAX';
declare var EARSessionStatus : { NotStarted:'NotStarted',Running:'Running',NotSupported:'NotSupported',FatalError:'FatalError',PermissionNotGranted:'PermissionNotGranted',UnsupportedConfiguration:'UnsupportedConfiguration',Other:'Other',EARSessionStatus_MAX:'EARSessionStatus_MAX', };
declare class ARSessionStatus { 
	AdditionalInfo: string;
	Status: EARSessionStatus;
	clone() : ARSessionStatus;
	static C(Other: UObject | any): ARSessionStatus;
	static GetARSessionStatus(): ARSessionStatus;
}

declare class ARSkeletonDefinition { 
	NumJoints: number;
	JointNames: string[];
	ParentIndices: number[];
	clone() : ARSkeletonDefinition;
	static C(Other: UObject | any): ARSkeletonDefinition;
}

declare type EARJointTransformSpace = 'Model' | 'ParentJoint' | 'EARJointTransformSpace_MAX';
declare var EARJointTransformSpace : { Model:'Model',ParentJoint:'ParentJoint',EARJointTransformSpace_MAX:'EARJointTransformSpace_MAX', };
declare class ARPose3D { 
	SkeletonDefinition: ARSkeletonDefinition;
	JointTransforms: Transform[];
	IsJointTracked: boolean[];
	JointTransformSpace: EARJointTransformSpace;
	clone() : ARPose3D;
	static C(Other: UObject | any): ARPose3D;
}

declare class ARTrackedPose extends ARTrackedGeometry { 
	TrackedPose: ARPose3D;
	static Load(ResourceName: string): ARTrackedPose;
	static Find(Outer: UObject, ResourceName: string): ARTrackedPose;
	static GetDefaultObject(): ARTrackedPose;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTrackedPose;
	GetTrackedPoseData(): ARPose3D;
	static C(Other: UObject | any): ARTrackedPose;
}

declare class ARTrackedPoint extends ARTrackedGeometry { 
	static Load(ResourceName: string): ARTrackedPoint;
	static Find(Outer: UObject, ResourceName: string): ARTrackedPoint;
	static GetDefaultObject(): ARTrackedPoint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTrackedPoint;
	static C(Other: UObject | any): ARTrackedPoint;
}

declare type EARPlaneOrientation = 'Horizontal' | 'Vertical' | 'Diagonal' | 'EARPlaneOrientation_MAX';
declare var EARPlaneOrientation : { Horizontal:'Horizontal',Vertical:'Vertical',Diagonal:'Diagonal',EARPlaneOrientation_MAX:'EARPlaneOrientation_MAX', };
declare class ARPlaneGeometry extends ARTrackedGeometry { 
	Orientation: EARPlaneOrientation;
	Center: Vector;
	Extent: Vector;
	BoundaryPolygon: Vector[];
	SubsumedBy: ARPlaneGeometry;
	static Load(ResourceName: string): ARPlaneGeometry;
	static Find(Outer: UObject, ResourceName: string): ARPlaneGeometry;
	static GetDefaultObject(): ARPlaneGeometry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARPlaneGeometry;
	GetSubsumedBy(): ARPlaneGeometry;
	GetOrientation(): EARPlaneOrientation;
	GetExtent(): Vector;
	GetCenter(): Vector;
	GetBoundaryPolygonInLocalSpace(): Vector[];
	static C(Other: UObject | any): ARPlaneGeometry;
}

declare class ARTrackedImage extends ARTrackedGeometry { 
	DetectedImage: ARCandidateImage;
	EstimatedSize: Vector2D;
	static Load(ResourceName: string): ARTrackedImage;
	static Find(Outer: UObject, ResourceName: string): ARTrackedImage;
	static GetDefaultObject(): ARTrackedImage;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTrackedImage;
	GetEstimateSize(): Vector2D;
	GetDetectedImage(): ARCandidateImage;
	static C(Other: UObject | any): ARTrackedImage;
}

declare class AREnvironmentCaptureProbeTexture extends TextureCube { 
	TextureType: EARTextureType;
	Timestamp: number;
	ExternalTextureGuid: Guid;
	Size: Vector2D;
	static Load(ResourceName: string): AREnvironmentCaptureProbeTexture;
	static Find(Outer: UObject, ResourceName: string): AREnvironmentCaptureProbeTexture;
	static GetDefaultObject(): AREnvironmentCaptureProbeTexture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AREnvironmentCaptureProbeTexture;
	static C(Other: UObject | any): AREnvironmentCaptureProbeTexture;
}

declare class AREnvironmentCaptureProbe extends ARTrackedGeometry { 
	Extent: Vector;
	EnvironmentCaptureTexture: AREnvironmentCaptureProbeTexture;
	static Load(ResourceName: string): AREnvironmentCaptureProbe;
	static Find(Outer: UObject, ResourceName: string): AREnvironmentCaptureProbe;
	static GetDefaultObject(): AREnvironmentCaptureProbe;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AREnvironmentCaptureProbe;
	GetExtent(): Vector;
	GetEnvironmentCaptureTexture(): AREnvironmentCaptureProbeTexture;
	static C(Other: UObject | any): AREnvironmentCaptureProbe;
}

declare class ARPose2D { 
	SkeletonDefinition: ARSkeletonDefinition;
	JointLocations: Vector2D[];
	IsJointTracked: boolean[];
	clone() : ARPose2D;
	static C(Other: UObject | any): ARPose2D;
}

declare class ARBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): ARBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): ARBlueprintLibrary;
	static GetDefaultObject(): ARBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARBlueprintLibrary;
	static UnpinComponent(ComponentToUnpin: SceneComponent): void;
	static ToggleARCapture(bOnOff: boolean,CaptureType: EARCaptureType): boolean;
	static StopARSession(): void;
	static StartARSession(SessionConfig: ARSessionConfig): void;
	static SetEnabledXRCamera(bOnOff: boolean): void;
	static SetARWorldScale(InWorldScale: number): void;
	static SetARWorldOriginLocationAndRotation(OriginLocation: Vector,OriginRotation: Rotator,bIsTransformInWorldSpace: boolean,bMaintainUpDirection: boolean): void;
	static SetAlignmentTransform(InAlignmentTransform: Transform): void;
	static SaveARPinToLocalStore(InSaveName: string,InPin: ARPin): boolean;
	static ResizeXRCamera(InSize: IntPoint): IntPoint;
	static RemovePin(PinToRemove: ARPin): void;
	static RemoveARPinFromLocalStore(InSaveName: string): void;
	static RemoveAllARPinsFromLocalStore(): void;
	static PinComponentToTraceResult(ComponentToPin: SceneComponent,TraceResult: ARTraceResult,DebugName: string): ARPin;
	static PinComponentToARPin(ComponentToPin: SceneComponent,Pin: ARPin): boolean;
	static PinComponent(ComponentToPin: SceneComponent,PinToWorldTransform: Transform,TrackedGeometry: ARTrackedGeometry,DebugName: string): ARPin;
	static PauseARSession(): void;
	static LoadARPinsFromLocalStore(): Map<string, ARPin>;
	static LineTraceTrackedObjects3D(Start: Vector,End: Vector,bTestFeaturePoints: boolean,bTestGroundPlane: boolean,bTestPlaneExtents: boolean,bTestPlaneBoundaryPolygon: boolean): ARTraceResult[];
	static LineTraceTrackedObjects(ScreenCoord: Vector2D,bTestFeaturePoints: boolean,bTestGroundPlane: boolean,bTestPlaneExtents: boolean,bTestPlaneBoundaryPolygon: boolean): ARTraceResult[];
	static IsSessionTypeSupported(SessionType: EARSessionType): boolean;
	static IsSessionTrackingFeatureSupported(SessionType: EARSessionType,SessionTrackingFeature: EARSessionTrackingFeature): boolean;
	static IsSceneReconstructionSupported(SessionType: EARSessionType,SceneReconstructionMethod: EARSceneReconstruction): boolean;
	static IsARSupported(): boolean;
	static IsARPinLocalStoreSupported(): boolean;
	static IsARPinLocalStoreReady(): boolean;
	static GetWorldMappingStatus(): EARWorldMappingState;
	static GetTrackingQualityReason(): EARTrackingQualityReason;
	static GetTrackingQuality(): EARTrackingQuality;
	static GetSupportedVideoFormats(SessionType: EARSessionType): ARVideoFormat[];
	static GetSessionConfig(): ARSessionConfig;
	static GetPointCloud(): Vector[];
	static GetPersonSegmentationImage(): ARTexture;
	static GetPersonSegmentationDepthImage(): ARTexture;
	static GetObjectClassificationAtLocation(InWorldLocation: Vector,OutClassification?: EARObjectClassification,OutClassificationLocation?: Vector,MaxLocationDiff?: number): {OutClassification: EARObjectClassification, OutClassificationLocation: Vector, $: boolean};
	static GetNumberOfTrackedFacesSupported(): number;
	static GetCurrentLightEstimate(): ARLightEstimate;
	static GetCameraIntrinsics(OutCameraIntrinsics?: ARCameraIntrinsics): {OutCameraIntrinsics: ARCameraIntrinsics, $: boolean};
	static GetCameraImage(): ARTextureCameraImage;
	static GetCameraDepth(): ARTextureCameraDepth;
	static GetARWorldScale(): number;
	static GetARTexture(TextureType: EARTextureType): ARTexture;
	static GetARSessionStatus(): ARSessionStatus;
	static GetAllTrackedPoses(): ARTrackedPose[];
	static GetAllTrackedPoints(): ARTrackedPoint[];
	static GetAllTrackedPlanes(): ARPlaneGeometry[];
	static GetAllTrackedImages(): ARTrackedImage[];
	static GetAllTrackedEnvironmentCaptureProbes(): AREnvironmentCaptureProbe[];
	static GetAllTracked2DPoses(): ARPose2D[];
	static GetAllPins(): ARPin[];
	static GetAllGeometriesByClass(GeometryClass: UnrealEngineClass): ARTrackedGeometry[];
	static GetAllGeometries(): ARTrackedGeometry[];
	static GetAlignmentTransform(): Transform;
	static FindTrackedPointsByName(PointName: string): ARTrackedPoint[];
	static DebugDrawTrackedGeometry(TrackedGeometry: ARTrackedGeometry,WorldContextObject: UObject,Color: LinearColor,OutlineThickness: number,PersistForSeconds: number): void;
	static DebugDrawPin(ARPin: ARPin,WorldContextObject: UObject,Color: LinearColor,Scale: number,PersistForSeconds: number): void;
	static CalculateClosestIntersection(StartPoints: Vector[],EndPoints: Vector[],ClosestIntersection?: Vector): {ClosestIntersection: Vector};
	static CalculateAlignmentTransform(TransformInFirstCoordinateSystem: Transform,TransformInSecondCoordinateSystem: Transform,AlignmentTransform?: Transform): {AlignmentTransform: Transform};
	static AddTrackedPointWithName(WorldTransform: Transform,PointName: string,bDeletePointsWithSameName: boolean): boolean;
	static AddRuntimeCandidateImage(SessionConfig: ARSessionConfig,CandidateTexture: Texture2D,FriendlyName: string,PhysicalWidth: number): ARCandidateImage;
	static AddManualEnvironmentCaptureProbe(Location: Vector,Extent: Vector): boolean;
	static C(Other: UObject | any): ARBlueprintLibrary;
}

declare class ARTraceResultLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): ARTraceResultLibrary;
	static Find(Outer: UObject, ResourceName: string): ARTraceResultLibrary;
	static GetDefaultObject(): ARTraceResultLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTraceResultLibrary;
	static GetTrackedGeometry(TraceResult: ARTraceResult): ARTrackedGeometry;
	static GetTraceChannel(TraceResult: ARTraceResult): EARLineTraceChannels;
	static GetLocalTransform(TraceResult: ARTraceResult): Transform;
	static GetLocalToWorldTransform(TraceResult: ARTraceResult): Transform;
	static GetLocalToTrackingTransform(TraceResult: ARTraceResult): Transform;
	static GetDistanceFromCamera(TraceResult: ARTraceResult): number;
	static C(Other: UObject | any): ARTraceResultLibrary;
}

declare class BlueprintAsyncActionBase extends UObject { 
	static Load(ResourceName: string): BlueprintAsyncActionBase;
	static Find(Outer: UObject, ResourceName: string): BlueprintAsyncActionBase;
	static GetDefaultObject(): BlueprintAsyncActionBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintAsyncActionBase;
	Activate(): void;
	static C(Other: UObject | any): BlueprintAsyncActionBase;
}

declare class ARBaseAsyncTaskBlueprintProxy extends BlueprintAsyncActionBase { 
	static Load(ResourceName: string): ARBaseAsyncTaskBlueprintProxy;
	static Find(Outer: UObject, ResourceName: string): ARBaseAsyncTaskBlueprintProxy;
	static GetDefaultObject(): ARBaseAsyncTaskBlueprintProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARBaseAsyncTaskBlueprintProxy;
	static C(Other: UObject | any): ARBaseAsyncTaskBlueprintProxy;
}

declare class ARSaveWorldAsyncTaskBlueprintProxy extends ARBaseAsyncTaskBlueprintProxy { 
	OnSuccess: UnrealEngineMulticastDelegate<(SavedWorld: number[]) => void>;
	OnFailed: UnrealEngineMulticastDelegate<(SavedWorld: number[]) => void>;
	static Load(ResourceName: string): ARSaveWorldAsyncTaskBlueprintProxy;
	static Find(Outer: UObject, ResourceName: string): ARSaveWorldAsyncTaskBlueprintProxy;
	static GetDefaultObject(): ARSaveWorldAsyncTaskBlueprintProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARSaveWorldAsyncTaskBlueprintProxy;
	static ARSaveWorld(WorldContextObject: UObject): ARSaveWorldAsyncTaskBlueprintProxy;
	static C(Other: UObject | any): ARSaveWorldAsyncTaskBlueprintProxy;
}

declare class ARGetCandidateObjectAsyncTaskBlueprintProxy extends ARBaseAsyncTaskBlueprintProxy { 
	OnSuccess: UnrealEngineMulticastDelegate<(SavedObject: ARCandidateObject) => void>;
	OnFailed: UnrealEngineMulticastDelegate<(SavedObject: ARCandidateObject) => void>;
	static Load(ResourceName: string): ARGetCandidateObjectAsyncTaskBlueprintProxy;
	static Find(Outer: UObject, ResourceName: string): ARGetCandidateObjectAsyncTaskBlueprintProxy;
	static GetDefaultObject(): ARGetCandidateObjectAsyncTaskBlueprintProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARGetCandidateObjectAsyncTaskBlueprintProxy;
	static ARGetCandidateObject(WorldContextObject: UObject,Location: Vector,Extent: Vector): ARGetCandidateObjectAsyncTaskBlueprintProxy;
	static C(Other: UObject | any): ARGetCandidateObjectAsyncTaskBlueprintProxy;
}

declare type EARServicePermissionRequestResult = 'Granted' | 'Denied' | 'EARServicePermissionRequestResult_MAX';
declare var EARServicePermissionRequestResult : { Granted:'Granted',Denied:'Denied',EARServicePermissionRequestResult_MAX:'EARServicePermissionRequestResult_MAX', };
declare type EARServiceInstallRequestResult = 'Installed' | 'DeviceNotCompatible' | 'UserDeclinedInstallation' | 'FatalError' | 'EARServiceInstallRequestResult_MAX';
declare var EARServiceInstallRequestResult : { Installed:'Installed',DeviceNotCompatible:'DeviceNotCompatible',UserDeclinedInstallation:'UserDeclinedInstallation',FatalError:'FatalError',EARServiceInstallRequestResult_MAX:'EARServiceInstallRequestResult_MAX', };
declare type EARServiceAvailability = 'UnknownError' | 'UnknownChecking' | 'UnknownTimedOut' | 'UnsupportedDeviceNotCapable' | 'SupportedNotInstalled' | 'SupportedVersionTooOld' | 'SupportedInstalled' | 'EARServiceAvailability_MAX';
declare var EARServiceAvailability : { UnknownError:'UnknownError',UnknownChecking:'UnknownChecking',UnknownTimedOut:'UnknownTimedOut',UnsupportedDeviceNotCapable:'UnsupportedDeviceNotCapable',SupportedNotInstalled:'SupportedNotInstalled',SupportedVersionTooOld:'SupportedVersionTooOld',SupportedInstalled:'SupportedInstalled',EARServiceAvailability_MAX:'EARServiceAvailability_MAX', };
declare class ARDependencyHandler extends UObject { 
	static Load(ResourceName: string): ARDependencyHandler;
	static Find(Outer: UObject, ResourceName: string): ARDependencyHandler;
	static GetDefaultObject(): ARDependencyHandler;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARDependencyHandler;
	StartARSessionLatent(WorldContextObject: UObject,SessionConfig: ARSessionConfig,LatentInfo: LatentActionInfo): void;
	RequestARSessionPermission(WorldContextObject: UObject,SessionConfig: ARSessionConfig,LatentInfo: LatentActionInfo,OutPermissionResult?: EARServicePermissionRequestResult): {OutPermissionResult: EARServicePermissionRequestResult};
	InstallARService(WorldContextObject: UObject,LatentInfo: LatentActionInfo,OutInstallResult?: EARServiceInstallRequestResult): {OutInstallResult: EARServiceInstallRequestResult};
	static GetARDependencyHandler(): ARDependencyHandler;
	CheckARServiceAvailability(WorldContextObject: UObject,LatentInfo: LatentActionInfo,OutAvailability?: EARServiceAvailability): {OutAvailability: EARServiceAvailability};
	static C(Other: UObject | any): ARDependencyHandler;
}

declare type EARGeoTrackingStateReason = 'None' | 'NotAvailableAtLocation' | 'NeedLocationPermissions' | 'DevicePointedTooLow' | 'WorldTrackingUnstable' | 'WaitingForLocation' | 'GeoDataNotLoaded' | 'VisualLocalizationFailed' | 'WaitingForAvailabilityCheck' | 'EARGeoTrackingStateReason_MAX';
declare var EARGeoTrackingStateReason : { None:'None',NotAvailableAtLocation:'NotAvailableAtLocation',NeedLocationPermissions:'NeedLocationPermissions',DevicePointedTooLow:'DevicePointedTooLow',WorldTrackingUnstable:'WorldTrackingUnstable',WaitingForLocation:'WaitingForLocation',GeoDataNotLoaded:'GeoDataNotLoaded',VisualLocalizationFailed:'VisualLocalizationFailed',WaitingForAvailabilityCheck:'WaitingForAvailabilityCheck',EARGeoTrackingStateReason_MAX:'EARGeoTrackingStateReason_MAX', };
declare type EARGeoTrackingState = 'Initializing' | 'Localized' | 'Localizing' | 'NotAvailable' | 'EARGeoTrackingState_MAX';
declare var EARGeoTrackingState : { Initializing:'Initializing',Localized:'Localized',Localizing:'Localizing',NotAvailable:'NotAvailable',EARGeoTrackingState_MAX:'EARGeoTrackingState_MAX', };
declare type EARGeoTrackingAccuracy = 'Undetermined' | 'Low' | 'Medium' | 'High' | 'EARGeoTrackingAccuracy_MAX';
declare var EARGeoTrackingAccuracy : { Undetermined:'Undetermined',Low:'Low',Medium:'Medium',High:'High',EARGeoTrackingAccuracy_MAX:'EARGeoTrackingAccuracy_MAX', };
declare class ARGeoTrackingSupport extends UObject { 
	static Load(ResourceName: string): ARGeoTrackingSupport;
	static Find(Outer: UObject, ResourceName: string): ARGeoTrackingSupport;
	static GetDefaultObject(): ARGeoTrackingSupport;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARGeoTrackingSupport;
	static GetGeoTrackingSupport(): ARGeoTrackingSupport;
	GetGeoTrackingStateReason(): EARGeoTrackingStateReason;
	GetGeoTrackingState(): EARGeoTrackingState;
	GetGeoTrackingAccuracy(): EARGeoTrackingAccuracy;
	AddGeoAnchorAtLocationWithAltitude(Longitude: number,Latitude: number,AltitudeMeters: number,OptionalAnchorName: string): boolean;
	AddGeoAnchorAtLocation(Longitude: number,Latitude: number,OptionalAnchorName: string): boolean;
	static C(Other: UObject | any): ARGeoTrackingSupport;
}

declare class CheckGeoTrackingAvailabilityAsyncTaskBlueprintProxy extends ARBaseAsyncTaskBlueprintProxy { 
	OnSuccess: UnrealEngineMulticastDelegate<(bIsAvailable: boolean, Error: string) => void>;
	OnFailed: UnrealEngineMulticastDelegate<(bIsAvailable: boolean, Error: string) => void>;
	static Load(ResourceName: string): CheckGeoTrackingAvailabilityAsyncTaskBlueprintProxy;
	static Find(Outer: UObject, ResourceName: string): CheckGeoTrackingAvailabilityAsyncTaskBlueprintProxy;
	static GetDefaultObject(): CheckGeoTrackingAvailabilityAsyncTaskBlueprintProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CheckGeoTrackingAvailabilityAsyncTaskBlueprintProxy;
	static CheckGeoTrackingAvailabilityAtLocation(WorldContextObject: UObject,Longitude: number,Latitude: number): CheckGeoTrackingAvailabilityAsyncTaskBlueprintProxy;
	static CheckGeoTrackingAvailability(WorldContextObject: UObject): CheckGeoTrackingAvailabilityAsyncTaskBlueprintProxy;
	static C(Other: UObject | any): CheckGeoTrackingAvailabilityAsyncTaskBlueprintProxy;
}

declare class GetGeoLocationAsyncTaskBlueprintProxy extends ARBaseAsyncTaskBlueprintProxy { 
	OnSuccess: UnrealEngineMulticastDelegate<(Longitude: number, Latitude: number, Altitude: number, Error: string) => void>;
	OnFailed: UnrealEngineMulticastDelegate<(Longitude: number, Latitude: number, Altitude: number, Error: string) => void>;
	static Load(ResourceName: string): GetGeoLocationAsyncTaskBlueprintProxy;
	static Find(Outer: UObject, ResourceName: string): GetGeoLocationAsyncTaskBlueprintProxy;
	static GetDefaultObject(): GetGeoLocationAsyncTaskBlueprintProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GetGeoLocationAsyncTaskBlueprintProxy;
	static GetGeoLocationAtWorldPosition(WorldContextObject: UObject,WorldPosition: Vector): GetGeoLocationAsyncTaskBlueprintProxy;
	static C(Other: UObject | any): GetGeoLocationAsyncTaskBlueprintProxy;
}

declare class ARLifeCycleComponent extends SceneComponent { 
	OnARActorSpawnedDelegate: UnrealEngineMulticastDelegate<(ComponentClass: UnrealEngineClass, NativeID: Guid, SpawnedActor: ARActor) => void>;
	OnARActorToBeDestroyedDelegate: UnrealEngineMulticastDelegate<(Actor: ARActor) => void>;
	static Load(ResourceName: string): ARLifeCycleComponent;
	static Find(Outer: UObject, ResourceName: string): ARLifeCycleComponent;
	static GetDefaultObject(): ARLifeCycleComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARLifeCycleComponent;
	ServerSpawnARActor(ComponentClass: UnrealEngineClass,NativeID: Guid): void;
	ServerDestroyARActor(Actor: ARActor): void;
	static C(Other: UObject | any): ARLifeCycleComponent;
}

declare class ARBasicLightEstimate extends ARLightEstimate { 
	AmbientIntensityLumens: number;
	AmbientColorTemperatureKelvin: number;
	AmbientColor: LinearColor;
	static Load(ResourceName: string): ARBasicLightEstimate;
	static Find(Outer: UObject, ResourceName: string): ARBasicLightEstimate;
	static GetDefaultObject(): ARBasicLightEstimate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARBasicLightEstimate;
	GetAmbientIntensityLumens(): number;
	GetAmbientColorTemperatureKelvin(): number;
	GetAmbientColor(): LinearColor;
	static C(Other: UObject | any): ARBasicLightEstimate;
}

declare class AROriginActor extends Actor { 
	static GetDefaultObject(): AROriginActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AROriginActor;
	static C(Other: UObject | any): AROriginActor;
}

declare class GameMode extends GameModeBase { 
	MatchState: string;
	bDelayedStart: boolean;
	NumSpectators: number;
	NumPlayers: number;
	NumBots: number;
	MinRespawnDelay: number;
	NumTravellingPlayers: number;
	EngineMessageClass: UnrealEngineClass;
	InactivePlayerArray: PlayerState[];
	InactivePlayerStateLifeSpan: number;
	MaxInactivePlayers: number;
	bHandleDedicatedServerReplays: boolean;
	static GetDefaultObject(): GameMode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameMode;
	StartMatch(): void;
	Say(Msg: string): void;
	RestartGame(): void;
	ReadyToStartMatch(): boolean;
	ReadyToEndMatch(): boolean;
	K2_OnSetMatchState(NewState: string): void;
	IsMatchInProgress(): boolean;
	GetMatchState(): string;
	EndMatch(): void;
	AbortMatch(): void;
	static C(Other: UObject | any): GameMode;
}

declare class GameState extends GameStateBase { 
	MatchState: string;
	PreviousMatchState: string;
	ElapsedTime: number;
	static GetDefaultObject(): GameState;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameState;
	OnRep_MatchState(): void;
	OnRep_ElapsedTime(): void;
	static C(Other: UObject | any): GameState;
}

declare class ARSharedWorldGameState extends GameState { 
	PreviewImageData: number[];
	ARWorldData: number[];
	PreviewImageBytesTotal: number;
	ARWorldBytesTotal: number;
	PreviewImageBytesDelivered: number;
	ARWorldBytesDelivered: number;
	static GetDefaultObject(): ARSharedWorldGameState;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARSharedWorldGameState;
	K2_OnARWorldMapIsReady(): void;
	static C(Other: UObject | any): ARSharedWorldGameState;
}

declare class ARSharedWorldGameMode extends GameMode { 
	BufferSizePerChunk: number;
	static GetDefaultObject(): ARSharedWorldGameMode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARSharedWorldGameMode;
	SetPreviewImageData(ImageData: number[]): void;
	SetARWorldSharingIsReady(): void;
	SetARSharedWorldData(ARWorldData: number[]): void;
	GetARSharedWorldGameState(): ARSharedWorldGameState;
	static C(Other: UObject | any): ARSharedWorldGameMode;
}

declare class ARSharedWorldPlayerController extends PlayerController { 
	static GetDefaultObject(): ARSharedWorldPlayerController;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARSharedWorldPlayerController;
	ServerMarkReadyForReceiving(): void;
	ClientUpdatePreviewImageData(Offset: number,Buffer: number[]): void;
	ClientUpdateARWorldData(Offset: number,Buffer: number[]): void;
	ClientInitSharedWorld(PreviewImageSize: number,ARWorldDataSize: number): void;
	static C(Other: UObject | any): ARSharedWorldPlayerController;
}

declare type ECastRayTracedShadow = 'Disabled' | 'UseProjectSetting' | 'Enabled' | 'ECastRayTracedShadow_MAX';
declare var ECastRayTracedShadow : { Disabled:'Disabled',UseProjectSetting:'UseProjectSetting',Enabled:'Enabled',ECastRayTracedShadow_MAX:'ECastRayTracedShadow_MAX', };
declare class LightComponentBase extends SceneComponent { 
	LightGuid: Guid;
	Brightness: number;
	Intensity: number;
	LightColor: Color;
	bAffectsWorld: boolean;
	CastShadows: boolean;
	CastStaticShadows: boolean;
	CastDynamicShadows: boolean;
	bAffectTranslucentLighting: boolean;
	bTransmission: boolean;
	bCastVolumetricShadow: boolean;
	bCastDeepShadow: boolean;
	bCastRaytracedShadow: boolean;
	CastRaytracedShadow: ECastRayTracedShadow;
	bAffectReflection: boolean;
	bAffectGlobalIllumination: boolean;
	DeepShadowLayerDistribution: number;
	IndirectLightingIntensity: number;
	VolumetricScatteringIntensity: number;
	SamplesPerPixel: number;
	StaticEditorTexture: Texture2D;
	StaticEditorTextureScale: number;
	DynamicEditorTexture: Texture2D;
	DynamicEditorTextureScale: number;
	static Load(ResourceName: string): LightComponentBase;
	static Find(Outer: UObject, ResourceName: string): LightComponentBase;
	static GetDefaultObject(): LightComponentBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightComponentBase;
	SetSamplesPerPixel(NewValue: number): void;
	SetCastVolumetricShadow(bNewValue: boolean): void;
	SetCastShadows(bNewValue: boolean): void;
	SetCastRaytracedShadows(bNewValue: ECastRayTracedShadow): void;
	SetCastRaytracedShadow(bNewValue: boolean): void;
	SetCastDeepShadow(bNewValue: boolean): void;
	SetAffectReflection(bNewValue: boolean): void;
	SetAffectGlobalIllumination(bNewValue: boolean): void;
	GetLightColor(): LinearColor;
	static C(Other: UObject | any): LightComponentBase;
}

declare type ESkyLightSourceType = 'SLS_CapturedScene' | 'SLS_SpecifiedCubemap' | 'SLS_MAX';
declare var ESkyLightSourceType : { SLS_CapturedScene:'SLS_CapturedScene',SLS_SpecifiedCubemap:'SLS_SpecifiedCubemap',SLS_MAX:'SLS_MAX', };
declare type EOcclusionCombineMode = 'OCM_Minimum' | 'OCM_Multiply' | 'OCM_MAX';
declare var EOcclusionCombineMode : { OCM_Minimum:'OCM_Minimum',OCM_Multiply:'OCM_Multiply',OCM_MAX:'OCM_MAX', };
declare class SkyLightComponent extends LightComponentBase { 
	bRealTimeCapture: boolean;
	SourceType: ESkyLightSourceType;
	Cubemap: TextureCube;
	SourceCubemapAngle: number;
	CubemapResolution: number;
	SkyDistanceThreshold: number;
	bCaptureEmissiveOnly: boolean;
	bLowerHemisphereIsBlack: boolean;
	LowerHemisphereColor: LinearColor;
	OcclusionMaxDistance: number;
	Contrast: number;
	OcclusionExponent: number;
	MinOcclusion: number;
	OcclusionTint: Color;
	bCloudAmbientOcclusion: boolean;
	CloudAmbientOcclusionStrength: number;
	CloudAmbientOcclusionExtent: number;
	CloudAmbientOcclusionMapResolutionScale: number;
	CloudAmbientOcclusionApertureScale: number;
	OcclusionCombineMode: EOcclusionCombineMode;
	BlendDestinationCubemap: TextureCube;
	static Load(ResourceName: string): SkyLightComponent;
	static Find(Outer: UObject, ResourceName: string): SkyLightComponent;
	static GetDefaultObject(): SkyLightComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkyLightComponent;
	SetVolumetricScatteringIntensity(NewIntensity: number): void;
	SetSourceCubemapAngle(NewValue: number): void;
	SetOcclusionTint(InTint: Color): void;
	SetOcclusionExponent(InOcclusionExponent: number): void;
	SetOcclusionContrast(InOcclusionContrast: number): void;
	SetMinOcclusion(InMinOcclusion: number): void;
	SetLowerHemisphereColor(InLowerHemisphereColor: LinearColor): void;
	SetLightColor(NewLightColor: LinearColor): void;
	SetIntensity(NewIntensity: number): void;
	SetIndirectLightingIntensity(NewIntensity: number): void;
	SetCubemapBlend(SourceCubemap: TextureCube,DestinationCubemap: TextureCube,InBlendFraction: number): void;
	SetCubemap(NewCubemap: TextureCube): void;
	RecaptureSky(): void;
	static C(Other: UObject | any): SkyLightComponent;
}

declare class SkyLight extends Info { 
	LightComponent: SkyLightComponent;
	bEnabled: boolean;
	static GetDefaultObject(): SkyLight;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkyLight;
	OnRep_bEnabled(): void;
	static C(Other: UObject | any): SkyLight;
}

declare class ARSkyLight extends SkyLight { 
	CaptureProbe: AREnvironmentCaptureProbe;
	static GetDefaultObject(): ARSkyLight;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARSkyLight;
	SetEnvironmentCaptureProbe(InCaptureProbe: AREnvironmentCaptureProbe): void;
	static C(Other: UObject | any): ARSkyLight;
}

declare class ARTraceResultDummy extends UObject { 
	static Load(ResourceName: string): ARTraceResultDummy;
	static Find(Outer: UObject, ResourceName: string): ARTraceResultDummy;
	static GetDefaultObject(): ARTraceResultDummy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTraceResultDummy;
	static C(Other: UObject | any): ARTraceResultDummy;
}

declare class ARTrackedQRCode extends ARTrackedImage { 
	QRCode: string;
	Version: number;
	static Load(ResourceName: string): ARTrackedQRCode;
	static Find(Outer: UObject, ResourceName: string): ARTrackedQRCode;
	static GetDefaultObject(): ARTrackedQRCode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTrackedQRCode;
	static C(Other: UObject | any): ARTrackedQRCode;
}

declare type EARFaceBlendShape = 'EyeBlinkLeft' | 'EyeLookDownLeft' | 'EyeLookInLeft' | 'EyeLookOutLeft' | 'EyeLookUpLeft' | 'EyeSquintLeft' | 'EyeWideLeft' | 'EyeBlinkRight' | 'EyeLookDownRight' | 'EyeLookInRight' | 'EyeLookOutRight' | 'EyeLookUpRight' | 'EyeSquintRight' | 'EyeWideRight' | 'JawForward' | 'JawLeft' | 'JawRight' | 'JawOpen' | 'MouthClose' | 'MouthFunnel' | 'MouthPucker' | 'MouthLeft' | 'MouthRight' | 'MouthSmileLeft' | 'MouthSmileRight' | 'MouthFrownLeft' | 'MouthFrownRight' | 'MouthDimpleLeft' | 'MouthDimpleRight' | 'MouthStretchLeft' | 'MouthStretchRight' | 'MouthRollLower' | 'MouthRollUpper' | 'MouthShrugLower' | 'MouthShrugUpper' | 'MouthPressLeft' | 'MouthPressRight' | 'MouthLowerDownLeft' | 'MouthLowerDownRight' | 'MouthUpperUpLeft' | 'MouthUpperUpRight' | 'BrowDownLeft' | 'BrowDownRight' | 'BrowInnerUp' | 'BrowOuterUpLeft' | 'BrowOuterUpRight' | 'CheekPuff' | 'CheekSquintLeft' | 'CheekSquintRight' | 'NoseSneerLeft' | 'NoseSneerRight' | 'TongueOut' | 'HeadYaw' | 'HeadPitch' | 'HeadRoll' | 'LeftEyeYaw' | 'LeftEyePitch' | 'LeftEyeRoll' | 'RightEyeYaw' | 'RightEyePitch' | 'RightEyeRoll' | 'MAX';
declare var EARFaceBlendShape : { EyeBlinkLeft:'EyeBlinkLeft',EyeLookDownLeft:'EyeLookDownLeft',EyeLookInLeft:'EyeLookInLeft',EyeLookOutLeft:'EyeLookOutLeft',EyeLookUpLeft:'EyeLookUpLeft',EyeSquintLeft:'EyeSquintLeft',EyeWideLeft:'EyeWideLeft',EyeBlinkRight:'EyeBlinkRight',EyeLookDownRight:'EyeLookDownRight',EyeLookInRight:'EyeLookInRight',EyeLookOutRight:'EyeLookOutRight',EyeLookUpRight:'EyeLookUpRight',EyeSquintRight:'EyeSquintRight',EyeWideRight:'EyeWideRight',JawForward:'JawForward',JawLeft:'JawLeft',JawRight:'JawRight',JawOpen:'JawOpen',MouthClose:'MouthClose',MouthFunnel:'MouthFunnel',MouthPucker:'MouthPucker',MouthLeft:'MouthLeft',MouthRight:'MouthRight',MouthSmileLeft:'MouthSmileLeft',MouthSmileRight:'MouthSmileRight',MouthFrownLeft:'MouthFrownLeft',MouthFrownRight:'MouthFrownRight',MouthDimpleLeft:'MouthDimpleLeft',MouthDimpleRight:'MouthDimpleRight',MouthStretchLeft:'MouthStretchLeft',MouthStretchRight:'MouthStretchRight',MouthRollLower:'MouthRollLower',MouthRollUpper:'MouthRollUpper',MouthShrugLower:'MouthShrugLower',MouthShrugUpper:'MouthShrugUpper',MouthPressLeft:'MouthPressLeft',MouthPressRight:'MouthPressRight',MouthLowerDownLeft:'MouthLowerDownLeft',MouthLowerDownRight:'MouthLowerDownRight',MouthUpperUpLeft:'MouthUpperUpLeft',MouthUpperUpRight:'MouthUpperUpRight',BrowDownLeft:'BrowDownLeft',BrowDownRight:'BrowDownRight',BrowInnerUp:'BrowInnerUp',BrowOuterUpLeft:'BrowOuterUpLeft',BrowOuterUpRight:'BrowOuterUpRight',CheekPuff:'CheekPuff',CheekSquintLeft:'CheekSquintLeft',CheekSquintRight:'CheekSquintRight',NoseSneerLeft:'NoseSneerLeft',NoseSneerRight:'NoseSneerRight',TongueOut:'TongueOut',HeadYaw:'HeadYaw',HeadPitch:'HeadPitch',HeadRoll:'HeadRoll',LeftEyeYaw:'LeftEyeYaw',LeftEyePitch:'LeftEyePitch',LeftEyeRoll:'LeftEyeRoll',RightEyeYaw:'RightEyeYaw',RightEyePitch:'RightEyePitch',RightEyeRoll:'RightEyeRoll',MAX:'MAX', };
declare type EAREye = 'LeftEye' | 'RightEye' | 'EAREye_MAX';
declare var EAREye : { LeftEye:'LeftEye',RightEye:'RightEye',EAREye_MAX:'EAREye_MAX', };
declare class ARFaceGeometry extends ARTrackedGeometry { 
	LookAtTarget: Vector;
	bIsTracked: boolean;
	BlendShapes: Map<EARFaceBlendShape, number>;
	LeftEyeTransform: Transform;
	RightEyeTransform: Transform;
	static Load(ResourceName: string): ARFaceGeometry;
	static Find(Outer: UObject, ResourceName: string): ARFaceGeometry;
	static GetDefaultObject(): ARFaceGeometry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARFaceGeometry;
	GetWorldSpaceEyeTransform(Eye: EAREye): Transform;
	GetLocalSpaceEyeTransform(Eye: EAREye): Transform;
	GetBlendShapeValue(BlendShape: EARFaceBlendShape): number;
	GetBlendShapes(): Map<EARFaceBlendShape, number>;
	static C(Other: UObject | any): ARFaceGeometry;
}

declare class ARTrackedObject extends ARTrackedGeometry { 
	DetectedObject: ARCandidateObject;
	static Load(ResourceName: string): ARTrackedObject;
	static Find(Outer: UObject, ResourceName: string): ARTrackedObject;
	static GetDefaultObject(): ARTrackedObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTrackedObject;
	GetDetectedObject(): ARCandidateObject;
	static C(Other: UObject | any): ARTrackedObject;
}

declare class ARMeshGeometry extends ARTrackedGeometry { 
	static Load(ResourceName: string): ARMeshGeometry;
	static Find(Outer: UObject, ResourceName: string): ARMeshGeometry;
	static GetDefaultObject(): ARMeshGeometry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARMeshGeometry;
	GetObjectClassificationAtLocation(InWorldLocation: Vector,OutClassification?: EARObjectClassification,OutClassificationLocation?: Vector,MaxLocationDiff?: number): {OutClassification: EARObjectClassification, OutClassificationLocation: Vector, $: boolean};
	static C(Other: UObject | any): ARMeshGeometry;
}

declare class ARGeoAnchor extends ARTrackedGeometry { 
	static Load(ResourceName: string): ARGeoAnchor;
	static Find(Outer: UObject, ResourceName: string): ARGeoAnchor;
	static GetDefaultObject(): ARGeoAnchor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARGeoAnchor;
	GetLongitude(): number;
	GetLatitude(): number;
	GetAltitudeSource(): EARAltitudeSource;
	GetAltitudeMeters(): number;
	static C(Other: UObject | any): ARGeoAnchor;
}

declare class ARTrackableNotifyComponent extends ActorComponent { 
	OnAddTrackedGeometry: UnrealEngineMulticastDelegate<(TrackedGeometry: ARTrackedGeometry) => void>;
	OnUpdateTrackedGeometry: UnrealEngineMulticastDelegate<(TrackedGeometry: ARTrackedGeometry) => void>;
	OnRemoveTrackedGeometry: UnrealEngineMulticastDelegate<(TrackedGeometry: ARTrackedGeometry) => void>;
	OnAddTrackedPlane: UnrealEngineMulticastDelegate<(TrackedPlane: ARPlaneGeometry) => void>;
	OnUpdateTrackedPlane: UnrealEngineMulticastDelegate<(TrackedPlane: ARPlaneGeometry) => void>;
	OnRemoveTrackedPlane: UnrealEngineMulticastDelegate<(TrackedPlane: ARPlaneGeometry) => void>;
	OnAddTrackedPoint: UnrealEngineMulticastDelegate<(TrackedPoint: ARTrackedPoint) => void>;
	OnUpdateTrackedPoint: UnrealEngineMulticastDelegate<(TrackedPoint: ARTrackedPoint) => void>;
	OnRemoveTrackedPoint: UnrealEngineMulticastDelegate<(TrackedPoint: ARTrackedPoint) => void>;
	OnAddTrackedImage: UnrealEngineMulticastDelegate<(TrackedImage: ARTrackedImage) => void>;
	OnUpdateTrackedImage: UnrealEngineMulticastDelegate<(TrackedImage: ARTrackedImage) => void>;
	OnRemoveTrackedImage: UnrealEngineMulticastDelegate<(TrackedImage: ARTrackedImage) => void>;
	OnAddTrackedFace: UnrealEngineMulticastDelegate<(TrackedFace: ARFaceGeometry) => void>;
	OnUpdateTrackedFace: UnrealEngineMulticastDelegate<(TrackedFace: ARFaceGeometry) => void>;
	OnRemoveTrackedFace: UnrealEngineMulticastDelegate<(TrackedFace: ARFaceGeometry) => void>;
	OnAddTrackedEnvProbe: UnrealEngineMulticastDelegate<(TrackedEnvProbe: AREnvironmentCaptureProbe) => void>;
	OnUpdateTrackedEnvProbe: UnrealEngineMulticastDelegate<(TrackedEnvProbe: AREnvironmentCaptureProbe) => void>;
	OnRemoveTrackedEnvProbe: UnrealEngineMulticastDelegate<(TrackedEnvProbe: AREnvironmentCaptureProbe) => void>;
	OnAddTrackedObject: UnrealEngineMulticastDelegate<(TrackedObject: ARTrackedObject) => void>;
	OnUpdateTrackedObject: UnrealEngineMulticastDelegate<(TrackedObject: ARTrackedObject) => void>;
	OnRemoveTrackedObject: UnrealEngineMulticastDelegate<(TrackedObject: ARTrackedObject) => void>;
	static Load(ResourceName: string): ARTrackableNotifyComponent;
	static Find(Outer: UObject, ResourceName: string): ARTrackableNotifyComponent;
	static GetDefaultObject(): ARTrackableNotifyComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTrackableNotifyComponent;
	static C(Other: UObject | any): ARTrackableNotifyComponent;
}

declare class ARTypesDummyClass extends UObject { 
	static Load(ResourceName: string): ARTypesDummyClass;
	static Find(Outer: UObject, ResourceName: string): ARTypesDummyClass;
	static GetDefaultObject(): ARTypesDummyClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTypesDummyClass;
	static C(Other: UObject | any): ARTypesDummyClass;
}

declare type EHandKeypoint = 'Palm' | 'Wrist' | 'ThumbMetacarpal' | 'ThumbProximal' | 'ThumbDistal' | 'ThumbTip' | 'IndexMetacarpal' | 'IndexProximal' | 'IndexIntermediate' | 'IndexDistal' | 'IndexTip' | 'MiddleMetacarpal' | 'MiddleProximal' | 'MiddleIntermediate' | 'MiddleDistal' | 'MiddleTip' | 'RingMetacarpal' | 'RingProximal' | 'RingIntermediate' | 'RingDistal' | 'RingTip' | 'LittleMetacarpal' | 'LittleProximal' | 'LittleIntermediate' | 'LittleDistal' | 'LittleTip' | 'EHandKeypoint_MAX';
declare var EHandKeypoint : { Palm:'Palm',Wrist:'Wrist',ThumbMetacarpal:'ThumbMetacarpal',ThumbProximal:'ThumbProximal',ThumbDistal:'ThumbDistal',ThumbTip:'ThumbTip',IndexMetacarpal:'IndexMetacarpal',IndexProximal:'IndexProximal',IndexIntermediate:'IndexIntermediate',IndexDistal:'IndexDistal',IndexTip:'IndexTip',MiddleMetacarpal:'MiddleMetacarpal',MiddleProximal:'MiddleProximal',MiddleIntermediate:'MiddleIntermediate',MiddleDistal:'MiddleDistal',MiddleTip:'MiddleTip',RingMetacarpal:'RingMetacarpal',RingProximal:'RingProximal',RingIntermediate:'RingIntermediate',RingDistal:'RingDistal',RingTip:'RingTip',LittleMetacarpal:'LittleMetacarpal',LittleProximal:'LittleProximal',LittleIntermediate:'LittleIntermediate',LittleDistal:'LittleDistal',LittleTip:'LittleTip',EHandKeypoint_MAX:'EHandKeypoint_MAX', };
declare class HandKeypointConversion extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): HandKeypointConversion;
	static Find(Outer: UObject, ResourceName: string): HandKeypointConversion;
	static GetDefaultObject(): HandKeypointConversion;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HandKeypointConversion;
	static Conv_HandKeypointToInt32(Input: EHandKeypoint): number;
	static C(Other: UObject | any): HandKeypointConversion;
}

declare type ESpectatorScreenMode = 'Disabled' | 'SingleEyeLetterboxed' | 'Undistorted' | 'Distorted' | 'SingleEye' | 'SingleEyeCroppedToFill' | 'Texture' | 'TexturePlusEye' | 'ESpectatorScreenMode_MAX';
declare var ESpectatorScreenMode : { Disabled:'Disabled',SingleEyeLetterboxed:'SingleEyeLetterboxed',Undistorted:'Undistorted',Distorted:'Distorted',SingleEye:'SingleEye',SingleEyeCroppedToFill:'SingleEyeCroppedToFill',Texture:'Texture',TexturePlusEye:'TexturePlusEye',ESpectatorScreenMode_MAX:'ESpectatorScreenMode_MAX', };
declare type EOrientPositionSelector = 'Orientation' | 'Position' | 'OrientationAndPosition' | 'EOrientPositionSelector_MAX';
declare var EOrientPositionSelector : { Orientation:'Orientation',Position:'Position',OrientationAndPosition:'OrientationAndPosition',EOrientPositionSelector_MAX:'EOrientPositionSelector_MAX', };
declare type EHMDWornState = 'Unknown' | 'Worn' | 'NotWorn' | 'EHMDWornState_MAX';
declare var EHMDWornState : { Unknown:'Unknown',Worn:'Worn',NotWorn:'NotWorn',EHMDWornState_MAX:'EHMDWornState_MAX', };
declare type EXRTrackedDeviceType = 'HeadMountedDisplay' | 'Controller' | 'TrackingReference' | 'Other' | 'Invalid' | 'Any' | 'EXRTrackedDeviceType_MAX';
declare var EXRTrackedDeviceType : { HeadMountedDisplay:'HeadMountedDisplay',Controller:'Controller',TrackingReference:'TrackingReference',Other:'Other',Invalid:'Invalid',Any:'Any',EXRTrackedDeviceType_MAX:'EXRTrackedDeviceType_MAX', };
declare type EXRDeviceConnectionResult = 'NoTrackingSystem' | 'FeatureNotSupported' | 'NoValidViewport' | 'MiscFailure' | 'Success' | 'EXRDeviceConnectionResult_MAX';
declare var EXRDeviceConnectionResult : { NoTrackingSystem:'NoTrackingSystem',FeatureNotSupported:'FeatureNotSupported',NoValidViewport:'NoValidViewport',MiscFailure:'MiscFailure',Success:'Success',EXRDeviceConnectionResult_MAX:'EXRDeviceConnectionResult_MAX', };
declare type ESpatialInputGestureAxis = 'None' | 'Manipulation' | 'Navigation' | 'NavigationRails' | 'ESpatialInputGestureAxis_MAX';
declare var ESpatialInputGestureAxis : { None:'None',Manipulation:'Manipulation',Navigation:'Navigation',NavigationRails:'NavigationRails',ESpatialInputGestureAxis_MAX:'ESpatialInputGestureAxis_MAX', };
declare class XRGestureConfig { 
	bTap: boolean;
	bHold: boolean;
	AxisGesture: ESpatialInputGestureAxis;
	bNavigationAxisX: boolean;
	bNavigationAxisY: boolean;
	bNavigationAxisZ: boolean;
	clone() : XRGestureConfig;
	static C(Other: UObject | any): XRGestureConfig;
	ConfigureGestures(): boolean;
	static ConfigureGestures(GestureConfig: XRGestureConfig): boolean;
}

declare class HeadMountedDisplayFunctionLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): HeadMountedDisplayFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): HeadMountedDisplayFunctionLibrary;
	static GetDefaultObject(): HeadMountedDisplayFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HeadMountedDisplayFunctionLibrary;
	static UpdateExternalTrackingHMDPosition(ExternalTrackingTransform: Transform): void;
	static SetWorldToMetersScale(WorldContext: UObject,NewScale: number): void;
	static SetTrackingOrigin(Origin: EHMDTrackingOrigin): void;
	static SetSpectatorScreenTexture(InTexture: Texture): void;
	static SetSpectatorScreenModeTexturePlusEyeLayout(EyeRectMin: Vector2D,EyeRectMax: Vector2D,TextureRectMin: Vector2D,TextureRectMax: Vector2D,bDrawEyeFirst: boolean,bClearBlack: boolean,bUseAlpha: boolean): void;
	static SetSpectatorScreenMode(Mode: ESpectatorScreenMode): void;
	static SetClippingPlanes(Near: number,Far: number): void;
	static ResetOrientationAndPosition(Yaw: number,Options: EOrientPositionSelector): void;
	static IsSpectatorScreenModeControllable(): boolean;
	static IsInLowPersistenceMode(): boolean;
	static IsHeadMountedDisplayEnabled(): boolean;
	static IsHeadMountedDisplayConnected(): boolean;
	static IsDeviceTracking(XRDeviceId: XRDeviceId): boolean;
	static HasValidTrackingPosition(): boolean;
	static GetXRSystemFlags(): number;
	static GetWorldToMetersScale(WorldContext: UObject): number;
	static GetVRFocusState(bUseFocus?: boolean,bHasFocus?: boolean): {bUseFocus: boolean, bHasFocus: boolean};
	static GetVersionString(): string;
	static GetTrackingToWorldTransform(WorldContext: UObject): Transform;
	static GetTrackingSensorParameters(Origin?: Vector,Rotation?: Rotator,LeftFOV?: number,RightFOV?: number,TopFOV?: number,BottomFOV?: number,Distance?: number,NearPlane?: number,FarPlane?: number,IsActive?: boolean,Index?: number): {Origin: Vector, Rotation: Rotator, LeftFOV: number, RightFOV: number, TopFOV: number, BottomFOV: number, Distance: number, NearPlane: number, FarPlane: number, IsActive: boolean};
	static GetTrackingOriginTransform(Origin: EHMDTrackingOrigin,OutTransform?: Transform): {OutTransform: Transform, $: boolean};
	static GetTrackingOrigin(): EHMDTrackingOrigin;
	static GetPositionalTrackingCameraParameters(CameraOrigin?: Vector,CameraRotation?: Rotator,HFOV?: number,VFOV?: number,CameraDistance?: number,NearPlane?: number,FarPlane?: number): {CameraOrigin: Vector, CameraRotation: Rotator, HFOV: number, VFOV: number, CameraDistance: number, NearPlane: number, FarPlane: number};
	static GetPlayAreaRect(OutTransform?: Transform,OutRect?: Vector2D): {OutTransform: Transform, OutRect: Vector2D, $: boolean};
	static GetPlayAreaBounds(Origin: EHMDTrackingOrigin): Vector2D;
	static GetPixelDensity(): number;
	static GetOrientationAndPosition(DeviceRotation?: Rotator,DevicePosition?: Vector): {DeviceRotation: Rotator, DevicePosition: Vector};
	static GetNumOfTrackingSensors(): number;
	static GetMotionControllerData(WorldContext: UObject,Hand: EControllerHand,MotionControllerData?: XRMotionControllerData): {MotionControllerData: XRMotionControllerData};
	static GetHMDWornState(): EHMDWornState;
	static GetHMDDeviceName(): string;
	static GetHMDData(WorldContext: UObject,HMDData?: XRHMDData): {HMDData: XRHMDData};
	static GetDeviceWorldPose(WorldContext: UObject,XRDeviceId: XRDeviceId,bIsTracked?: boolean,Orientation?: Rotator,bHasPositionalTracking?: boolean,Position?: Vector): {bIsTracked: boolean, Orientation: Rotator, bHasPositionalTracking: boolean, Position: Vector};
	static GetDevicePose(XRDeviceId: XRDeviceId,bIsTracked?: boolean,Orientation?: Rotator,bHasPositionalTracking?: boolean,Position?: Vector): {bIsTracked: boolean, Orientation: Rotator, bHasPositionalTracking: boolean, Position: Vector};
	static GetCurrentInteractionProfile(Hand: EControllerHand,InteractionProfile?: string): {InteractionProfile: string, $: boolean};
	static GetControllerTransformForTime(WorldContext: UObject,ControllerIndex: number,MotionSource: string,Time: Timespan,bTimeWasUsed?: boolean,Orientation?: Rotator,Position?: Vector,bProvidedLinearVelocity?: boolean,LinearVelocity?: Vector,bProvidedAngularVelocity?: boolean,AngularVelocityRadPerSec?: Vector,bProvidedLinearAcceleration?: boolean,LinearAcceleration?: Vector): {bTimeWasUsed: boolean, Orientation: Rotator, Position: Vector, bProvidedLinearVelocity: boolean, LinearVelocity: Vector, bProvidedAngularVelocity: boolean, AngularVelocityRadPerSec: Vector, bProvidedLinearAcceleration: boolean, LinearAcceleration: Vector, $: boolean};
	static EnumerateTrackedDevices(SystemId: string,DeviceType: EXRTrackedDeviceType): XRDeviceId[];
	static EnableLowPersistenceMode(bEnable: boolean): void;
	static EnableHMD(bEnable: boolean): boolean;
	static DisconnectRemoteXRDevice(): void;
	static ConnectRemoteXRDevice(IpAddress: string,BitRate: number): EXRDeviceConnectionResult;
	static ConfigureGestures(GestureConfig: XRGestureConfig): boolean;
	static ClearXRTimedInputActionDelegate(ActionPath: string): void;
	static CalibrateExternalTrackingToHMD(ExternalTrackingTransform: Transform): void;
	static BreakKey(InKey: Key,InteractionProfile?: string,Hand?: EControllerHand,MotionSource?: string,Indentifier?: string,Component?: string): {InteractionProfile: string, Hand: EControllerHand, MotionSource: string, Indentifier: string, Component: string};
	static C(Other: UObject | any): HeadMountedDisplayFunctionLibrary;
}

declare class MotionControllerComponent extends PrimitiveComponent { 
	PlayerIndex: number;
	Hand: EControllerHand;
	MotionSource: string;
	bDisableLowLatencyUpdate: boolean;
	CurrentTrackingStatus: ETrackingStatus;
	bDisplayDeviceModel: boolean;
	DisplayModelSource: string;
	CustomDisplayMesh: StaticMesh;
	DisplayMeshMaterialOverrides: MaterialInterface[];
	DisplayComponent: PrimitiveComponent;
	static Load(ResourceName: string): MotionControllerComponent;
	static Find(Outer: UObject, ResourceName: string): MotionControllerComponent;
	static GetDefaultObject(): MotionControllerComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MotionControllerComponent;
	SetTrackingSource(NewSource: EControllerHand): void;
	SetTrackingMotionSource(NewSource: string): void;
	SetShowDeviceModel(bShowControllerModel: boolean): void;
	SetDisplayModelSource(NewDisplayModelSource: string): void;
	SetCustomDisplayMesh(NewDisplayMesh: StaticMesh): void;
	SetAssociatedPlayerIndex(NewPlayer: number): void;
	OnMotionControllerUpdated(): void;
	IsTracked(): boolean;
	GetTrackingSource(): EControllerHand;
	GetParameterValue(InName: string,bValueFound?: boolean): {bValueFound: boolean, $: number};
	GetHandJointPosition(jointIndex: number,bValueFound?: boolean): {bValueFound: boolean, $: Vector};
	static C(Other: UObject | any): MotionControllerComponent;
	DisableMotionTrackingForComponent(): void;
	EnableMotionTrackingForComponent(): boolean;
	IsMotionTrackingEnabledForComponent(): boolean;
	static DisableMotionTrackingForComponent(MotionControllerComponent: MotionControllerComponent): void;
	static EnableMotionTrackingForComponent(MotionControllerComponent: MotionControllerComponent): boolean;
	static IsMotionTrackingEnabledForComponent(MotionControllerComponent: MotionControllerComponent): boolean;
}

declare class MotionTrackedDeviceFunctionLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): MotionTrackedDeviceFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): MotionTrackedDeviceFunctionLibrary;
	static GetDefaultObject(): MotionTrackedDeviceFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MotionTrackedDeviceFunctionLibrary;
	static SetIsControllerMotionTrackingEnabledByDefault(Enable: boolean): void;
	static IsMotionTrackingEnabledForSource(PlayerIndex: number,SourceName: string): boolean;
	static IsMotionTrackingEnabledForDevice(PlayerIndex: number,Hand: EControllerHand): boolean;
	static IsMotionTrackingEnabledForComponent(MotionControllerComponent: MotionControllerComponent): boolean;
	static IsMotionTrackedDeviceCountManagementNecessary(): boolean;
	static IsMotionSourceTracking(PlayerIndex: number,SourceName: string): boolean;
	static GetMotionTrackingEnabledControllerCount(): number;
	static GetMaximumMotionTrackedControllerCount(): number;
	static GetActiveTrackingSystemName(): string;
	static EnumerateMotionSources(): string[];
	static EnableMotionTrackingOfSource(PlayerIndex: number,SourceName: string): boolean;
	static EnableMotionTrackingOfDevice(PlayerIndex: number,Hand: EControllerHand): boolean;
	static EnableMotionTrackingForComponent(MotionControllerComponent: MotionControllerComponent): boolean;
	static DisableMotionTrackingOfSource(PlayerIndex: number,SourceName: string): void;
	static DisableMotionTrackingOfDevice(PlayerIndex: number,Hand: EControllerHand): void;
	static DisableMotionTrackingOfControllersForPlayer(PlayerIndex: number): void;
	static DisableMotionTrackingOfAllControllers(): void;
	static DisableMotionTrackingForComponent(MotionControllerComponent: MotionControllerComponent): void;
	static C(Other: UObject | any): MotionTrackedDeviceFunctionLibrary;
}

declare class VRNotificationsComponent extends ActorComponent { 
	HMDTrackingInitializingAndNeedsHMDToBeTrackedDelegate: UnrealEngineMulticastDelegate<() => void>;
	HMDTrackingInitializedDelegate: UnrealEngineMulticastDelegate<() => void>;
	HMDRecenteredDelegate: UnrealEngineMulticastDelegate<() => void>;
	HMDLostDelegate: UnrealEngineMulticastDelegate<() => void>;
	HMDReconnectedDelegate: UnrealEngineMulticastDelegate<() => void>;
	HMDConnectCanceledDelegate: UnrealEngineMulticastDelegate<() => void>;
	HMDPutOnHeadDelegate: UnrealEngineMulticastDelegate<() => void>;
	HMDRemovedFromHeadDelegate: UnrealEngineMulticastDelegate<() => void>;
	VRControllerRecenteredDelegate: UnrealEngineMulticastDelegate<() => void>;
	XRTrackingOriginChangedDelegate: UnrealEngineMulticastDelegate<() => void>;
	XRPlayAreaChangedDelegate: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): VRNotificationsComponent;
	static Find(Outer: UObject, ResourceName: string): VRNotificationsComponent;
	static GetDefaultObject(): VRNotificationsComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VRNotificationsComponent;
	static C(Other: UObject | any): VRNotificationsComponent;
}

declare class XRAssetFunctionLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): XRAssetFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): XRAssetFunctionLibrary;
	static GetDefaultObject(): XRAssetFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): XRAssetFunctionLibrary;
	static AddNamedDeviceVisualizationComponentBlocking(Target: Actor,SystemName: string,DeviceName: string,bManualAttachment: boolean,RelativeTransform: Transform,XRDeviceId?: XRDeviceId): {XRDeviceId: XRDeviceId, $: PrimitiveComponent};
	static AddDeviceVisualizationComponentBlocking(Target: Actor,XRDeviceId: XRDeviceId,bManualAttachment: boolean,RelativeTransform: Transform): PrimitiveComponent;
	static C(Other: UObject | any): XRAssetFunctionLibrary;
}

declare class AsyncTask_LoadXRDeviceVisComponent extends BlueprintAsyncActionBase { 
	OnModelLoaded: UnrealEngineMulticastDelegate<(LoadedComponent: PrimitiveComponent) => void>;
	OnLoadFailure: UnrealEngineMulticastDelegate<(LoadedComponent: PrimitiveComponent) => void>;
	SpawnedComponent: PrimitiveComponent;
	static Load(ResourceName: string): AsyncTask_LoadXRDeviceVisComponent;
	static Find(Outer: UObject, ResourceName: string): AsyncTask_LoadXRDeviceVisComponent;
	static GetDefaultObject(): AsyncTask_LoadXRDeviceVisComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AsyncTask_LoadXRDeviceVisComponent;
	static AddNamedDeviceVisualizationComponentAsync(Target: Actor,SystemName: string,DeviceName: string,bManualAttachment: boolean,RelativeTransform: Transform,XRDeviceId?: XRDeviceId,NewComponent?: PrimitiveComponent): {XRDeviceId: XRDeviceId, NewComponent: PrimitiveComponent, $: AsyncTask_LoadXRDeviceVisComponent};
	static AddDeviceVisualizationComponentAsync(Target: Actor,XRDeviceId: XRDeviceId,bManualAttachment: boolean,RelativeTransform: Transform,NewComponent?: PrimitiveComponent): {NewComponent: PrimitiveComponent, $: AsyncTask_LoadXRDeviceVisComponent};
	static C(Other: UObject | any): AsyncTask_LoadXRDeviceVisComponent;
}

declare class XRLoadingScreenFunctionLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): XRLoadingScreenFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): XRLoadingScreenFunctionLibrary;
	static GetDefaultObject(): XRLoadingScreenFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): XRLoadingScreenFunctionLibrary;
	static ShowLoadingScreen(): void;
	static SetLoadingScreen(Texture: Texture,Scale: Vector2D,Offset: Vector,bShowLoadingMovie: boolean,bShowOnSet: boolean): void;
	static HideLoadingScreen(): void;
	static ClearLoadingScreenSplashes(): void;
	static AddLoadingScreenSplash(Texture: Texture,Translation: Vector,Rotation: Rotator,Size: Vector2D,DeltaRotation: Rotator,bClearBeforeAdd: boolean): void;
	static C(Other: UObject | any): XRLoadingScreenFunctionLibrary;
}

declare type EAudioDeviceChangedRole = 'Invalid' | 'Console' | 'Multimedia' | 'Communications' | 'Count' | 'EAudioDeviceChangedRole_MAX';
declare var EAudioDeviceChangedRole : { Invalid:'Invalid',Console:'Console',Multimedia:'Multimedia',Communications:'Communications',Count:'Count',EAudioDeviceChangedRole_MAX:'EAudioDeviceChangedRole_MAX', };
declare type EAudioDeviceChangedState = 'Invalid' | 'Active' | 'Disabled' | 'NotPresent' | 'Unplugged' | 'Count' | 'EAudioDeviceChangedState_MAX';
declare var EAudioDeviceChangedState : { Invalid:'Invalid',Active:'Active',Disabled:'Disabled',NotPresent:'NotPresent',Unplugged:'Unplugged',Count:'Count',EAudioDeviceChangedState_MAX:'EAudioDeviceChangedState_MAX', };
declare class AudioDeviceNotificationSubsystem extends EngineSubsystem { 
	DefaultCaptureDeviceChanged: UnrealEngineMulticastDelegate<(AudioDeviceRole: EAudioDeviceChangedRole, DeviceID: string) => void>;
	DefaultRenderDeviceChanged: UnrealEngineMulticastDelegate<(AudioDeviceRole: EAudioDeviceChangedRole, DeviceID: string) => void>;
	DeviceAdded: UnrealEngineMulticastDelegate<(DeviceID: string) => void>;
	DeviceRemoved: UnrealEngineMulticastDelegate<(DeviceID: string) => void>;
	DeviceStateChanged: UnrealEngineMulticastDelegate<(DeviceID: string, NewState: EAudioDeviceChangedState) => void>;
	DeviceSwitched: UnrealEngineMulticastDelegate<(DeviceID: string) => void>;
	static Load(ResourceName: string): AudioDeviceNotificationSubsystem;
	static Find(Outer: UObject, ResourceName: string): AudioDeviceNotificationSubsystem;
	static GetDefaultObject(): AudioDeviceNotificationSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioDeviceNotificationSubsystem;
	static C(Other: UObject | any): AudioDeviceNotificationSubsystem;
}

declare class SoundNode extends UObject { 
	ChildNodes: SoundNode[];
	GraphNode: EdGraphNode;
	static Load(ResourceName: string): SoundNode;
	static Find(Outer: UObject, ResourceName: string): SoundNode;
	static GetDefaultObject(): SoundNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNode;
	static C(Other: UObject | any): SoundNode;
}

declare class SoundCue extends SoundBase { 
	FirstNode: SoundNode;
	VolumeMultiplier: number;
	PitchMultiplier: number;
	AttenuationOverrides: SoundAttenuationSettings;
	AllNodes: SoundNode[];
	SoundCueGraph: EdGraph;
	SubtitlePriority: number;
	bPrimeOnLoad: boolean;
	bOverrideAttenuation: boolean;
	bExcludeFromRandomNodeBranchCulling: boolean;
	bHasPlayWhenSilent: boolean;
	CookedQualityIndex: number;
	static Load(ResourceName: string): SoundCue;
	static Find(Outer: UObject, ResourceName: string): SoundCue;
	static GetDefaultObject(): SoundCue;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundCue;
	static C(Other: UObject | any): SoundCue;
	PrimeSoundCueForPlayback(): void;
	static PrimeSoundCueForPlayback(SoundCue: SoundCue): void;
}

declare type EAudioSpectrumBandPresetType = 'KickDrum' | 'SnareDrum' | 'Voice' | 'Cymbals' | 'EAudioSpectrumBandPresetType_MAX';
declare var EAudioSpectrumBandPresetType : { KickDrum:'KickDrum',SnareDrum:'SnareDrum',Voice:'Voice',Cymbals:'Cymbals',EAudioSpectrumBandPresetType_MAX:'EAudioSpectrumBandPresetType_MAX', };
declare class SoundSubmixSpectralAnalysisBandSettings { 
	BandFrequency: number;
	AttackTimeMsec: number;
	ReleaseTimeMsec: number;
	QFactor: number;
	clone() : SoundSubmixSpectralAnalysisBandSettings;
	static C(Other: UObject | any): SoundSubmixSpectralAnalysisBandSettings;
}

declare type EMusicalNoteName = 'C' | 'Db' | 'D' | 'Eb' | 'E' | 'F' | 'Gb' | 'G' | 'Ab' | 'A' | 'Bb' | 'B' | 'EMusicalNoteName_MAX';
declare var EMusicalNoteName : { C:'C',Db:'Db',D:'D',Eb:'Eb',E:'E',F:'F',Gb:'Gb',G:'G',Ab:'Ab',A:'A',Bb:'Bb',B:'B',EMusicalNoteName_MAX:'EMusicalNoteName_MAX', };
declare class AudioMixerBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): AudioMixerBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): AudioMixerBlueprintLibrary;
	static GetDefaultObject(): AudioMixerBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioMixerBlueprintLibrary;
	static TrimAudioCache(InMegabytesToFree: number): number;
	static StopRecordingOutput(WorldContextObject: UObject,ExportType: EAudioRecordingExportType,Name: string,Path: string,SubmixToRecord: SoundSubmix,ExistingSoundWaveToOverwrite: SoundWave): SoundWave;
	static StopAudioBus(WorldContextObject: UObject,AudioBus: AudioBus): void;
	static StopAnalyzingOutput(WorldContextObject: UObject,SubmixToStopAnalyzing: SoundSubmix): void;
	static StartRecordingOutput(WorldContextObject: UObject,ExpectedDuration: number,SubmixToRecord: SoundSubmix): void;
	static StartAudioBus(WorldContextObject: UObject,AudioBus: AudioBus): void;
	static StartAnalyzingOutput(WorldContextObject: UObject,SubmixToAnalyze: SoundSubmix,FFTSize: EFFTSize,InterpolationMethod: EFFTPeakInterpolationMethod,WindowType: EFFTWindowType,HopSize: number,SpectrumType: EAudioSpectrumType): void;
	static SetSubmixEffectChainOverride(WorldContextObject: UObject,SoundSubmix: SoundSubmix,SubmixEffectPresetChain: SoundEffectSubmixPreset[],FadeTimeSec: number): void;
	static SetBypassSourceEffectChainEntry(WorldContextObject: UObject,PresetChain: SoundEffectSourcePresetChain,EntryIndex: number,bBypassed: boolean): void;
	static ResumeRecordingOutput(WorldContextObject: UObject,SubmixToPause: SoundSubmix): void;
	static ReplaceSubmixEffect(WorldContextObject: UObject,InSoundSubmix: SoundSubmix,SubmixChainIndex: number,SubmixEffectPreset: SoundEffectSubmixPreset): void;
	static ReplaceSoundEffectSubmix(WorldContextObject: UObject,InSoundSubmix: SoundSubmix,SubmixChainIndex: number,SubmixEffectPreset: SoundEffectSubmixPreset): void;
	static RemoveSubmixEffectPresetAtIndex(WorldContextObject: UObject,SoundSubmix: SoundSubmix,SubmixChainIndex: number): void;
	static RemoveSubmixEffectPreset(WorldContextObject: UObject,SoundSubmix: SoundSubmix,SubmixEffectPreset: SoundEffectSubmixPreset): void;
	static RemoveSubmixEffectAtIndex(WorldContextObject: UObject,SoundSubmix: SoundSubmix,SubmixChainIndex: number): void;
	static RemoveSubmixEffect(WorldContextObject: UObject,SoundSubmix: SoundSubmix,SubmixEffectPreset: SoundEffectSubmixPreset): void;
	static RemoveSourceEffectFromPresetChain(WorldContextObject: UObject,PresetChain: SoundEffectSourcePresetChain,EntryIndex: number): void;
	static RemoveMasterSubmixEffect(WorldContextObject: UObject,SubmixEffectPreset: SoundEffectSubmixPreset): void;
	static PrimeSoundCueForPlayback(SoundCue: SoundCue): void;
	static PauseRecordingOutput(WorldContextObject: UObject,SubmixToPause: SoundSubmix): void;
	static MakePresetSpectralAnalysisBandSettings(InBandPresetType: EAudioSpectrumBandPresetType,InNumBands: number,InAttackTimeMsec: number,InReleaseTimeMsec: number): SoundSubmixSpectralAnalysisBandSettings[];
	static MakeMusicalSpectralAnalysisBandSettings(InNumSemitones: number,InStartingMusicalNote: EMusicalNoteName,InStartingOctave: number,InAttackTimeMsec: number,InReleaseTimeMsec: number): SoundSubmixSpectralAnalysisBandSettings[];
	static MakeFullSpectrumSpectralAnalysisBandSettings(InNumBands: number,InMinimumFrequency: number,InMaximumFrequency: number,InAttackTimeMsec: number,InReleaseTimeMsec: number): SoundSubmixSpectralAnalysisBandSettings[];
	static IsAudioBusActive(WorldContextObject: UObject,AudioBus: AudioBus): boolean;
	static GetPhaseForFrequencies(WorldContextObject: UObject,Frequencies: number[],Phases?: number[],SubmixToAnalyze?: SoundSubmix): {Phases: number[]};
	static GetNumberOfEntriesInSourceEffectChain(WorldContextObject: UObject,PresetChain: SoundEffectSourcePresetChain): number;
	static GetMagnitudeForFrequencies(WorldContextObject: UObject,Frequencies: number[],Magnitudes?: number[],SubmixToAnalyze?: SoundSubmix): {Magnitudes: number[]};
	static Conv_AudioOutputDeviceInfoToString(Info: AudioOutputDeviceInfo): string;
	static ClearSubmixEffects(WorldContextObject: UObject,SoundSubmix: SoundSubmix): void;
	static ClearSubmixEffectChainOverride(WorldContextObject: UObject,SoundSubmix: SoundSubmix,FadeTimeSec: number): void;
	static ClearMasterSubmixEffects(WorldContextObject: UObject): void;
	static AddSubmixEffect(WorldContextObject: UObject,SoundSubmix: SoundSubmix,SubmixEffectPreset: SoundEffectSubmixPreset): number;
	static AddSourceEffectToPresetChain(WorldContextObject: UObject,PresetChain: SoundEffectSourcePresetChain,Entry: SourceEffectChainEntry): void;
	static AddMasterSubmixEffect(WorldContextObject: UObject,SubmixEffectPreset: SoundEffectSubmixPreset): void;
	static C(Other: UObject | any): AudioMixerBlueprintLibrary;
}

declare class SoundWaveProcedural extends SoundWave { 
	static Load(ResourceName: string): SoundWaveProcedural;
	static Find(Outer: UObject, ResourceName: string): SoundWaveProcedural;
	static GetDefaultObject(): SoundWaveProcedural;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundWaveProcedural;
	static C(Other: UObject | any): SoundWaveProcedural;
}

declare class SynthComponent extends SceneComponent { 
	bAutoDestroy: boolean;
	bStopWhenOwnerDestroyed: boolean;
	bAllowSpatialization: boolean;
	bOverrideAttenuation: boolean;
	bOutputToBusOnly: boolean;
	bEnableBusSends: boolean;
	bEnableBaseSubmix: boolean;
	bEnableSubmixSends: boolean;
	AttenuationSettings: SoundAttenuation;
	AttenuationOverrides: SoundAttenuationSettings;
	ConcurrencySettings: SoundConcurrency;
	ConcurrencySet: Set<SoundConcurrency>;
	SoundClass: SoundClass;
	SourceEffectChain: SoundEffectSourcePresetChain;
	SoundSubmix: SoundSubmixBase;
	SoundSubmixSends: SoundSubmixSendInfo[];
	BusSends: SoundSourceBusSendInfo[];
	PreEffectBusSends: SoundSourceBusSendInfo[];
	bIsUISound: boolean;
	bIsPreviewSound: boolean;
	EnvelopeFollowerAttackTime: number;
	EnvelopeFollowerReleaseTime: number;
	OnAudioEnvelopeValue: UnrealEngineMulticastDelegate<(EnvelopeValue: number) => void>;
	Synth: SynthSound;
	AudioComponent: AudioComponent;
	static Load(ResourceName: string): SynthComponent;
	static Find(Outer: UObject, ResourceName: string): SynthComponent;
	static GetDefaultObject(): SynthComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SynthComponent;
	Stop(): void;
	Start(): void;
	SetVolumeMultiplier(VolumeMultiplier: number): void;
	SetSubmixSend(Submix: SoundSubmixBase,SendLevel: number): void;
	SetOutputToBusOnly(bInOutputToBusOnly: boolean): void;
	SetLowPassFilterFrequency(InLowPassFilterFrequency: number): void;
	SetLowPassFilterEnabled(InLowPassFilterEnabled: boolean): void;
	IsPlaying(): boolean;
	FadeOut(FadeOutDuration: number,FadeVolumeLevel: number,FadeCurve: EAudioFaderCurve): void;
	FadeIn(FadeInDuration: number,FadeVolumeLevel: number,StartTime: number,FadeCurve: EAudioFaderCurve): void;
	AdjustVolume(AdjustVolumeDuration: number,AdjustVolumeLevel: number,FadeCurve: EAudioFaderCurve): void;
	static C(Other: UObject | any): SynthComponent;
}

declare class SynthSound extends SoundWaveProcedural { 
	OwningSynthComponent: SynthComponent;
	static Load(ResourceName: string): SynthSound;
	static Find(Outer: UObject, ResourceName: string): SynthSound;
	static GetDefaultObject(): SynthSound;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SynthSound;
	static C(Other: UObject | any): SynthSound;
}

declare type ESubmixEffectDynamicsProcessorType = 'Compressor' | 'Limiter' | 'Expander' | 'Gate' | 'UpwardsCompressor' | 'Count' | 'ESubmixEffectDynamicsProcessorType_MAX';
declare var ESubmixEffectDynamicsProcessorType : { Compressor:'Compressor',Limiter:'Limiter',Expander:'Expander',Gate:'Gate',UpwardsCompressor:'UpwardsCompressor',Count:'Count',ESubmixEffectDynamicsProcessorType_MAX:'ESubmixEffectDynamicsProcessorType_MAX', };
declare type ESubmixEffectDynamicsPeakMode = 'MeanSquared' | 'RootMeanSquared' | 'Peak' | 'Count' | 'ESubmixEffectDynamicsPeakMode_MAX';
declare var ESubmixEffectDynamicsPeakMode : { MeanSquared:'MeanSquared',RootMeanSquared:'RootMeanSquared',Peak:'Peak',Count:'Count',ESubmixEffectDynamicsPeakMode_MAX:'ESubmixEffectDynamicsPeakMode_MAX', };
declare type ESubmixEffectDynamicsChannelLinkMode = 'Disabled' | 'Average' | 'Peak' | 'Count' | 'ESubmixEffectDynamicsChannelLinkMode_MAX';
declare var ESubmixEffectDynamicsChannelLinkMode : { Disabled:'Disabled',Average:'Average',Peak:'Peak',Count:'Count',ESubmixEffectDynamicsChannelLinkMode_MAX:'ESubmixEffectDynamicsChannelLinkMode_MAX', };
declare type ESubmixEffectDynamicsKeySource = 'Default' | 'AudioBus' | 'Submix' | 'Count' | 'ESubmixEffectDynamicsKeySource_MAX';
declare var ESubmixEffectDynamicsKeySource : { Default:'Default',AudioBus:'AudioBus',Submix:'Submix',Count:'Count',ESubmixEffectDynamicsKeySource_MAX:'ESubmixEffectDynamicsKeySource_MAX', };
declare class SubmixEffectDynamicProcessorFilterSettings { 
	bEnabled: boolean;
	Cutoff: number;
	GainDb: number;
	clone() : SubmixEffectDynamicProcessorFilterSettings;
	static C(Other: UObject | any): SubmixEffectDynamicProcessorFilterSettings;
}

declare class SubmixEffectDynamicsProcessorSettings { 
	DynamicsProcessorType: ESubmixEffectDynamicsProcessorType;
	PeakMode: ESubmixEffectDynamicsPeakMode;
	LinkMode: ESubmixEffectDynamicsChannelLinkMode;
	InputGainDb: number;
	ThresholdDb: number;
	Ratio: number;
	KneeBandwidthDb: number;
	LookAheadMsec: number;
	AttackTimeMsec: number;
	ReleaseTimeMsec: number;
	KeySource: ESubmixEffectDynamicsKeySource;
	ExternalAudioBus: AudioBus;
	ExternalSubmix: SoundSubmix;
	bChannelLinked: boolean;
	bAnalogMode: boolean;
	bBypass: boolean;
	bKeyAudition: boolean;
	KeyGainDb: number;
	OutputGainDb: number;
	KeyHighshelf: SubmixEffectDynamicProcessorFilterSettings;
	KeyLowshelf: SubmixEffectDynamicProcessorFilterSettings;
	clone() : SubmixEffectDynamicsProcessorSettings;
	static C(Other: UObject | any): SubmixEffectDynamicsProcessorSettings;
}

declare class SubmixEffectDynamicsProcessorPreset extends SoundEffectSubmixPreset { 
	Settings: SubmixEffectDynamicsProcessorSettings;
	static Load(ResourceName: string): SubmixEffectDynamicsProcessorPreset;
	static Find(Outer: UObject, ResourceName: string): SubmixEffectDynamicsProcessorPreset;
	static GetDefaultObject(): SubmixEffectDynamicsProcessorPreset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubmixEffectDynamicsProcessorPreset;
	SetSettings(Settings: SubmixEffectDynamicsProcessorSettings): void;
	SetExternalSubmix(Submix: SoundSubmix): void;
	SetAudioBus(AudioBus: AudioBus): void;
	ResetKey(): void;
	static C(Other: UObject | any): SubmixEffectDynamicsProcessorPreset;
}

declare class SubmixEffectEQBand { 
	Frequency: number;
	Bandwidth: number;
	GainDb: number;
	bEnabled: boolean;
	clone() : SubmixEffectEQBand;
	static C(Other: UObject | any): SubmixEffectEQBand;
}

declare class SubmixEffectSubmixEQSettings { 
	EQBands: SubmixEffectEQBand[];
	clone() : SubmixEffectSubmixEQSettings;
	static C(Other: UObject | any): SubmixEffectSubmixEQSettings;
}

declare class SubmixEffectSubmixEQPreset extends SoundEffectSubmixPreset { 
	Settings: SubmixEffectSubmixEQSettings;
	static Load(ResourceName: string): SubmixEffectSubmixEQPreset;
	static Find(Outer: UObject, ResourceName: string): SubmixEffectSubmixEQPreset;
	static GetDefaultObject(): SubmixEffectSubmixEQPreset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubmixEffectSubmixEQPreset;
	SetSettings(InSettings: SubmixEffectSubmixEQSettings): void;
	static C(Other: UObject | any): SubmixEffectSubmixEQPreset;
}

declare class SubmixEffectReverbSettings { 
	bBypassEarlyReflections: boolean;
	ReflectionsDelay: number;
	GainHF: number;
	ReflectionsGain: number;
	bBypassLateReflections: boolean;
	LateDelay: number;
	DecayTime: number;
	Density: number;
	Diffusion: number;
	AirAbsorptionGainHF: number;
	DecayHFRatio: number;
	LateGain: number;
	Gain: number;
	WetLevel: number;
	DryLevel: number;
	bBypass: boolean;
	clone() : SubmixEffectReverbSettings;
	static C(Other: UObject | any): SubmixEffectReverbSettings;
}

declare class SubmixEffectReverbPreset extends SoundEffectSubmixPreset { 
	Settings: SubmixEffectReverbSettings;
	static Load(ResourceName: string): SubmixEffectReverbPreset;
	static Find(Outer: UObject, ResourceName: string): SubmixEffectReverbPreset;
	static GetDefaultObject(): SubmixEffectReverbPreset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubmixEffectReverbPreset;
	SetSettingsWithReverbEffect(InReverbEffect: ReverbEffect,WetLevel: number,DryLevel: number): void;
	SetSettings(InSettings: SubmixEffectReverbSettings): void;
	static C(Other: UObject | any): SubmixEffectReverbPreset;
}

declare class AudioGenerator extends UObject { 
	static Load(ResourceName: string): AudioGenerator;
	static Find(Outer: UObject, ResourceName: string): AudioGenerator;
	static GetDefaultObject(): AudioGenerator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioGenerator;
	static C(Other: UObject | any): AudioGenerator;
}

declare type EQuartzCommandQuantization = 'Bar' | 'Beat' | 'ThirtySecondNote' | 'SixteenthNote' | 'EighthNote' | 'QuarterNote' | 'HalfNote' | 'WholeNote' | 'DottedSixteenthNote' | 'DottedEighthNote' | 'DottedQuarterNote' | 'DottedHalfNote' | 'DottedWholeNote' | 'SixteenthNoteTriplet' | 'EighthNoteTriplet' | 'QuarterNoteTriplet' | 'HalfNoteTriplet' | 'Tick' | 'Count' | 'None' | 'EQuartzCommandQuantization_MAX';
declare var EQuartzCommandQuantization : { Bar:'Bar',Beat:'Beat',ThirtySecondNote:'ThirtySecondNote',SixteenthNote:'SixteenthNote',EighthNote:'EighthNote',QuarterNote:'QuarterNote',HalfNote:'HalfNote',WholeNote:'WholeNote',DottedSixteenthNote:'DottedSixteenthNote',DottedEighthNote:'DottedEighthNote',DottedQuarterNote:'DottedQuarterNote',DottedHalfNote:'DottedHalfNote',DottedWholeNote:'DottedWholeNote',SixteenthNoteTriplet:'SixteenthNoteTriplet',EighthNoteTriplet:'EighthNoteTriplet',QuarterNoteTriplet:'QuarterNoteTriplet',HalfNoteTriplet:'HalfNoteTriplet',Tick:'Tick',Count:'Count',None:'None',EQuartzCommandQuantization_MAX:'EQuartzCommandQuantization_MAX', };
declare class QuartzTransportTimeStamp { 
	Bars: number;
	Beat: number;
	BeatFraction: number;
	Seconds: number;
	clone() : QuartzTransportTimeStamp;
	static C(Other: UObject | any): QuartzTransportTimeStamp;
}

declare class QuartzClockHandle extends UObject { 
	static Load(ResourceName: string): QuartzClockHandle;
	static Find(Outer: UObject, ResourceName: string): QuartzClockHandle;
	static GetDefaultObject(): QuartzClockHandle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): QuartzClockHandle;
	UnsubscribeFromTimeDivision(WorldContextObject: UObject,InQuantizationBoundary: EQuartzCommandQuantization,ClockHandle?: QuartzClockHandle): {ClockHandle: QuartzClockHandle};
	UnsubscribeFromAllTimeDivisions(WorldContextObject: UObject,ClockHandle?: QuartzClockHandle): {ClockHandle: QuartzClockHandle};
	StopClock(WorldContextObject: UObject,CancelPendingEvents: boolean,ClockHandle?: QuartzClockHandle): {ClockHandle: QuartzClockHandle};
	StartClock(WorldContextObject: UObject,ClockHandle?: QuartzClockHandle): {ClockHandle: QuartzClockHandle};
	ResumeClock(WorldContextObject: UObject,ClockHandle?: QuartzClockHandle): {ClockHandle: QuartzClockHandle};
	PauseClock(WorldContextObject: UObject,ClockHandle?: QuartzClockHandle): {ClockHandle: QuartzClockHandle};
	IsClockRunning(WorldContextObject: UObject): boolean;
	GetTicksPerSecond(WorldContextObject: UObject): number;
	GetThirtySecondNotesPerMinute(WorldContextObject: UObject): number;
	GetSecondsPerTick(WorldContextObject: UObject): number;
	GetMillisecondsPerTick(WorldContextObject: UObject): number;
	GetEstimatedRunTime(WorldContextObject: UObject): number;
	GetDurationOfQuantizationTypeInSeconds(WorldContextObject: UObject,QuantizationType: EQuartzCommandQuantization,Multiplier: number): number;
	GetCurrentTimestamp(WorldContextObject: UObject): QuartzTransportTimeStamp;
	GetBeatsPerMinute(WorldContextObject: UObject): number;
	static C(Other: UObject | any): QuartzClockHandle;
}

declare class TickableWorldSubsystem extends WorldSubsystem { 
	static Load(ResourceName: string): TickableWorldSubsystem;
	static Find(Outer: UObject, ResourceName: string): TickableWorldSubsystem;
	static GetDefaultObject(): TickableWorldSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TickableWorldSubsystem;
	static C(Other: UObject | any): TickableWorldSubsystem;
}

declare type EQuartzTimeSignatureQuantization = 'HalfNote' | 'QuarterNote' | 'EighthNote' | 'SixteenthNote' | 'ThirtySecondNote' | 'Count' | 'EQuartzTimeSignatureQuantization_MAX';
declare var EQuartzTimeSignatureQuantization : { HalfNote:'HalfNote',QuarterNote:'QuarterNote',EighthNote:'EighthNote',SixteenthNote:'SixteenthNote',ThirtySecondNote:'ThirtySecondNote',Count:'Count',EQuartzTimeSignatureQuantization_MAX:'EQuartzTimeSignatureQuantization_MAX', };
declare class QuartzPulseOverrideStep { 
	NumberOfPulses: number;
	PulseDuration: EQuartzCommandQuantization;
	clone() : QuartzPulseOverrideStep;
	static C(Other: UObject | any): QuartzPulseOverrideStep;
}

declare class QuartzTimeSignature { 
	NumBeats: number;
	BeatType: EQuartzTimeSignatureQuantization;
	OptionalPulseOverride: QuartzPulseOverrideStep[];
	clone() : QuartzTimeSignature;
	static C(Other: UObject | any): QuartzTimeSignature;
}

declare class QuartzClockSettings { 
	TimeSignature: QuartzTimeSignature;
	bIgnoreLevelChange: boolean;
	clone() : QuartzClockSettings;
	static C(Other: UObject | any): QuartzClockSettings;
}

declare class QuartzSubsystem extends TickableWorldSubsystem { 
	static Load(ResourceName: string): QuartzSubsystem;
	static Find(Outer: UObject, ResourceName: string): QuartzSubsystem;
	static GetDefaultObject(): QuartzSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): QuartzSubsystem;
	IsQuartzEnabled(): boolean;
	IsClockRunning(WorldContextObject: UObject,ClockName: string): boolean;
	GetRoundTripMinLatency(WorldContextObject: UObject): number;
	GetRoundTripMaxLatency(WorldContextObject: UObject): number;
	GetRoundTripAverageLatency(WorldContextObject: UObject): number;
	GetHandleForClock(WorldContextObject: UObject,ClockName: string): QuartzClockHandle;
	GetGameThreadToAudioRenderThreadMinLatency(WorldContextObject: UObject): number;
	GetGameThreadToAudioRenderThreadMaxLatency(WorldContextObject: UObject): number;
	GetGameThreadToAudioRenderThreadAverageLatency(WorldContextObject: UObject): number;
	GetEstimatedClockRunTime(WorldContextObject: UObject,InClockName: string): number;
	GetDurationOfQuantizationTypeInSeconds(WorldContextObject: UObject,ClockName: string,QuantizationType: EQuartzCommandQuantization,Multiplier: number): number;
	GetCurrentClockTimestamp(WorldContextObject: UObject,InClockName: string): QuartzTransportTimeStamp;
	GetAudioRenderThreadToGameThreadMinLatency(): number;
	GetAudioRenderThreadToGameThreadMaxLatency(): number;
	GetAudioRenderThreadToGameThreadAverageLatency(): number;
	DoesClockExist(WorldContextObject: UObject,ClockName: string): boolean;
	DeleteClockByName(WorldContextObject: UObject,ClockName: string): void;
	DeleteClockByHandle(WorldContextObject: UObject,InClockHandle?: QuartzClockHandle): {InClockHandle: QuartzClockHandle};
	CreateNewClock(WorldContextObject: UObject,ClockName: string,InSettings: QuartzClockSettings,bOverrideSettingsIfClockExists: boolean,bUseAudioEngineClockManager: boolean): QuartzClockHandle;
	static C(Other: UObject | any): QuartzSubsystem;
}

declare class MediaPlayerProxyInterface extends Interface { 
	static Load(ResourceName: string): MediaPlayerProxyInterface;
	static Find(Outer: UObject, ResourceName: string): MediaPlayerProxyInterface;
	static GetDefaultObject(): MediaPlayerProxyInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MediaPlayerProxyInterface;
	static C(Other: UObject | any): MediaPlayerProxyInterface;
}

declare type EMediaSoundChannels = 'Mono' | 'Stereo' | 'Surround' | 'EMediaSoundChannels_MAX';
declare var EMediaSoundChannels : { Mono:'Mono',Stereo:'Stereo',Surround:'Surround',EMediaSoundChannels_MAX:'EMediaSoundChannels_MAX', };
declare class MediaSource extends UObject { 
	static Load(ResourceName: string): MediaSource;
	static Find(Outer: UObject, ResourceName: string): MediaSource;
	static GetDefaultObject(): MediaSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MediaSource;
	Validate(): boolean;
	SetMediaOptionString(Key: string,Value: string): void;
	SetMediaOptionInt64(Key: string,Value: number): void;
	SetMediaOptionFloat(Key: string,Value: number): void;
	SetMediaOptionBool(Key: string,Value: boolean): void;
	GetUrl(): string;
	static C(Other: UObject | any): MediaSource;
}

declare class MediaPlaylist extends UObject { 
	Items: MediaSource[];
	static Load(ResourceName: string): MediaPlaylist;
	static Find(Outer: UObject, ResourceName: string): MediaPlaylist;
	static GetDefaultObject(): MediaPlaylist;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MediaPlaylist;
	Replace(Index: number,Replacement: MediaSource): boolean;
	RemoveAt(Index: number): boolean;
	Remove(MediaSource: MediaSource): boolean;
	Num(): number;
	Insert(MediaSource: MediaSource,Index: number): void;
	GetRandom(OutIndex?: number): {OutIndex: number, $: MediaSource};
	GetPrevious(InOutIndex?: number): {InOutIndex: number, $: MediaSource};
	GetNext(InOutIndex?: number): {InOutIndex: number, $: MediaSource};
	Get(Index: number): MediaSource;
	AddUrl(URL: string): boolean;
	AddFile(FilePath: string): boolean;
	Add(MediaSource: MediaSource): boolean;
	static C(Other: UObject | any): MediaPlaylist;
}

declare type EMediaPlayerTrack = 'Audio' | 'Caption' | 'Metadata' | 'Script' | 'Subtitle' | 'Text' | 'Video' | 'EMediaPlayerTrack_MAX';
declare var EMediaPlayerTrack : { Audio:'Audio',Caption:'Caption',Metadata:'Metadata',Script:'Script',Subtitle:'Subtitle',Text:'Text',Video:'Video',EMediaPlayerTrack_MAX:'EMediaPlayerTrack_MAX', };
declare class MediaPlayerTrackOptions { 
	Audio: number;
	Caption: number;
	MetaData: number;
	Script: number;
	Subtitle: number;
	Text: number;
	Video: number;
	clone() : MediaPlayerTrackOptions;
	static C(Other: UObject | any): MediaPlayerTrackOptions;
}

declare type EMediaPlayerOptionBooleanOverride = 'UseMediaPlayerSetting' | 'Enabled' | 'Disabled' | 'EMediaPlayerOptionBooleanOverride_MAX';
declare var EMediaPlayerOptionBooleanOverride : { UseMediaPlayerSetting:'UseMediaPlayerSetting',Enabled:'Enabled',Disabled:'Disabled',EMediaPlayerOptionBooleanOverride_MAX:'EMediaPlayerOptionBooleanOverride_MAX', };
declare class MediaPlayerOptions { 
	Tracks: MediaPlayerTrackOptions;
	SeekTime: Timespan;
	PlayOnOpen: EMediaPlayerOptionBooleanOverride;
	loop: EMediaPlayerOptionBooleanOverride;
	clone() : MediaPlayerOptions;
	static C(Other: UObject | any): MediaPlayerOptions;
}

declare class MediaTimeStampInfo extends UObject { 
	Time: Timespan;
	SequenceIndex: number;
	static Load(ResourceName: string): MediaTimeStampInfo;
	static Find(Outer: UObject, ResourceName: string): MediaTimeStampInfo;
	static GetDefaultObject(): MediaTimeStampInfo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MediaTimeStampInfo;
	static C(Other: UObject | any): MediaTimeStampInfo;
}

declare class MediaPlayer extends UObject { 
	OnEndReached: UnrealEngineMulticastDelegate<() => void>;
	OnMediaClosed: UnrealEngineMulticastDelegate<() => void>;
	OnMediaOpened: UnrealEngineMulticastDelegate<(OpenedUrl: string) => void>;
	OnMediaOpenFailed: UnrealEngineMulticastDelegate<(FailedUrl: string) => void>;
	OnPlaybackResumed: UnrealEngineMulticastDelegate<() => void>;
	OnPlaybackSuspended: UnrealEngineMulticastDelegate<() => void>;
	OnSeekCompleted: UnrealEngineMulticastDelegate<() => void>;
	OnTracksChanged: UnrealEngineMulticastDelegate<() => void>;
	CacheAhead: Timespan;
	CacheBehind: Timespan;
	CacheBehindGame: Timespan;
	NativeAudioOut: boolean;
	PlayOnOpen: boolean;
	Shuffle: boolean;
	loop: boolean;
	Playlist: MediaPlaylist;
	PlaylistIndex: number;
	TimeDelay: Timespan;
	HorizontalFieldOfView: number;
	VerticalFieldOfView: number;
	ViewRotation: Rotator;
	PlayerGuid: Guid;
	AffectedByPIEHandling: boolean;
	static Load(ResourceName: string): MediaPlayer;
	static Find(Outer: UObject, ResourceName: string): MediaPlayer;
	static GetDefaultObject(): MediaPlayer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MediaPlayer;
	SupportsSeeking(): boolean;
	SupportsScrubbing(): boolean;
	SupportsRate(Rate: number,Unthinned: boolean): boolean;
	SetViewRotation(Rotation: Rotator,Absolute: boolean): boolean;
	SetViewField(Horizontal: number,Vertical: number,Absolute: boolean): boolean;
	SetVideoTrackFrameRate(TrackIndex: number,FormatIndex: number,FrameRate: number): boolean;
	SetTrackFormat(TrackType: EMediaPlayerTrack,TrackIndex: number,FormatIndex: number): boolean;
	SetTimeDelay(TimeDelay: Timespan): void;
	SetRate(Rate: number): boolean;
	SetNativeVolume(Volume: number): boolean;
	SetMediaOptions(Options: MediaSource): void;
	SetLooping(Looping: boolean): boolean;
	SetDesiredPlayerName(PlayerName: string): void;
	SetBlockOnTime(Time: Timespan): void;
	SelectTrack(TrackType: EMediaPlayerTrack,TrackIndex: number): boolean;
	Seek(Time: Timespan): boolean;
	Rewind(): boolean;
	Reopen(): boolean;
	Previous(): boolean;
	PlayAndSeek(): void;
	Play(): boolean;
	Pause(): boolean;
	OpenUrl(URL: string): boolean;
	OpenSourceWithOptions(MediaSource: MediaSource,Options: MediaPlayerOptions): boolean;
	OpenSourceLatent(WorldContextObject: UObject,LatentInfo: LatentActionInfo,MediaSource: MediaSource,Options: MediaPlayerOptions,bSuccess?: boolean): {bSuccess: boolean};
	OpenSource(MediaSource: MediaSource): boolean;
	OpenPlaylistIndex(InPlaylist: MediaPlaylist,Index: number): boolean;
	OpenPlaylist(InPlaylist: MediaPlaylist): boolean;
	OpenFile(FilePath: string): boolean;
	Next(): boolean;
	IsReady(): boolean;
	IsPreparing(): boolean;
	IsPlaying(): boolean;
	IsPaused(): boolean;
	IsLooping(): boolean;
	IsConnecting(): boolean;
	IsClosed(): boolean;
	IsBuffering(): boolean;
	HasError(): boolean;
	GetViewRotation(): Rotator;
	GetVideoTrackType(TrackIndex: number,FormatIndex: number): string;
	GetVideoTrackFrameRates(TrackIndex: number,FormatIndex: number): FloatRange;
	GetVideoTrackFrameRate(TrackIndex: number,FormatIndex: number): number;
	GetVideoTrackDimensions(TrackIndex: number,FormatIndex: number): IntPoint;
	GetVideoTrackAspectRatio(TrackIndex: number,FormatIndex: number): number;
	GetVerticalFieldOfView(): number;
	GetUrl(): string;
	GetTrackLanguage(TrackType: EMediaPlayerTrack,TrackIndex: number): string;
	GetTrackFormat(TrackType: EMediaPlayerTrack,TrackIndex: number): number;
	GetTrackDisplayName(TrackType: EMediaPlayerTrack,TrackIndex: number): string;
	GetTimeStamp(): MediaTimeStampInfo;
	GetTimeDelay(): Timespan;
	GetTime(): Timespan;
	GetSupportedRates(OutRates?: FloatRange[],Unthinned?: boolean): {OutRates: FloatRange[]};
	GetSelectedTrack(TrackType: EMediaPlayerTrack): number;
	GetRate(): number;
	GetPlaylistIndex(): number;
	GetPlaylist(): MediaPlaylist;
	GetPlayerName(): string;
	GetNumTracks(TrackType: EMediaPlayerTrack): number;
	GetNumTrackFormats(TrackType: EMediaPlayerTrack,TrackIndex: number): number;
	GetMediaName(): string;
	GetHorizontalFieldOfView(): number;
	GetDuration(): Timespan;
	GetDesiredPlayerName(): string;
	GetAudioTrackType(TrackIndex: number,FormatIndex: number): string;
	GetAudioTrackSampleRate(TrackIndex: number,FormatIndex: number): number;
	GetAudioTrackChannels(TrackIndex: number,FormatIndex: number): number;
	Close(): void;
	CanPlayUrl(URL: string): boolean;
	CanPlaySource(MediaSource: MediaSource): boolean;
	CanPause(): boolean;
	static C(Other: UObject | any): MediaPlayer;
}

declare type EMediaSoundComponentFFTSize = 'Min_64' | 'Small_256' | 'Medium_512' | 'Large_1024' | 'EMediaSoundComponentFFTSize_MAX';
declare var EMediaSoundComponentFFTSize : { Min_64:'Min_64',Small_256:'Small_256',Medium_512:'Medium_512',Large_1024:'Large_1024',EMediaSoundComponentFFTSize_MAX:'EMediaSoundComponentFFTSize_MAX', };
declare class MediaSoundComponentSpectralData { 
	FrequencyHz: number;
	Magnitude: number;
	clone() : MediaSoundComponentSpectralData;
	static C(Other: UObject | any): MediaSoundComponentSpectralData;
}

declare class MediaSoundComponent extends SynthComponent { 
	Channels: EMediaSoundChannels;
	DynamicRateAdjustment: boolean;
	RateAdjustmentFactor: number;
	RateAdjustmentRange: FloatRange;
	MediaPlayer: MediaPlayer;
	static Load(ResourceName: string): MediaSoundComponent;
	static Find(Outer: UObject, ResourceName: string): MediaSoundComponent;
	static GetDefaultObject(): MediaSoundComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MediaSoundComponent;
	SetSpectralAnalysisSettings(InFrequenciesToAnalyze: number[],InFFTSize: EMediaSoundComponentFFTSize): void;
	SetMediaPlayer(NewMediaPlayer: MediaPlayer): void;
	SetEnvelopeFollowingsettings(AttackTimeMsec: number,ReleaseTimeMsec: number): void;
	SetEnableSpectralAnalysis(bInSpectralAnalysisEnabled: boolean): void;
	SetEnableEnvelopeFollowing(bInEnvelopeFollowing: boolean): void;
	GetSpectralData(): MediaSoundComponentSpectralData[];
	GetNormalizedSpectralData(): MediaSoundComponentSpectralData[];
	GetMediaPlayer(): MediaPlayer;
	GetEnvelopeValue(): number;
	BP_GetAttenuationSettingsToApply(OutAttenuationSettings?: SoundAttenuationSettings): {OutAttenuationSettings: SoundAttenuationSettings, $: boolean};
	static C(Other: UObject | any): MediaSoundComponent;
}

declare type MediaTextureOutputFormat = 'MTOF_Default' | 'MTOF_SRGB_LINOUT' | 'MTOF_MAX';
declare var MediaTextureOutputFormat : { MTOF_Default:'MTOF_Default',MTOF_SRGB_LINOUT:'MTOF_SRGB_LINOUT',MTOF_MAX:'MTOF_MAX', };
declare type MediaTextureOrientation = 'MTORI_Original' | 'MTORI_CW90' | 'MTORI_CW180' | 'MTORI_CW270' | 'MTORI_MAX';
declare var MediaTextureOrientation : { MTORI_Original:'MTORI_Original',MTORI_CW90:'MTORI_CW90',MTORI_CW180:'MTORI_CW180',MTORI_CW270:'MTORI_CW270',MTORI_MAX:'MTORI_MAX', };
declare class MediaTexture extends Texture { 
	AddressX: TextureAddress;
	AddressY: TextureAddress;
	AutoClear: boolean;
	ClearColor: LinearColor;
	EnableGenMips: boolean;
	NumMips: number;
	NewStyleOutput: boolean;
	OutputFormat: MediaTextureOutputFormat;
	CurrentAspectRatio: number;
	CurrentOrientation: MediaTextureOrientation;
	MediaPlayer: MediaPlayer;
	static Load(ResourceName: string): MediaTexture;
	static Find(Outer: UObject, ResourceName: string): MediaTexture;
	static GetDefaultObject(): MediaTexture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MediaTexture;
	UpdateResource(): void;
	SetMediaPlayer(NewMediaPlayer: MediaPlayer): void;
	GetWidth(): number;
	GetTextureNumMips(): number;
	GetMediaPlayer(): MediaPlayer;
	GetHeight(): number;
	GetAspectRatio(): number;
	static C(Other: UObject | any): MediaTexture;
}

declare class BaseMediaSource extends MediaSource { 
	PlatformPlayerNames: Map<string, string>;
	PlayerName: string;
	static Load(ResourceName: string): BaseMediaSource;
	static Find(Outer: UObject, ResourceName: string): BaseMediaSource;
	static GetDefaultObject(): BaseMediaSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BaseMediaSource;
	static C(Other: UObject | any): BaseMediaSource;
}

declare class FileMediaSource extends BaseMediaSource { 
	FilePath: string;
	PrecacheFile: boolean;
	static Load(ResourceName: string): FileMediaSource;
	static Find(Outer: UObject, ResourceName: string): FileMediaSource;
	static GetDefaultObject(): FileMediaSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FileMediaSource;
	SetFilePath(Path: string): void;
	static C(Other: UObject | any): FileMediaSource;
}

declare class MediaComponent extends ActorComponent { 
	MediaTexture: MediaTexture;
	MediaPlayer: MediaPlayer;
	static Load(ResourceName: string): MediaComponent;
	static Find(Outer: UObject, ResourceName: string): MediaComponent;
	static GetDefaultObject(): MediaComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MediaComponent;
	GetMediaTexture(): MediaTexture;
	GetMediaPlayer(): MediaPlayer;
	static C(Other: UObject | any): MediaComponent;
}

declare class PlatformMediaSource extends MediaSource { 
	PlatformMediaSources: Map<string, MediaSource>;
	MediaSource: MediaSource;
	static Load(ResourceName: string): PlatformMediaSource;
	static Find(Outer: UObject, ResourceName: string): PlatformMediaSource;
	static GetDefaultObject(): PlatformMediaSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlatformMediaSource;
	static C(Other: UObject | any): PlatformMediaSource;
}

declare class StreamMediaSource extends BaseMediaSource { 
	StreamUrl: string;
	static Load(ResourceName: string): StreamMediaSource;
	static Find(Outer: UObject, ResourceName: string): StreamMediaSource;
	static GetDefaultObject(): StreamMediaSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StreamMediaSource;
	static C(Other: UObject | any): StreamMediaSource;
}

declare class TimeSynchronizableMediaSource extends BaseMediaSource { 
	bUseTimeSynchronization: boolean;
	FrameDelay: number;
	TimeDelay: number;
	bAutoDetectInput: boolean;
	static Load(ResourceName: string): TimeSynchronizableMediaSource;
	static Find(Outer: UObject, ResourceName: string): TimeSynchronizableMediaSource;
	static GetDefaultObject(): TimeSynchronizableMediaSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TimeSynchronizableMediaSource;
	static C(Other: UObject | any): TimeSynchronizableMediaSource;
}

declare class MediaCaptureDevice { 
	DisplayName: string;
	URL: string;
	clone() : MediaCaptureDevice;
	static C(Other: UObject | any): MediaCaptureDevice;
}

declare class MediaBlueprintFunctionLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): MediaBlueprintFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): MediaBlueprintFunctionLibrary;
	static GetDefaultObject(): MediaBlueprintFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MediaBlueprintFunctionLibrary;
	static EnumerateWebcamCaptureDevices(OutDevices?: MediaCaptureDevice[],Filter?: number): {OutDevices: MediaCaptureDevice[]};
	static EnumerateVideoCaptureDevices(OutDevices?: MediaCaptureDevice[],Filter?: number): {OutDevices: MediaCaptureDevice[]};
	static EnumerateAudioCaptureDevices(OutDevices?: MediaCaptureDevice[],Filter?: number): {OutDevices: MediaCaptureDevice[]};
	static C(Other: UObject | any): MediaBlueprintFunctionLibrary;
}

declare class EngineCustomTimeStep extends UObject { 
	static Load(ResourceName: string): EngineCustomTimeStep;
	static Find(Outer: UObject, ResourceName: string): EngineCustomTimeStep;
	static GetDefaultObject(): EngineCustomTimeStep;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EngineCustomTimeStep;
	static C(Other: UObject | any): EngineCustomTimeStep;
}

declare class FixedFrameRateCustomTimeStep extends EngineCustomTimeStep { 
	static Load(ResourceName: string): FixedFrameRateCustomTimeStep;
	static Find(Outer: UObject, ResourceName: string): FixedFrameRateCustomTimeStep;
	static GetDefaultObject(): FixedFrameRateCustomTimeStep;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FixedFrameRateCustomTimeStep;
	static C(Other: UObject | any): FixedFrameRateCustomTimeStep;
}

declare class GenlockedCustomTimeStep extends FixedFrameRateCustomTimeStep { 
	bAutoDetectFormat: boolean;
	static Load(ResourceName: string): GenlockedCustomTimeStep;
	static Find(Outer: UObject, ResourceName: string): GenlockedCustomTimeStep;
	static GetDefaultObject(): GenlockedCustomTimeStep;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GenlockedCustomTimeStep;
	static C(Other: UObject | any): GenlockedCustomTimeStep;
}

declare class GenlockedFixedRateCustomTimeStep extends GenlockedCustomTimeStep { 
	FrameRate: FrameRate;
	bShouldBlock: boolean;
	bForceSingleFrameDeltaTime: boolean;
	static Load(ResourceName: string): GenlockedFixedRateCustomTimeStep;
	static Find(Outer: UObject, ResourceName: string): GenlockedFixedRateCustomTimeStep;
	static GetDefaultObject(): GenlockedFixedRateCustomTimeStep;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GenlockedFixedRateCustomTimeStep;
	static C(Other: UObject | any): GenlockedFixedRateCustomTimeStep;
}

declare type ETimecodeProviderSynchronizationState = 'Closed' | 'Error' | 'Synchronized' | 'Synchronizing' | 'ETimecodeProviderSynchronizationState_MAX';
declare var ETimecodeProviderSynchronizationState : { Closed:'Closed',Error:'Error',Synchronized:'Synchronized',Synchronizing:'Synchronizing',ETimecodeProviderSynchronizationState_MAX:'ETimecodeProviderSynchronizationState_MAX', };
declare class TimecodeProvider extends UObject { 
	FrameDelay: number;
	static Load(ResourceName: string): TimecodeProvider;
	static Find(Outer: UObject, ResourceName: string): TimecodeProvider;
	static GetDefaultObject(): TimecodeProvider;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TimecodeProvider;
	GetTimecode(): Timecode;
	GetSynchronizationState(): ETimecodeProviderSynchronizationState;
	GetQualifiedFrameTime(): QualifiedFrameTime;
	GetFrameRate(): FrameRate;
	GetDelayedTimecode(): Timecode;
	GetDelayedQualifiedFrameTime(): QualifiedFrameTime;
	FetchTimecode(OutFrameTime?: QualifiedFrameTime): {OutFrameTime: QualifiedFrameTime, $: boolean};
	FetchAndUpdate(): void;
	static C(Other: UObject | any): TimecodeProvider;
}

declare class GenlockedTimecodeProvider extends TimecodeProvider { 
	bUseGenlockToCount: boolean;
	static Load(ResourceName: string): GenlockedTimecodeProvider;
	static Find(Outer: UObject, ResourceName: string): GenlockedTimecodeProvider;
	static GetDefaultObject(): GenlockedTimecodeProvider;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GenlockedTimecodeProvider;
	static C(Other: UObject | any): GenlockedTimecodeProvider;
}

declare class TimeManagementBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): TimeManagementBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): TimeManagementBlueprintLibrary;
	static GetDefaultObject(): TimeManagementBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TimeManagementBlueprintLibrary;
	static TransformTime(SourceTime: FrameTime,SourceRate: FrameRate,DestinationRate: FrameRate): FrameTime;
	static Subtract_FrameNumberInteger(A: FrameNumber,B: number): FrameNumber;
	static Subtract_FrameNumberFrameNumber(A: FrameNumber,B: FrameNumber): FrameNumber;
	static SnapFrameTimeToRate(SourceTime: FrameTime,SourceRate: FrameRate,SnapToRate: FrameRate): FrameTime;
	static Multiply_SecondsFrameRate(TimeInSeconds: number,FrameRate: FrameRate): FrameTime;
	static Multiply_FrameNumberInteger(A: FrameNumber,B: number): FrameNumber;
	static IsValid_MultipleOf(InFrameRate: FrameRate,OtherFramerate: FrameRate): boolean;
	static IsValid_Framerate(InFrameRate: FrameRate): boolean;
	static GetTimecodeFrameRate(): FrameRate;
	static GetTimecode(): Timecode;
	static Divide_FrameNumberInteger(A: FrameNumber,B: number): FrameNumber;
	static Conv_TimecodeToString(InTimecode: Timecode,bForceSignDisplay: boolean): string;
	static Conv_QualifiedFrameTimeToSeconds(InFrameTime: QualifiedFrameTime): number;
	static Conv_FrameRateToSeconds(InFrameRate: FrameRate): number;
	static Conv_FrameNumberToInteger(InFrameNumber: FrameNumber): number;
	static Add_FrameNumberInteger(A: FrameNumber,B: number): FrameNumber;
	static Add_FrameNumberFrameNumber(A: FrameNumber,B: FrameNumber): FrameNumber;
	static C(Other: UObject | any): TimeManagementBlueprintLibrary;
}

declare class TimeSynchronizationSource extends UObject { 
	bUseForSynchronization: boolean;
	FrameOffset: number;
	static Load(ResourceName: string): TimeSynchronizationSource;
	static Find(Outer: UObject, ResourceName: string): TimeSynchronizationSource;
	static GetDefaultObject(): TimeSynchronizationSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TimeSynchronizationSource;
	static C(Other: UObject | any): TimeSynchronizationSource;
}

declare class MovieSceneChannelOverrideProvider extends Interface { 
	static Load(ResourceName: string): MovieSceneChannelOverrideProvider;
	static Find(Outer: UObject, ResourceName: string): MovieSceneChannelOverrideProvider;
	static GetDefaultObject(): MovieSceneChannelOverrideProvider;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneChannelOverrideProvider;
	static C(Other: UObject | any): MovieSceneChannelOverrideProvider;
}

declare class MovieSceneDeterminismSource extends Interface { 
	static Load(ResourceName: string): MovieSceneDeterminismSource;
	static Find(Outer: UObject, ResourceName: string): MovieSceneDeterminismSource;
	static GetDefaultObject(): MovieSceneDeterminismSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneDeterminismSource;
	static C(Other: UObject | any): MovieSceneDeterminismSource;
}

declare class MovieSceneEvaluationHook extends Interface { 
	static Load(ResourceName: string): MovieSceneEvaluationHook;
	static Find(Outer: UObject, ResourceName: string): MovieSceneEvaluationHook;
	static GetDefaultObject(): MovieSceneEvaluationHook;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneEvaluationHook;
	static C(Other: UObject | any): MovieSceneEvaluationHook;
}

declare class MovieScenePlaybackClient extends Interface { 
	static Load(ResourceName: string): MovieScenePlaybackClient;
	static Find(Outer: UObject, ResourceName: string): MovieScenePlaybackClient;
	static GetDefaultObject(): MovieScenePlaybackClient;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScenePlaybackClient;
	static C(Other: UObject | any): MovieScenePlaybackClient;
}

declare class MovieSceneSequencePlayerObserver extends Interface { 
	static Load(ResourceName: string): MovieSceneSequencePlayerObserver;
	static Find(Outer: UObject, ResourceName: string): MovieSceneSequencePlayerObserver;
	static GetDefaultObject(): MovieSceneSequencePlayerObserver;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneSequencePlayerObserver;
	static C(Other: UObject | any): MovieSceneSequencePlayerObserver;
}

declare class MovieSceneBindingOwnerInterface extends Interface { 
	static Load(ResourceName: string): MovieSceneBindingOwnerInterface;
	static Find(Outer: UObject, ResourceName: string): MovieSceneBindingOwnerInterface;
	static GetDefaultObject(): MovieSceneBindingOwnerInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneBindingOwnerInterface;
	static C(Other: UObject | any): MovieSceneBindingOwnerInterface;
}

declare class MovieSceneChannelOverrideContainer extends MovieSceneSignedObject { 
	static Load(ResourceName: string): MovieSceneChannelOverrideContainer;
	static Find(Outer: UObject, ResourceName: string): MovieSceneChannelOverrideContainer;
	static GetDefaultObject(): MovieSceneChannelOverrideContainer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneChannelOverrideContainer;
	static C(Other: UObject | any): MovieSceneChannelOverrideContainer;
}

declare class MovieSceneKeyProxy extends Interface { 
	static Load(ResourceName: string): MovieSceneKeyProxy;
	static Find(Outer: UObject, ResourceName: string): MovieSceneKeyProxy;
	static GetDefaultObject(): MovieSceneKeyProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneKeyProxy;
	static C(Other: UObject | any): MovieSceneKeyProxy;
}

declare class MovieSceneSequenceTickManagerClient extends Interface { 
	static Load(ResourceName: string): MovieSceneSequenceTickManagerClient;
	static Find(Outer: UObject, ResourceName: string): MovieSceneSequenceTickManagerClient;
	static GetDefaultObject(): MovieSceneSequenceTickManagerClient;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneSequenceTickManagerClient;
	static C(Other: UObject | any): MovieSceneSequenceTickManagerClient;
}

declare class MovieSceneSectionChannelOverrideRegistry extends UObject { 
	Overrides: Map<string, MovieSceneChannelOverrideContainer>;
	static Load(ResourceName: string): MovieSceneSectionChannelOverrideRegistry;
	static Find(Outer: UObject, ResourceName: string): MovieSceneSectionChannelOverrideRegistry;
	static GetDefaultObject(): MovieSceneSectionChannelOverrideRegistry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneSectionChannelOverrideRegistry;
	static C(Other: UObject | any): MovieSceneSectionChannelOverrideRegistry;
}

declare class MovieSceneTrackTemplateProducer extends Interface { 
	static Load(ResourceName: string): MovieSceneTrackTemplateProducer;
	static Find(Outer: UObject, ResourceName: string): MovieSceneTrackTemplateProducer;
	static GetDefaultObject(): MovieSceneTrackTemplateProducer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneTrackTemplateProducer;
	static C(Other: UObject | any): MovieSceneTrackTemplateProducer;
}

declare class MovieSceneEntityProvider extends Interface { 
	static Load(ResourceName: string): MovieSceneEntityProvider;
	static Find(Outer: UObject, ResourceName: string): MovieSceneEntityProvider;
	static GetDefaultObject(): MovieSceneEntityProvider;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneEntityProvider;
	static C(Other: UObject | any): MovieSceneEntityProvider;
}

declare class MovieSceneEntitySystem extends UObject { 
	Linker: MovieSceneEntitySystemLinker;
	static Load(ResourceName: string): MovieSceneEntitySystem;
	static Find(Outer: UObject, ResourceName: string): MovieSceneEntitySystem;
	static GetDefaultObject(): MovieSceneEntitySystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneEntitySystem;
	static C(Other: UObject | any): MovieSceneEntitySystem;
}

declare class MovieSceneBlenderSystem extends MovieSceneEntitySystem { 
	static Load(ResourceName: string): MovieSceneBlenderSystem;
	static Find(Outer: UObject, ResourceName: string): MovieSceneBlenderSystem;
	static GetDefaultObject(): MovieSceneBlenderSystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneBlenderSystem;
	static C(Other: UObject | any): MovieSceneBlenderSystem;
}

declare class MovieSceneEntityInstantiatorSystem extends MovieSceneEntitySystem { 
	static Load(ResourceName: string): MovieSceneEntityInstantiatorSystem;
	static Find(Outer: UObject, ResourceName: string): MovieSceneEntityInstantiatorSystem;
	static GetDefaultObject(): MovieSceneEntityInstantiatorSystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneEntityInstantiatorSystem;
	static C(Other: UObject | any): MovieSceneEntityInstantiatorSystem;
}

declare class MovieSceneGenericBoundObjectInstantiator extends MovieSceneEntityInstantiatorSystem { 
	static Load(ResourceName: string): MovieSceneGenericBoundObjectInstantiator;
	static Find(Outer: UObject, ResourceName: string): MovieSceneGenericBoundObjectInstantiator;
	static GetDefaultObject(): MovieSceneGenericBoundObjectInstantiator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneGenericBoundObjectInstantiator;
	static C(Other: UObject | any): MovieSceneGenericBoundObjectInstantiator;
}

declare class MovieSceneBoundSceneComponentInstantiator extends MovieSceneEntityInstantiatorSystem { 
	static Load(ResourceName: string): MovieSceneBoundSceneComponentInstantiator;
	static Find(Outer: UObject, ResourceName: string): MovieSceneBoundSceneComponentInstantiator;
	static GetDefaultObject(): MovieSceneBoundSceneComponentInstantiator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneBoundSceneComponentInstantiator;
	static C(Other: UObject | any): MovieSceneBoundSceneComponentInstantiator;
}

declare class MovieSceneValueDecomposer extends Interface { 
	static Load(ResourceName: string): MovieSceneValueDecomposer;
	static Find(Outer: UObject, ResourceName: string): MovieSceneValueDecomposer;
	static GetDefaultObject(): MovieSceneValueDecomposer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneValueDecomposer;
	static C(Other: UObject | any): MovieSceneValueDecomposer;
}

declare class MovieSceneEvalTimeSystem extends MovieSceneEntitySystem { 
	static Load(ResourceName: string): MovieSceneEvalTimeSystem;
	static Find(Outer: UObject, ResourceName: string): MovieSceneEvalTimeSystem;
	static GetDefaultObject(): MovieSceneEvalTimeSystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneEvalTimeSystem;
	static C(Other: UObject | any): MovieSceneEvalTimeSystem;
}

declare class MovieSceneEvaluationInstanceKey { 
	clone() : MovieSceneEvaluationInstanceKey;
	static C(Other: UObject | any): MovieSceneEvaluationInstanceKey;
}

declare class MovieSceneEvaluationHookComponent { 
	Interface: MovieSceneEvaluationHook;
	clone() : MovieSceneEvaluationHookComponent;
	static C(Other: UObject | any): MovieSceneEvaluationHookComponent;
}

declare class MovieSceneEvaluationHookEvent { 
	Hook: MovieSceneEvaluationHookComponent;
	clone() : MovieSceneEvaluationHookEvent;
	static C(Other: UObject | any): MovieSceneEvaluationHookEvent;
}

declare class MovieSceneEvaluationHookEventContainer { 
	Events: MovieSceneEvaluationHookEvent[];
	clone() : MovieSceneEvaluationHookEventContainer;
	static C(Other: UObject | any): MovieSceneEvaluationHookEventContainer;
}

declare class MovieSceneEvaluationHookSystem extends MovieSceneEntitySystem { 
	PendingEventsByRootInstance: Map<MovieSceneEvaluationInstanceKey, MovieSceneEvaluationHookEventContainer>;
	static Load(ResourceName: string): MovieSceneEvaluationHookSystem;
	static Find(Outer: UObject, ResourceName: string): MovieSceneEvaluationHookSystem;
	static GetDefaultObject(): MovieSceneEvaluationHookSystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneEvaluationHookSystem;
	static C(Other: UObject | any): MovieSceneEvaluationHookSystem;
}

declare class MovieSceneMasterInstantiatorSystem extends MovieSceneEntityInstantiatorSystem { 
	static Load(ResourceName: string): MovieSceneMasterInstantiatorSystem;
	static Find(Outer: UObject, ResourceName: string): MovieSceneMasterInstantiatorSystem;
	static GetDefaultObject(): MovieSceneMasterInstantiatorSystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneMasterInstantiatorSystem;
	static C(Other: UObject | any): MovieSceneMasterInstantiatorSystem;
}

declare class MovieScenePreAnimatedStateSystemInterface extends Interface { 
	static Load(ResourceName: string): MovieScenePreAnimatedStateSystemInterface;
	static Find(Outer: UObject, ResourceName: string): MovieScenePreAnimatedStateSystemInterface;
	static GetDefaultObject(): MovieScenePreAnimatedStateSystemInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScenePreAnimatedStateSystemInterface;
	static C(Other: UObject | any): MovieScenePreAnimatedStateSystemInterface;
}

declare class MovieSceneCachePreAnimatedStateSystem extends MovieSceneEntityInstantiatorSystem { 
	static Load(ResourceName: string): MovieSceneCachePreAnimatedStateSystem;
	static Find(Outer: UObject, ResourceName: string): MovieSceneCachePreAnimatedStateSystem;
	static GetDefaultObject(): MovieSceneCachePreAnimatedStateSystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneCachePreAnimatedStateSystem;
	static C(Other: UObject | any): MovieSceneCachePreAnimatedStateSystem;
}

declare class MovieSceneRestorePreAnimatedStateSystem extends MovieSceneEntityInstantiatorSystem { 
	static Load(ResourceName: string): MovieSceneRestorePreAnimatedStateSystem;
	static Find(Outer: UObject, ResourceName: string): MovieSceneRestorePreAnimatedStateSystem;
	static GetDefaultObject(): MovieSceneRestorePreAnimatedStateSystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneRestorePreAnimatedStateSystem;
	static C(Other: UObject | any): MovieSceneRestorePreAnimatedStateSystem;
}

declare class MovieSceneSpawnablesSystem extends MovieSceneEntitySystem { 
	static Load(ResourceName: string): MovieSceneSpawnablesSystem;
	static Find(Outer: UObject, ResourceName: string): MovieSceneSpawnablesSystem;
	static GetDefaultObject(): MovieSceneSpawnablesSystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneSpawnablesSystem;
	static C(Other: UObject | any): MovieSceneSpawnablesSystem;
}

declare class MovieSceneTrackInstanceInput { 
	Section: MovieSceneSection;
	clone() : MovieSceneTrackInstanceInput;
	static C(Other: UObject | any): MovieSceneTrackInstanceInput;
}

declare class MovieSceneTrackInstance extends UObject { 
	AnimatedObject: UObject;
	bIsMasterTrackInstance: boolean;
	PrivateLinker: MovieSceneEntitySystemLinker;
	Inputs: MovieSceneTrackInstanceInput[];
	static Load(ResourceName: string): MovieSceneTrackInstance;
	static Find(Outer: UObject, ResourceName: string): MovieSceneTrackInstance;
	static GetDefaultObject(): MovieSceneTrackInstance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneTrackInstance;
	static C(Other: UObject | any): MovieSceneTrackInstance;
}

declare class MovieSceneTrackInstanceInstantiator extends MovieSceneEntityInstantiatorSystem { 
	static Load(ResourceName: string): MovieSceneTrackInstanceInstantiator;
	static Find(Outer: UObject, ResourceName: string): MovieSceneTrackInstanceInstantiator;
	static GetDefaultObject(): MovieSceneTrackInstanceInstantiator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneTrackInstanceInstantiator;
	static C(Other: UObject | any): MovieSceneTrackInstanceInstantiator;
}

declare class MovieSceneTrackInstanceSystem extends MovieSceneEntitySystem { 
	Instantiator: MovieSceneTrackInstanceInstantiator;
	static Load(ResourceName: string): MovieSceneTrackInstanceSystem;
	static Find(Outer: UObject, ResourceName: string): MovieSceneTrackInstanceSystem;
	static GetDefaultObject(): MovieSceneTrackInstanceSystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneTrackInstanceSystem;
	static C(Other: UObject | any): MovieSceneTrackInstanceSystem;
}

declare class MovieSceneCustomClockSource extends Interface { 
	static Load(ResourceName: string): MovieSceneCustomClockSource;
	static Find(Outer: UObject, ResourceName: string): MovieSceneCustomClockSource;
	static GetDefaultObject(): MovieSceneCustomClockSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneCustomClockSource;
	OnTick(DeltaSeconds: number,InPlayRate: number): void;
	OnStopPlaying(InStopTime: QualifiedFrameTime): void;
	OnStartPlaying(InStartTime: QualifiedFrameTime): void;
	OnRequestCurrentTime(InCurrentTime: QualifiedFrameTime,InPlayRate: number): FrameTime;
	static C(Other: UObject | any): MovieSceneCustomClockSource;
}

declare type EMovieSceneBuiltInEasing = 'Linear' | 'SinIn' | 'SinOut' | 'SinInOut' | 'QuadIn' | 'QuadOut' | 'QuadInOut' | 'CubicIn' | 'CubicOut' | 'CubicInOut' | 'QuartIn' | 'QuartOut' | 'QuartInOut' | 'QuintIn' | 'QuintOut' | 'QuintInOut' | 'ExpoIn' | 'ExpoOut' | 'ExpoInOut' | 'CircIn' | 'CircOut' | 'CircInOut' | 'EMovieSceneBuiltInEasing_MAX';
declare var EMovieSceneBuiltInEasing : { Linear:'Linear',SinIn:'SinIn',SinOut:'SinOut',SinInOut:'SinInOut',QuadIn:'QuadIn',QuadOut:'QuadOut',QuadInOut:'QuadInOut',CubicIn:'CubicIn',CubicOut:'CubicOut',CubicInOut:'CubicInOut',QuartIn:'QuartIn',QuartOut:'QuartOut',QuartInOut:'QuartInOut',QuintIn:'QuintIn',QuintOut:'QuintOut',QuintInOut:'QuintInOut',ExpoIn:'ExpoIn',ExpoOut:'ExpoOut',ExpoInOut:'ExpoInOut',CircIn:'CircIn',CircOut:'CircOut',CircInOut:'CircInOut',EMovieSceneBuiltInEasing_MAX:'EMovieSceneBuiltInEasing_MAX', };
declare class MovieSceneBuiltInEasingFunction extends UObject { 
	Type: EMovieSceneBuiltInEasing;
	static Load(ResourceName: string): MovieSceneBuiltInEasingFunction;
	static Find(Outer: UObject, ResourceName: string): MovieSceneBuiltInEasingFunction;
	static GetDefaultObject(): MovieSceneBuiltInEasingFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneBuiltInEasingFunction;
	static C(Other: UObject | any): MovieSceneBuiltInEasingFunction;
}

declare class MovieSceneEasingExternalCurve extends UObject { 
	Curve: CurveFloat;
	static Load(ResourceName: string): MovieSceneEasingExternalCurve;
	static Find(Outer: UObject, ResourceName: string): MovieSceneEasingExternalCurve;
	static GetDefaultObject(): MovieSceneEasingExternalCurve;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneEasingExternalCurve;
	static C(Other: UObject | any): MovieSceneEasingExternalCurve;
}

declare class NodeAndChannelMappings extends Interface { 
	static Load(ResourceName: string): NodeAndChannelMappings;
	static Find(Outer: UObject, ResourceName: string): NodeAndChannelMappings;
	static GetDefaultObject(): NodeAndChannelMappings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NodeAndChannelMappings;
	static C(Other: UObject | any): NodeAndChannelMappings;
}

declare class MovieSceneBindingOverrideData { 
	ObjectBindingID: MovieSceneObjectBindingID;
	UObject: UObject;
	bOverridesDefault: boolean;
	clone() : MovieSceneBindingOverrideData;
	static C(Other: UObject | any): MovieSceneBindingOverrideData;
}

declare class MovieSceneBindingOverrides extends UObject { 
	BindingData: MovieSceneBindingOverrideData[];
	static Load(ResourceName: string): MovieSceneBindingOverrides;
	static Find(Outer: UObject, ResourceName: string): MovieSceneBindingOverrides;
	static GetDefaultObject(): MovieSceneBindingOverrides;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneBindingOverrides;
	static C(Other: UObject | any): MovieSceneBindingOverrides;
}

declare type EMovieScenePlayerStatus = 'Stopped' | 'Playing' | 'Scrubbing' | 'Jumping' | 'Stepping' | 'Paused' | 'MAX';
declare var EMovieScenePlayerStatus : { Stopped:'Stopped',Playing:'Playing',Scrubbing:'Scrubbing',Jumping:'Jumping',Stepping:'Stepping',Paused:'Paused',MAX:'MAX', };
declare class MovieSceneSequenceLoopCount { 
	Value: number;
	clone() : MovieSceneSequenceLoopCount;
	static C(Other: UObject | any): MovieSceneSequenceLoopCount;
}

declare class MovieSceneSequenceTickInterval { 
	TickIntervalSeconds: number;
	EvaluationBudgetMicroseconds: number;
	bTickWhenPaused: boolean;
	bAllowRounding: boolean;
	clone() : MovieSceneSequenceTickInterval;
	static C(Other: UObject | any): MovieSceneSequenceTickInterval;
}

declare class MovieSceneSequencePlaybackSettings { 
	bAutoPlay: boolean;
	LoopCount: MovieSceneSequenceLoopCount;
	TickInterval: MovieSceneSequenceTickInterval;
	PlayRate: number;
	StartTime: number;
	bRandomStartTime: boolean;
	bRestoreState: boolean;
	bDisableMovementInput: boolean;
	bDisableLookAtInput: boolean;
	bHidePlayer: boolean;
	bHideHud: boolean;
	bDisableCameraCuts: boolean;
	bPauseAtEnd: boolean;
	bInheritTickIntervalFromOwner: boolean;
	clone() : MovieSceneSequencePlaybackSettings;
	static C(Other: UObject | any): MovieSceneSequencePlaybackSettings;
}

declare class MovieSceneSequenceReplProperties { 
	LastKnownPosition: FrameTime;
	LastKnownStatus: EMovieScenePlayerStatus;
	LastKnownNumLoops: number;
	clone() : MovieSceneSequenceReplProperties;
	static C(Other: UObject | any): MovieSceneSequenceReplProperties;
}

declare class MovieSceneSequenceTickManager extends UObject { 
	static Load(ResourceName: string): MovieSceneSequenceTickManager;
	static Find(Outer: UObject, ResourceName: string): MovieSceneSequenceTickManager;
	static GetDefaultObject(): MovieSceneSequenceTickManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneSequenceTickManager;
	static C(Other: UObject | any): MovieSceneSequenceTickManager;
}

declare type EMovieScenePositionType = 'Frame' | 'Time' | 'MarkedFrame' | 'EMovieScenePositionType_MAX';
declare var EMovieScenePositionType : { Frame:'Frame',Time:'Time',MarkedFrame:'MarkedFrame',EMovieScenePositionType_MAX:'EMovieScenePositionType_MAX', };
declare type EUpdatePositionMethod = 'Play' | 'Jump' | 'Scrub' | 'EUpdatePositionMethod_MAX';
declare var EUpdatePositionMethod : { Play:'Play',Jump:'Jump',Scrub:'Scrub',EUpdatePositionMethod_MAX:'EUpdatePositionMethod_MAX', };
declare class MovieSceneSequencePlaybackParams { 
	Frame: FrameTime;
	Time: number;
	MarkedFrame: string;
	PositionType: EMovieScenePositionType;
	UpdateMethod: EUpdatePositionMethod;
	bHasJumped: boolean;
	clone() : MovieSceneSequencePlaybackParams;
	static C(Other: UObject | any): MovieSceneSequencePlaybackParams;
	PlayTo(): void;
	static PlayTo(PlaybackParams: MovieSceneSequencePlaybackParams): void;
}

declare class MovieSceneSequencePlayToParams { 
	bExclusive: boolean;
	clone() : MovieSceneSequencePlayToParams;
	static C(Other: UObject | any): MovieSceneSequencePlayToParams;
}

declare class MovieSceneSequencePlayer extends UObject { 
	Observer: MovieSceneSequencePlayerObserver;
	OnPlay: UnrealEngineMulticastDelegate<() => void>;
	OnPlayReverse: UnrealEngineMulticastDelegate<() => void>;
	OnStop: UnrealEngineMulticastDelegate<() => void>;
	OnPause: UnrealEngineMulticastDelegate<() => void>;
	OnFinished: UnrealEngineMulticastDelegate<() => void>;
	Status: EMovieScenePlayerStatus;
	bReversePlayback: boolean;
	Sequence: MovieSceneSequence;
	StartTime: FrameNumber;
	DurationFrames: number;
	DurationSubFrames: number;
	CurrentNumLoops: number;
	PlaybackSettings: MovieSceneSequencePlaybackSettings;
	RootTemplateInstance: MovieSceneRootEvaluationTemplateInstance;
	NetSyncProps: MovieSceneSequenceReplProperties;
	PlaybackClient: MovieScenePlaybackClient;
	TickManager: MovieSceneSequenceTickManager;
	static Load(ResourceName: string): MovieSceneSequencePlayer;
	static Find(Outer: UObject, ResourceName: string): MovieSceneSequencePlayer;
	static GetDefaultObject(): MovieSceneSequencePlayer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneSequencePlayer;
	StopAtCurrentTime(): void;
	Stop(): void;
	SetTimeRange(StartTime: number,Duration: number): void;
	SetPlayRate(PlayRate: number): void;
	SetPlaybackPosition(PlaybackParams: MovieSceneSequencePlaybackParams): void;
	SetFrameRate(FrameRate: FrameRate): void;
	SetFrameRange(StartFrame: number,Duration: number,SubFrames: number): void;
	SetDisableCameraCuts(bInDisableCameraCuts: boolean): void;
	ScrubToSeconds(TimeInSeconds: number): void;
	ScrubToMarkedFrame(InLabel: string): boolean;
	ScrubToFrame(NewPosition: FrameTime): void;
	Scrub(): void;
	RPC_OnStopEvent(StoppedTime: FrameTime): void;
	RPC_OnFinishPlaybackEvent(StoppedTime: FrameTime): void;
	RPC_ExplicitServerUpdateEvent(Method: EUpdatePositionMethod,RelevantTime: FrameTime): void;
	RestoreState(): void;
	PlayToSeconds(TimeInSeconds: number): void;
	PlayToMarkedFrame(InLabel: string): boolean;
	PlayToFrame(NewPosition: FrameTime): void;
	PlayTo(PlaybackParams: MovieSceneSequencePlaybackParams,PlayToParams: MovieSceneSequencePlayToParams): void;
	PlayReverse(): void;
	PlayLooping(NumLoops: number): void;
	Play(): void;
	Pause(): void;
	JumpToSeconds(TimeInSeconds: number): void;
	JumpToMarkedFrame(InLabel: string): boolean;
	JumpToFrame(NewPosition: FrameTime): void;
	IsReversed(): boolean;
	IsPlaying(): boolean;
	IsPaused(): boolean;
	GoToEndAndStop(): void;
	GetStartTime(): QualifiedFrameTime;
	GetSequenceName(bAddClientInfo: boolean): string;
	GetSequence(): MovieSceneSequence;
	GetPlayRate(): number;
	GetObjectBindings(InObject: UObject): MovieSceneObjectBindingID[];
	GetFrameRate(): FrameRate;
	GetFrameDuration(): number;
	GetEndTime(): QualifiedFrameTime;
	GetDuration(): QualifiedFrameTime;
	GetDisableCameraCuts(): boolean;
	GetCurrentTime(): QualifiedFrameTime;
	GetBoundObjects(ObjectBinding: MovieSceneObjectBindingID): UObject[];
	ChangePlaybackDirection(): void;
	static C(Other: UObject | any): MovieSceneSequencePlayer;
}

declare class MovieSceneBoolSection extends MovieSceneSection { 
	DefaultValue: boolean;
	BoolCurve: MovieSceneBoolChannel;
	bIsExternallyInverted: boolean;
	static Load(ResourceName: string): MovieSceneBoolSection;
	static Find(Outer: UObject, ResourceName: string): MovieSceneBoolSection;
	static GetDefaultObject(): MovieSceneBoolSection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneBoolSection;
	static C(Other: UObject | any): MovieSceneBoolSection;
}

declare class MovieSceneHookSection extends MovieSceneSection { 
	bRequiresRangedHook: boolean;
	bRequiresTriggerHooks: boolean;
	static Load(ResourceName: string): MovieSceneHookSection;
	static Find(Outer: UObject, ResourceName: string): MovieSceneHookSection;
	static GetDefaultObject(): MovieSceneHookSection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneHookSection;
	static C(Other: UObject | any): MovieSceneHookSection;
}

declare class MovieSceneSpawnSection extends MovieSceneBoolSection { 
	static Load(ResourceName: string): MovieSceneSpawnSection;
	static Find(Outer: UObject, ResourceName: string): MovieSceneSpawnSection;
	static GetDefaultObject(): MovieSceneSpawnSection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneSpawnSection;
	static C(Other: UObject | any): MovieSceneSpawnSection;
}

declare class TestMovieSceneTrack extends MovieSceneTrack { 
	bHighPassFilter: boolean;
	SectionArray: MovieSceneSection[];
	static Load(ResourceName: string): TestMovieSceneTrack;
	static Find(Outer: UObject, ResourceName: string): TestMovieSceneTrack;
	static GetDefaultObject(): TestMovieSceneTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestMovieSceneTrack;
	static C(Other: UObject | any): TestMovieSceneTrack;
}

declare class TestMovieSceneSection extends MovieSceneSection { 
	static Load(ResourceName: string): TestMovieSceneSection;
	static Find(Outer: UObject, ResourceName: string): TestMovieSceneSection;
	static GetDefaultObject(): TestMovieSceneSection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestMovieSceneSection;
	static C(Other: UObject | any): TestMovieSceneSection;
}

declare class TestMovieSceneSequence extends MovieSceneSequence { 
	MovieScene: MovieScene;
	static Load(ResourceName: string): TestMovieSceneSequence;
	static Find(Outer: UObject, ResourceName: string): TestMovieSceneSequence;
	static GetDefaultObject(): TestMovieSceneSequence;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestMovieSceneSequence;
	static C(Other: UObject | any): TestMovieSceneSequence;
}

declare class MovieSceneSubTrack extends MovieSceneNameableTrack { 
	Sections: MovieSceneSection[];
	static Load(ResourceName: string): MovieSceneSubTrack;
	static Find(Outer: UObject, ResourceName: string): MovieSceneSubTrack;
	static GetDefaultObject(): MovieSceneSubTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneSubTrack;
	static C(Other: UObject | any): MovieSceneSubTrack;
}

declare class TestMovieSceneSubTrack extends MovieSceneSubTrack { 
	SectionArray: MovieSceneSection[];
	static Load(ResourceName: string): TestMovieSceneSubTrack;
	static Find(Outer: UObject, ResourceName: string): TestMovieSceneSubTrack;
	static GetDefaultObject(): TestMovieSceneSubTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestMovieSceneSubTrack;
	static C(Other: UObject | any): TestMovieSceneSubTrack;
}

declare class TestMovieSceneSubSection extends MovieSceneSubSection { 
	static Load(ResourceName: string): TestMovieSceneSubSection;
	static Find(Outer: UObject, ResourceName: string): TestMovieSceneSubSection;
	static GetDefaultObject(): TestMovieSceneSubSection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestMovieSceneSubSection;
	static C(Other: UObject | any): TestMovieSceneSubSection;
}

declare class TestMovieSceneEvalHookTrack extends MovieSceneTrack { 
	SectionArray: MovieSceneSection[];
	static Load(ResourceName: string): TestMovieSceneEvalHookTrack;
	static Find(Outer: UObject, ResourceName: string): TestMovieSceneEvalHookTrack;
	static GetDefaultObject(): TestMovieSceneEvalHookTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestMovieSceneEvalHookTrack;
	static C(Other: UObject | any): TestMovieSceneEvalHookTrack;
}

declare class TestMovieSceneEvalHookSection extends MovieSceneHookSection { 
	static Load(ResourceName: string): TestMovieSceneEvalHookSection;
	static Find(Outer: UObject, ResourceName: string): TestMovieSceneEvalHookSection;
	static GetDefaultObject(): TestMovieSceneEvalHookSection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestMovieSceneEvalHookSection;
	static C(Other: UObject | any): TestMovieSceneEvalHookSection;
}

declare class MovieSceneSpawnTrack extends MovieSceneTrack { 
	Sections: MovieSceneSection[];
	ObjectGuid: Guid;
	static Load(ResourceName: string): MovieSceneSpawnTrack;
	static Find(Outer: UObject, ResourceName: string): MovieSceneSpawnTrack;
	static GetDefaultObject(): MovieSceneSpawnTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneSpawnTrack;
	static C(Other: UObject | any): MovieSceneSpawnTrack;
}

declare class ChaosDebugDrawComponent extends ActorComponent { 
	static Load(ResourceName: string): ChaosDebugDrawComponent;
	static Find(Outer: UObject, ResourceName: string): ChaosDebugDrawComponent;
	static GetDefaultObject(): ChaosDebugDrawComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosDebugDrawComponent;
	static C(Other: UObject | any): ChaosDebugDrawComponent;
}

declare class ChaosEventListenerComponent extends ActorComponent { 
	static Load(ResourceName: string): ChaosEventListenerComponent;
	static Find(Outer: UObject, ResourceName: string): ChaosEventListenerComponent;
	static GetDefaultObject(): ChaosEventListenerComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosEventListenerComponent;
	static C(Other: UObject | any): ChaosEventListenerComponent;
}

declare class ChaosHandlerSet { 
	ChaosHandlers: Set<UObject>;
	clone() : ChaosHandlerSet;
	static C(Other: UObject | any): ChaosHandlerSet;
}

declare class BreakEventCallbackWrapper { 
	clone() : BreakEventCallbackWrapper;
	static C(Other: UObject | any): BreakEventCallbackWrapper;
}

declare class RemovalEventCallbackWrapper { 
	clone() : RemovalEventCallbackWrapper;
	static C(Other: UObject | any): RemovalEventCallbackWrapper;
}

declare class CrumblingEventCallbackWrapper { 
	clone() : CrumblingEventCallbackWrapper;
	static C(Other: UObject | any): CrumblingEventCallbackWrapper;
}

declare class ChaosGameplayEventDispatcher extends ChaosEventListenerComponent { 
	CollisionEventRegistrations: Map<PrimitiveComponent, ChaosHandlerSet>;
	BreakEventRegistrations: Map<PrimitiveComponent, BreakEventCallbackWrapper>;
	RemovalEventRegistrations: Map<PrimitiveComponent, RemovalEventCallbackWrapper>;
	CrumblingEventRegistrations: Map<PrimitiveComponent, CrumblingEventCallbackWrapper>;
	static Load(ResourceName: string): ChaosGameplayEventDispatcher;
	static Find(Outer: UObject, ResourceName: string): ChaosGameplayEventDispatcher;
	static GetDefaultObject(): ChaosGameplayEventDispatcher;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosGameplayEventDispatcher;
	static C(Other: UObject | any): ChaosGameplayEventDispatcher;
}

declare class ChaosNotifyHandlerInterface extends Interface { 
	static Load(ResourceName: string): ChaosNotifyHandlerInterface;
	static Find(Outer: UObject, ResourceName: string): ChaosNotifyHandlerInterface;
	static GetDefaultObject(): ChaosNotifyHandlerInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosNotifyHandlerInterface;
	static C(Other: UObject | any): ChaosNotifyHandlerInterface;
}

declare class ChaosPhysicsCollisionInfo { 
	Component: PrimitiveComponent;
	OtherComponent: PrimitiveComponent;
	Location: Vector;
	Normal: Vector;
	AccumulatedImpulse: Vector;
	Velocity: Vector;
	OtherVelocity: Vector;
	AngularVelocity: Vector;
	OtherAngularVelocity: Vector;
	Mass: number;
	OtherMass: number;
	clone() : ChaosPhysicsCollisionInfo;
	static C(Other: UObject | any): ChaosPhysicsCollisionInfo;
	ConvertPhysicsCollisionToHitResult(): HitResult;
	static ConvertPhysicsCollisionToHitResult(PhysicsCollision: ChaosPhysicsCollisionInfo): HitResult;
}

declare class ChaosSolverEngineBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): ChaosSolverEngineBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): ChaosSolverEngineBlueprintLibrary;
	static GetDefaultObject(): ChaosSolverEngineBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosSolverEngineBlueprintLibrary;
	static ConvertPhysicsCollisionToHitResult(PhysicsCollision: ChaosPhysicsCollisionInfo): HitResult;
	static C(Other: UObject | any): ChaosSolverEngineBlueprintLibrary;
}

declare class ChaosSolver extends UObject { 
	static Load(ResourceName: string): ChaosSolver;
	static Find(Outer: UObject, ResourceName: string): ChaosSolver;
	static GetDefaultObject(): ChaosSolver;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosSolver;
	static C(Other: UObject | any): ChaosSolver;
}

declare type EClusterConnectionTypeEnum = 'Chaos_PointImplicit' | 'Chaos_DelaunayTriangulation' | 'Chaos_MinimalSpanningSubsetDelaunayTriangulation' | 'Chaos_PointImplicitAugmentedWithMinimalDelaunay' | 'Chaos_BoundsOverlapFilteredDelaunayTriangulation' | 'Chaos_None' | 'Chaos_EClsuterCreationParameters_Max' | 'Chaos_MAX';
declare var EClusterConnectionTypeEnum : { Chaos_PointImplicit:'Chaos_PointImplicit',Chaos_DelaunayTriangulation:'Chaos_DelaunayTriangulation',Chaos_MinimalSpanningSubsetDelaunayTriangulation:'Chaos_MinimalSpanningSubsetDelaunayTriangulation',Chaos_PointImplicitAugmentedWithMinimalDelaunay:'Chaos_PointImplicitAugmentedWithMinimalDelaunay',Chaos_BoundsOverlapFilteredDelaunayTriangulation:'Chaos_BoundsOverlapFilteredDelaunayTriangulation',Chaos_None:'Chaos_None',Chaos_EClsuterCreationParameters_Max:'Chaos_EClsuterCreationParameters_Max',Chaos_MAX:'Chaos_MAX', };
declare class ChaosDebugSubstepControl { 
	bPause: boolean;
	bSubstep: boolean;
	bStep: boolean;
	clone() : ChaosDebugSubstepControl;
	static C(Other: UObject | any): ChaosDebugSubstepControl;
}

declare class ChaosSolverActor extends Actor { 
	Properties: ChaosSolverConfiguration;
	TimeStepMultiplier: number;
	CollisionIterations: number;
	PushOutIterations: number;
	PushOutPairIterations: number;
	ClusterConnectionFactor: number;
	ClusterUnionConnectionType: EClusterConnectionTypeEnum;
	DoGenerateCollisionData: boolean;
	CollisionFilterSettings: SolverCollisionFilterSettings;
	DoGenerateBreakingData: boolean;
	BreakingFilterSettings: SolverBreakingFilterSettings;
	DoGenerateTrailingData: boolean;
	TrailingFilterSettings: SolverTrailingFilterSettings;
	MassScale: number;
	bHasFloor: boolean;
	FloorHeight: number;
	ChaosDebugSubstepControl: ChaosDebugSubstepControl;
	SpriteComponent: BillboardComponent;
	GameplayEventDispatcherComponent: ChaosGameplayEventDispatcher;
	static GetDefaultObject(): ChaosSolverActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosSolverActor;
	SetSolverActive(bActive: boolean): void;
	SetAsCurrentWorldSolver(): void;
	static C(Other: UObject | any): ChaosSolverActor;
}

declare class ChaosSolverSettings extends DeveloperSettings { 
	DefaultChaosSolverActorClass: SoftClassPath;
	static Load(ResourceName: string): ChaosSolverSettings;
	static Find(Outer: UObject, ResourceName: string): ChaosSolverSettings;
	static GetDefaultObject(): ChaosSolverSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosSolverSettings;
	static C(Other: UObject | any): ChaosSolverSettings;
}

declare class FieldSystem extends UObject { 
	static Load(ResourceName: string): FieldSystem;
	static Find(Outer: UObject, ResourceName: string): FieldSystem;
	static GetDefaultObject(): FieldSystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldSystem;
	static C(Other: UObject | any): FieldSystem;
}

declare class FieldNodeBase extends ActorComponent { 
	static Load(ResourceName: string): FieldNodeBase;
	static Find(Outer: UObject, ResourceName: string): FieldNodeBase;
	static GetDefaultObject(): FieldNodeBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldNodeBase;
	static C(Other: UObject | any): FieldNodeBase;
}

declare class FieldSystemMetaData extends ActorComponent { 
	static Load(ResourceName: string): FieldSystemMetaData;
	static Find(Outer: UObject, ResourceName: string): FieldSystemMetaData;
	static GetDefaultObject(): FieldSystemMetaData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldSystemMetaData;
	static C(Other: UObject | any): FieldSystemMetaData;
}

declare class FieldObjectCommands { 
	TargetNames: string[];
	RootNodes: FieldNodeBase[];
	MetaDatas: FieldSystemMetaData[];
	clone() : FieldObjectCommands;
	static C(Other: UObject | any): FieldObjectCommands;
}

declare type EFieldPhysicsType = 'Field_None' | 'Field_DynamicState' | 'Field_LinearForce' | 'Field_ExternalClusterStrain' | 'Field_Kill' | 'Field_LinearVelocity' | 'Field_AngularVelociy' | 'Field_AngularTorque' | 'Field_InternalClusterStrain' | 'Field_DisableThreshold' | 'Field_SleepingThreshold' | 'Field_PositionStatic' | 'Field_PositionAnimated' | 'Field_PositionTarget' | 'Field_DynamicConstraint' | 'Field_CollisionGroup' | 'Field_ActivateDisabled' | 'Field_InitialLinearVelocity' | 'Field_InitialAngularVelocity' | 'Field_LinearImpulse' | 'Field_PhysicsType_Max';
declare var EFieldPhysicsType : { Field_None:'Field_None',Field_DynamicState:'Field_DynamicState',Field_LinearForce:'Field_LinearForce',Field_ExternalClusterStrain:'Field_ExternalClusterStrain',Field_Kill:'Field_Kill',Field_LinearVelocity:'Field_LinearVelocity',Field_AngularVelociy:'Field_AngularVelociy',Field_AngularTorque:'Field_AngularTorque',Field_InternalClusterStrain:'Field_InternalClusterStrain',Field_DisableThreshold:'Field_DisableThreshold',Field_SleepingThreshold:'Field_SleepingThreshold',Field_PositionStatic:'Field_PositionStatic',Field_PositionAnimated:'Field_PositionAnimated',Field_PositionTarget:'Field_PositionTarget',Field_DynamicConstraint:'Field_DynamicConstraint',Field_CollisionGroup:'Field_CollisionGroup',Field_ActivateDisabled:'Field_ActivateDisabled',Field_InitialLinearVelocity:'Field_InitialLinearVelocity',Field_InitialAngularVelocity:'Field_InitialAngularVelocity',Field_LinearImpulse:'Field_LinearImpulse',Field_PhysicsType_Max:'Field_PhysicsType_Max', };
declare class FieldSystemComponent extends PrimitiveComponent { 
	FieldSystem: FieldSystem;
	bIsWorldField: boolean;
	bIsChaosField: boolean;
	SupportedSolvers: ChaosSolverActor[];
	ConstructionCommands: FieldObjectCommands;
	BufferCommands: FieldObjectCommands;
	static Load(ResourceName: string): FieldSystemComponent;
	static Find(Outer: UObject, ResourceName: string): FieldSystemComponent;
	static GetDefaultObject(): FieldSystemComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldSystemComponent;
	ResetFieldSystem(): void;
	RemovePersistentFields(): void;
	ApplyUniformVectorFalloffForce(Enabled: boolean,Position: Vector,Direction: Vector,Radius: number,Magnitude: number): void;
	ApplyStrainField(Enabled: boolean,Position: Vector,Radius: number,Magnitude: number,Iterations: number): void;
	ApplyStayDynamicField(Enabled: boolean,Position: Vector,Radius: number): void;
	ApplyRadialVectorFalloffForce(Enabled: boolean,Position: Vector,Radius: number,Magnitude: number): void;
	ApplyRadialForce(Enabled: boolean,Position: Vector,Magnitude: number): void;
	ApplyPhysicsField(Enabled: boolean,Target: EFieldPhysicsType,MetaData: FieldSystemMetaData,Field: FieldNodeBase): void;
	ApplyLinearForce(Enabled: boolean,Direction: Vector,Magnitude: number): void;
	AddPersistentField(Enabled: boolean,Target: EFieldPhysicsType,MetaData: FieldSystemMetaData,Field: FieldNodeBase): void;
	AddFieldCommand(Enabled: boolean,Target: EFieldPhysicsType,MetaData: FieldSystemMetaData,Field: FieldNodeBase): void;
	static C(Other: UObject | any): FieldSystemComponent;
}

declare class FieldSystemActor extends Actor { 
	FieldSystemComponent: FieldSystemComponent;
	static GetDefaultObject(): FieldSystemActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldSystemActor;
	static C(Other: UObject | any): FieldSystemActor;
}

declare class FieldSystemMetaDataIteration extends FieldSystemMetaData { 
	Iterations: number;
	static Load(ResourceName: string): FieldSystemMetaDataIteration;
	static Find(Outer: UObject, ResourceName: string): FieldSystemMetaDataIteration;
	static GetDefaultObject(): FieldSystemMetaDataIteration;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldSystemMetaDataIteration;
	SetMetaDataIteration(Iterations: number): FieldSystemMetaDataIteration;
	static C(Other: UObject | any): FieldSystemMetaDataIteration;
}

declare type EFieldResolutionType = 'Field_Resolution_Minimal' | 'Field_Resolution_DisabledParents' | 'Field_Resolution_Maximum' | 'Field_Resolution_Max';
declare var EFieldResolutionType : { Field_Resolution_Minimal:'Field_Resolution_Minimal',Field_Resolution_DisabledParents:'Field_Resolution_DisabledParents',Field_Resolution_Maximum:'Field_Resolution_Maximum',Field_Resolution_Max:'Field_Resolution_Max', };
declare class FieldSystemMetaDataProcessingResolution extends FieldSystemMetaData { 
	ResolutionType: EFieldResolutionType;
	static Load(ResourceName: string): FieldSystemMetaDataProcessingResolution;
	static Find(Outer: UObject, ResourceName: string): FieldSystemMetaDataProcessingResolution;
	static GetDefaultObject(): FieldSystemMetaDataProcessingResolution;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldSystemMetaDataProcessingResolution;
	SetMetaDataaProcessingResolutionType(ResolutionType: EFieldResolutionType): FieldSystemMetaDataProcessingResolution;
	static C(Other: UObject | any): FieldSystemMetaDataProcessingResolution;
}

declare type EFieldFilterType = 'Field_Filter_Dynamic' | 'Field_Filter_Kinematic' | 'Field_Filter_Static' | 'Field_Filter_All' | 'Field_Filter_Sleeping' | 'Field_Filter_Disabled' | 'Field_Filter_Max';
declare var EFieldFilterType : { Field_Filter_Dynamic:'Field_Filter_Dynamic',Field_Filter_Kinematic:'Field_Filter_Kinematic',Field_Filter_Static:'Field_Filter_Static',Field_Filter_All:'Field_Filter_All',Field_Filter_Sleeping:'Field_Filter_Sleeping',Field_Filter_Disabled:'Field_Filter_Disabled',Field_Filter_Max:'Field_Filter_Max', };
declare type EFieldObjectType = 'Field_Object_Rigid' | 'Field_Object_Cloth' | 'Field_Object_Destruction' | 'Field_Object_Character' | 'Field_Object_All' | 'Field_Object_Max';
declare var EFieldObjectType : { Field_Object_Rigid:'Field_Object_Rigid',Field_Object_Cloth:'Field_Object_Cloth',Field_Object_Destruction:'Field_Object_Destruction',Field_Object_Character:'Field_Object_Character',Field_Object_All:'Field_Object_All',Field_Object_Max:'Field_Object_Max', };
declare type EFieldPositionType = 'Field_Position_CenterOfMass' | 'Field_Position_PivotPoint' | 'Field_Position_Max';
declare var EFieldPositionType : { Field_Position_CenterOfMass:'Field_Position_CenterOfMass',Field_Position_PivotPoint:'Field_Position_PivotPoint',Field_Position_Max:'Field_Position_Max', };
declare class FieldSystemMetaDataFilter extends FieldSystemMetaData { 
	FilterType: EFieldFilterType;
	ObjectType: EFieldObjectType;
	PositionType: EFieldPositionType;
	static Load(ResourceName: string): FieldSystemMetaDataFilter;
	static Find(Outer: UObject, ResourceName: string): FieldSystemMetaDataFilter;
	static GetDefaultObject(): FieldSystemMetaDataFilter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldSystemMetaDataFilter;
	SetMetaDataFilterType(FilterType: EFieldFilterType,ObjectType: EFieldObjectType,PositionType: EFieldPositionType): FieldSystemMetaDataFilter;
	static C(Other: UObject | any): FieldSystemMetaDataFilter;
}

declare class FieldNodeInt extends FieldNodeBase { 
	static Load(ResourceName: string): FieldNodeInt;
	static Find(Outer: UObject, ResourceName: string): FieldNodeInt;
	static GetDefaultObject(): FieldNodeInt;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldNodeInt;
	static C(Other: UObject | any): FieldNodeInt;
}

declare class FieldNodeFloat extends FieldNodeBase { 
	static Load(ResourceName: string): FieldNodeFloat;
	static Find(Outer: UObject, ResourceName: string): FieldNodeFloat;
	static GetDefaultObject(): FieldNodeFloat;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldNodeFloat;
	static C(Other: UObject | any): FieldNodeFloat;
}

declare class FieldNodeVector extends FieldNodeBase { 
	static Load(ResourceName: string): FieldNodeVector;
	static Find(Outer: UObject, ResourceName: string): FieldNodeVector;
	static GetDefaultObject(): FieldNodeVector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldNodeVector;
	static C(Other: UObject | any): FieldNodeVector;
}

declare class UniformInteger extends FieldNodeInt { 
	Magnitude: number;
	static Load(ResourceName: string): UniformInteger;
	static Find(Outer: UObject, ResourceName: string): UniformInteger;
	static GetDefaultObject(): UniformInteger;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UniformInteger;
	SetUniformInteger(Magnitude: number): UniformInteger;
	static C(Other: UObject | any): UniformInteger;
}

declare type ESetMaskConditionType = 'Field_Set_Always' | 'Field_Set_IFF_NOT_Interior' | 'Field_Set_IFF_NOT_Exterior' | 'Field_MaskCondition_Max' | 'Field_MAX';
declare var ESetMaskConditionType : { Field_Set_Always:'Field_Set_Always',Field_Set_IFF_NOT_Interior:'Field_Set_IFF_NOT_Interior',Field_Set_IFF_NOT_Exterior:'Field_Set_IFF_NOT_Exterior',Field_MaskCondition_Max:'Field_MaskCondition_Max',Field_MAX:'Field_MAX', };
declare class RadialIntMask extends FieldNodeInt { 
	Radius: number;
	Position: Vector;
	InteriorValue: number;
	ExteriorValue: number;
	SetMaskCondition: ESetMaskConditionType;
	static Load(ResourceName: string): RadialIntMask;
	static Find(Outer: UObject, ResourceName: string): RadialIntMask;
	static GetDefaultObject(): RadialIntMask;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RadialIntMask;
	SetRadialIntMask(Radius: number,Position: Vector,InteriorValue: number,ExteriorValue: number,SetMaskConditionIn: ESetMaskConditionType): RadialIntMask;
	static C(Other: UObject | any): RadialIntMask;
}

declare class UniformScalar extends FieldNodeFloat { 
	Magnitude: number;
	static Load(ResourceName: string): UniformScalar;
	static Find(Outer: UObject, ResourceName: string): UniformScalar;
	static GetDefaultObject(): UniformScalar;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UniformScalar;
	SetUniformScalar(Magnitude: number): UniformScalar;
	static C(Other: UObject | any): UniformScalar;
}

declare type EWaveFunctionType = 'Field_Wave_Cosine' | 'Field_Wave_Gaussian' | 'Field_Wave_Falloff' | 'Field_Wave_Decay' | 'Field_Wave_Max';
declare var EWaveFunctionType : { Field_Wave_Cosine:'Field_Wave_Cosine',Field_Wave_Gaussian:'Field_Wave_Gaussian',Field_Wave_Falloff:'Field_Wave_Falloff',Field_Wave_Decay:'Field_Wave_Decay',Field_Wave_Max:'Field_Wave_Max', };
declare type EFieldFalloffType = 'Field_FallOff_None' | 'Field_Falloff_Linear' | 'Field_Falloff_Inverse' | 'Field_Falloff_Squared' | 'Field_Falloff_Logarithmic' | 'Field_Falloff_Max';
declare var EFieldFalloffType : { Field_FallOff_None:'Field_FallOff_None',Field_Falloff_Linear:'Field_Falloff_Linear',Field_Falloff_Inverse:'Field_Falloff_Inverse',Field_Falloff_Squared:'Field_Falloff_Squared',Field_Falloff_Logarithmic:'Field_Falloff_Logarithmic',Field_Falloff_Max:'Field_Falloff_Max', };
declare class WaveScalar extends FieldNodeFloat { 
	Magnitude: number;
	Position: Vector;
	Wavelength: number;
	Period: number;
	UFunction: EWaveFunctionType;
	Falloff: EFieldFalloffType;
	static Load(ResourceName: string): WaveScalar;
	static Find(Outer: UObject, ResourceName: string): WaveScalar;
	static GetDefaultObject(): WaveScalar;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WaveScalar;
	SetWaveScalar(Magnitude: number,Position: Vector,Wavelength: number,Period: number,Time: number,UFunction: EWaveFunctionType,Falloff: EFieldFalloffType): WaveScalar;
	static C(Other: UObject | any): WaveScalar;
}

declare class RadialFalloff extends FieldNodeFloat { 
	Magnitude: number;
	MinRange: number;
	MaxRange: number;
	Default: number;
	Radius: number;
	Position: Vector;
	Falloff: EFieldFalloffType;
	static Load(ResourceName: string): RadialFalloff;
	static Find(Outer: UObject, ResourceName: string): RadialFalloff;
	static GetDefaultObject(): RadialFalloff;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RadialFalloff;
	SetRadialFalloff(Magnitude: number,MinRange: number,MaxRange: number,Default: number,Radius: number,Position: Vector,Falloff: EFieldFalloffType): RadialFalloff;
	static C(Other: UObject | any): RadialFalloff;
}

declare class PlaneFalloff extends FieldNodeFloat { 
	Magnitude: number;
	MinRange: number;
	MaxRange: number;
	Default: number;
	Distance: number;
	Position: Vector;
	Normal: Vector;
	Falloff: EFieldFalloffType;
	static Load(ResourceName: string): PlaneFalloff;
	static Find(Outer: UObject, ResourceName: string): PlaneFalloff;
	static GetDefaultObject(): PlaneFalloff;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlaneFalloff;
	SetPlaneFalloff(Magnitude: number,MinRange: number,MaxRange: number,Default: number,Distance: number,Position: Vector,Normal: Vector,Falloff: EFieldFalloffType): PlaneFalloff;
	static C(Other: UObject | any): PlaneFalloff;
}

declare class BoxFalloff extends FieldNodeFloat { 
	Magnitude: number;
	MinRange: number;
	MaxRange: number;
	Default: number;
	Transform: Transform;
	Falloff: EFieldFalloffType;
	static Load(ResourceName: string): BoxFalloff;
	static Find(Outer: UObject, ResourceName: string): BoxFalloff;
	static GetDefaultObject(): BoxFalloff;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BoxFalloff;
	SetBoxFalloff(Magnitude: number,MinRange: number,MaxRange: number,Default: number,Transform: Transform,Falloff: EFieldFalloffType): BoxFalloff;
	static C(Other: UObject | any): BoxFalloff;
}

declare class NoiseField extends FieldNodeFloat { 
	MinRange: number;
	MaxRange: number;
	Transform: Transform;
	static Load(ResourceName: string): NoiseField;
	static Find(Outer: UObject, ResourceName: string): NoiseField;
	static GetDefaultObject(): NoiseField;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NoiseField;
	SetNoiseField(MinRange: number,MaxRange: number,Transform: Transform): NoiseField;
	static C(Other: UObject | any): NoiseField;
}

declare class UniformVector extends FieldNodeVector { 
	Magnitude: number;
	Direction: Vector;
	static Load(ResourceName: string): UniformVector;
	static Find(Outer: UObject, ResourceName: string): UniformVector;
	static GetDefaultObject(): UniformVector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UniformVector;
	SetUniformVector(Magnitude: number,Direction: Vector): UniformVector;
	static C(Other: UObject | any): UniformVector;
}

declare class RadialVector extends FieldNodeVector { 
	Magnitude: number;
	Position: Vector;
	static Load(ResourceName: string): RadialVector;
	static Find(Outer: UObject, ResourceName: string): RadialVector;
	static GetDefaultObject(): RadialVector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RadialVector;
	SetRadialVector(Magnitude: number,Position: Vector): RadialVector;
	static C(Other: UObject | any): RadialVector;
}

declare class RandomVector extends FieldNodeVector { 
	Magnitude: number;
	static Load(ResourceName: string): RandomVector;
	static Find(Outer: UObject, ResourceName: string): RandomVector;
	static GetDefaultObject(): RandomVector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RandomVector;
	SetRandomVector(Magnitude: number): RandomVector;
	static C(Other: UObject | any): RandomVector;
}

declare type EFieldOperationType = 'Field_Multiply' | 'Field_Divide' | 'Field_Add' | 'Field_Substract' | 'Field_Operation_Max';
declare var EFieldOperationType : { Field_Multiply:'Field_Multiply',Field_Divide:'Field_Divide',Field_Add:'Field_Add',Field_Substract:'Field_Substract',Field_Operation_Max:'Field_Operation_Max', };
declare class OperatorField extends FieldNodeBase { 
	Magnitude: number;
	RightField: FieldNodeBase;
	LeftField: FieldNodeBase;
	Operation: EFieldOperationType;
	static Load(ResourceName: string): OperatorField;
	static Find(Outer: UObject, ResourceName: string): OperatorField;
	static GetDefaultObject(): OperatorField;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OperatorField;
	SetOperatorField(Magnitude: number,LeftField: FieldNodeBase,RightField: FieldNodeBase,Operation: EFieldOperationType): OperatorField;
	static C(Other: UObject | any): OperatorField;
}

declare class ToIntegerField extends FieldNodeInt { 
	FloatField: FieldNodeFloat;
	static Load(ResourceName: string): ToIntegerField;
	static Find(Outer: UObject, ResourceName: string): ToIntegerField;
	static GetDefaultObject(): ToIntegerField;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToIntegerField;
	SetToIntegerField(FloatField: FieldNodeFloat): ToIntegerField;
	static C(Other: UObject | any): ToIntegerField;
}

declare class ToFloatField extends FieldNodeFloat { 
	IntField: FieldNodeInt;
	static Load(ResourceName: string): ToFloatField;
	static Find(Outer: UObject, ResourceName: string): ToFloatField;
	static GetDefaultObject(): ToFloatField;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToFloatField;
	SetToFloatField(IntegerField: FieldNodeInt): ToFloatField;
	static C(Other: UObject | any): ToFloatField;
}

declare type EFieldCullingOperationType = 'Field_Culling_Inside' | 'Field_Culling_Outside' | 'Field_Culling_Operation_Max' | 'Field_Culling_MAX';
declare var EFieldCullingOperationType : { Field_Culling_Inside:'Field_Culling_Inside',Field_Culling_Outside:'Field_Culling_Outside',Field_Culling_Operation_Max:'Field_Culling_Operation_Max',Field_Culling_MAX:'Field_Culling_MAX', };
declare class CullingField extends FieldNodeBase { 
	Culling: FieldNodeBase;
	Field: FieldNodeBase;
	Operation: EFieldCullingOperationType;
	static Load(ResourceName: string): CullingField;
	static Find(Outer: UObject, ResourceName: string): CullingField;
	static GetDefaultObject(): CullingField;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CullingField;
	SetCullingField(Culling: FieldNodeBase,Field: FieldNodeBase,Operation: EFieldCullingOperationType): CullingField;
	static C(Other: UObject | any): CullingField;
}

declare class ReturnResultsTerminal extends FieldNodeBase { 
	static Load(ResourceName: string): ReturnResultsTerminal;
	static Find(Outer: UObject, ResourceName: string): ReturnResultsTerminal;
	static GetDefaultObject(): ReturnResultsTerminal;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReturnResultsTerminal;
	SetReturnResultsTerminal(): ReturnResultsTerminal;
	static C(Other: UObject | any): ReturnResultsTerminal;
}

declare class NetAnalyticsDataConfig { 
	DataName: string;
	bEnabled: boolean;
	clone() : NetAnalyticsDataConfig;
	static C(Other: UObject | any): NetAnalyticsDataConfig;
}

declare class NetAnalyticsAggregatorConfig extends UObject { 
	NetAnalyticsData: NetAnalyticsDataConfig[];
	static Load(ResourceName: string): NetAnalyticsAggregatorConfig;
	static Find(Outer: UObject, ResourceName: string): NetAnalyticsAggregatorConfig;
	static GetDefaultObject(): NetAnalyticsAggregatorConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NetAnalyticsAggregatorConfig;
	static C(Other: UObject | any): NetAnalyticsAggregatorConfig;
}

declare class StatePerObjectConfig extends UObject { 
	PerObjectConfigSection: string;
	bEnabled: boolean;
	static Load(ResourceName: string): StatePerObjectConfig;
	static Find(Outer: UObject, ResourceName: string): StatePerObjectConfig;
	static GetDefaultObject(): StatePerObjectConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StatePerObjectConfig;
	static C(Other: UObject | any): StatePerObjectConfig;
}

declare class EscalationManagerConfig extends StatePerObjectConfig { 
	EscalationSeverity: string[];
	static Load(ResourceName: string): EscalationManagerConfig;
	static Find(Outer: UObject, ResourceName: string): EscalationManagerConfig;
	static GetDefaultObject(): EscalationManagerConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EscalationManagerConfig;
	static C(Other: UObject | any): EscalationManagerConfig;
}

declare class DataflowEdNode extends EdGraphNode { 
	static Load(ResourceName: string): DataflowEdNode;
	static Find(Outer: UObject, ResourceName: string): DataflowEdNode;
	static GetDefaultObject(): DataflowEdNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DataflowEdNode;
	static C(Other: UObject | any): DataflowEdNode;
}

declare class Dataflow extends EdGraph { 
	bActive: boolean;
	Targets: UObject[];
	static Load(ResourceName: string): Dataflow;
	static Find(Outer: UObject, ResourceName: string): Dataflow;
	static GetDefaultObject(): Dataflow;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Dataflow;
	static C(Other: UObject | any): Dataflow;
}

declare class GeometryCollectionISMPoolComponent extends SceneComponent { 
	static Load(ResourceName: string): GeometryCollectionISMPoolComponent;
	static Find(Outer: UObject, ResourceName: string): GeometryCollectionISMPoolComponent;
	static GetDefaultObject(): GeometryCollectionISMPoolComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCollectionISMPoolComponent;
	static C(Other: UObject | any): GeometryCollectionISMPoolComponent;
}

declare class GeometryCollectionISMPoolActor extends Actor { 
	ISMPoolComp: GeometryCollectionISMPoolComponent;
	static GetDefaultObject(): GeometryCollectionISMPoolActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCollectionISMPoolActor;
	static C(Other: UObject | any): GeometryCollectionISMPoolActor;
}

declare type EChaosCollisionSortMethod = 'SortNone' | 'SortByHighestMass' | 'SortByHighestSpeed' | 'SortByHighestImpulse' | 'SortByNearestFirst' | 'Count' | 'EChaosCollisionSortMethod_MAX';
declare var EChaosCollisionSortMethod : { SortNone:'SortNone',SortByHighestMass:'SortByHighestMass',SortByHighestSpeed:'SortByHighestSpeed',SortByHighestImpulse:'SortByHighestImpulse',SortByNearestFirst:'SortByNearestFirst',Count:'Count',EChaosCollisionSortMethod_MAX:'EChaosCollisionSortMethod_MAX', };
declare class ChaosCollisionEventRequestSettings { 
	MaxNumberResults: number;
	MinMass: number;
	MinSpeed: number;
	MinImpulse: number;
	MaxDistance: number;
	SortMethod: EChaosCollisionSortMethod;
	clone() : ChaosCollisionEventRequestSettings;
	static C(Other: UObject | any): ChaosCollisionEventRequestSettings;
}

declare type EChaosBreakingSortMethod = 'SortNone' | 'SortByHighestMass' | 'SortByHighestSpeed' | 'SortByNearestFirst' | 'Count' | 'EChaosBreakingSortMethod_MAX';
declare var EChaosBreakingSortMethod : { SortNone:'SortNone',SortByHighestMass:'SortByHighestMass',SortByHighestSpeed:'SortByHighestSpeed',SortByNearestFirst:'SortByNearestFirst',Count:'Count',EChaosBreakingSortMethod_MAX:'EChaosBreakingSortMethod_MAX', };
declare class ChaosBreakingEventRequestSettings { 
	MaxNumberOfResults: number;
	MinRadius: number;
	MinSpeed: number;
	MinMass: number;
	MaxDistance: number;
	SortMethod: EChaosBreakingSortMethod;
	clone() : ChaosBreakingEventRequestSettings;
	static C(Other: UObject | any): ChaosBreakingEventRequestSettings;
}

declare type EChaosTrailingSortMethod = 'SortNone' | 'SortByHighestMass' | 'SortByHighestSpeed' | 'SortByNearestFirst' | 'Count' | 'EChaosTrailingSortMethod_MAX';
declare var EChaosTrailingSortMethod : { SortNone:'SortNone',SortByHighestMass:'SortByHighestMass',SortByHighestSpeed:'SortByHighestSpeed',SortByNearestFirst:'SortByNearestFirst',Count:'Count',EChaosTrailingSortMethod_MAX:'EChaosTrailingSortMethod_MAX', };
declare class ChaosTrailingEventRequestSettings { 
	MaxNumberOfResults: number;
	MinMass: number;
	MinSpeed: number;
	MinAngularSpeed: number;
	MaxDistance: number;
	SortMethod: EChaosTrailingSortMethod;
	clone() : ChaosTrailingEventRequestSettings;
	static C(Other: UObject | any): ChaosTrailingEventRequestSettings;
}

declare type EChaosRemovalSortMethod = 'SortNone' | 'SortByHighestMass' | 'SortByNearestFirst' | 'Count' | 'EChaosRemovalSortMethod_MAX';
declare var EChaosRemovalSortMethod : { SortNone:'SortNone',SortByHighestMass:'SortByHighestMass',SortByNearestFirst:'SortByNearestFirst',Count:'Count',EChaosRemovalSortMethod_MAX:'EChaosRemovalSortMethod_MAX', };
declare class ChaosRemovalEventRequestSettings { 
	MaxNumberOfResults: number;
	MinMass: number;
	MaxDistance: number;
	SortMethod: EChaosRemovalSortMethod;
	clone() : ChaosRemovalEventRequestSettings;
	static C(Other: UObject | any): ChaosRemovalEventRequestSettings;
}

declare class GeometryCollectionDamagePropagationData { 
	bEnabled: boolean;
	BreakDamagePropagationFactor: number;
	ShockDamagePropagationFactor: number;
	clone() : GeometryCollectionDamagePropagationData;
	static C(Other: UObject | any): GeometryCollectionDamagePropagationData;
}

declare class GeometryCollectionSource { 
	SourceGeometryObject: SoftObjectPath;
	LocalTransform: Transform;
	SourceMaterial: MaterialInterface[];
	bAddInternalMaterials: boolean;
	bSplitComponents: boolean;
	clone() : GeometryCollectionSource;
	static C(Other: UObject | any): GeometryCollectionSource;
}

declare class GeometryCollectionEmbeddedExemplar { 
	StaticMeshExemplar: SoftObjectPath;
	StartCullDistance: number;
	EndCullDistance: number;
	InstanceCount: number;
	clone() : GeometryCollectionEmbeddedExemplar;
	static C(Other: UObject | any): GeometryCollectionEmbeddedExemplar;
}

declare class GeometryCollectionAutoInstanceMesh { 
	StaticMesh: SoftObjectPath;
	Materials: MaterialInterface[];
	clone() : GeometryCollectionAutoInstanceMesh;
	static C(Other: UObject | any): GeometryCollectionAutoInstanceMesh;
}

declare type ECollisionTypeEnum = 'Chaos_Volumetric' | 'Chaos_Surface_Volumetric' | 'Chaos_Max';
declare var ECollisionTypeEnum : { Chaos_Volumetric:'Chaos_Volumetric',Chaos_Surface_Volumetric:'Chaos_Surface_Volumetric',Chaos_Max:'Chaos_Max', };
declare type EImplicitTypeEnum = 'Chaos_Implicit_Box' | 'Chaos_Implicit_Sphere' | 'Chaos_Implicit_Capsule' | 'Chaos_Implicit_LevelSet' | 'Chaos_Implicit_None' | 'Chaos_Implicit_Convex' | 'Chaos_Max';
declare var EImplicitTypeEnum : { Chaos_Implicit_Box:'Chaos_Implicit_Box',Chaos_Implicit_Sphere:'Chaos_Implicit_Sphere',Chaos_Implicit_Capsule:'Chaos_Implicit_Capsule',Chaos_Implicit_LevelSet:'Chaos_Implicit_LevelSet',Chaos_Implicit_None:'Chaos_Implicit_None',Chaos_Implicit_Convex:'Chaos_Implicit_Convex',Chaos_Max:'Chaos_Max', };
declare class GeometryCollectionLevelSetData { 
	MinLevelSetResolution: number;
	MaxLevelSetResolution: number;
	MinClusterLevelSetResolution: number;
	MaxClusterLevelSetResolution: number;
	clone() : GeometryCollectionLevelSetData;
	static C(Other: UObject | any): GeometryCollectionLevelSetData;
}

declare class GeometryCollectionCollisionParticleData { 
	CollisionParticlesFraction: number;
	MaximumCollisionParticles: number;
	clone() : GeometryCollectionCollisionParticleData;
	static C(Other: UObject | any): GeometryCollectionCollisionParticleData;
}

declare class GeometryCollectionCollisionTypeData { 
	CollisionType: ECollisionTypeEnum;
	ImplicitType: EImplicitTypeEnum;
	LevelSet: GeometryCollectionLevelSetData;
	CollisionParticles: GeometryCollectionCollisionParticleData;
	CollisionObjectReductionPercentage: number;
	CollisionMarginFraction: number;
	clone() : GeometryCollectionCollisionTypeData;
	static C(Other: UObject | any): GeometryCollectionCollisionTypeData;
}

declare class GeometryCollectionSizeSpecificData { 
	MaxSize: number;
	CollisionShapes: GeometryCollectionCollisionTypeData[];
	CollisionType: ECollisionTypeEnum;
	ImplicitType: EImplicitTypeEnum;
	MinLevelSetResolution: number;
	MaxLevelSetResolution: number;
	MinClusterLevelSetResolution: number;
	MaxClusterLevelSetResolution: number;
	CollisionObjectReductionPercentage: number;
	CollisionParticlesFraction: number;
	MaximumCollisionParticles: number;
	DamageThreshold: number;
	clone() : GeometryCollectionSizeSpecificData;
	static C(Other: UObject | any): GeometryCollectionSizeSpecificData;
}

declare class GeometryCollection extends UObject { 
	EnableClustering: boolean;
	ClusterGroupIndex: number;
	MaxClusterLevel: number;
	DamageThreshold: number[];
	bUseSizeSpecificDamageThreshold: boolean;
	PerClusterOnlyDamageThreshold: boolean;
	DamagePropagationData: GeometryCollectionDamagePropagationData;
	ClusterConnectionType: EClusterConnectionTypeEnum;
	ConnectionGraphBoundsFilteringMargin: number;
	GeometrySource: GeometryCollectionSource[];
	Materials: MaterialInterface[];
	EmbeddedGeometryExemplar: GeometryCollectionEmbeddedExemplar[];
	bUseFullPrecisionUVs: boolean;
	AutoInstanceMeshes: GeometryCollectionAutoInstanceMesh[];
	RootProxy: SoftObjectPath;
	bStripOnCook: boolean;
	EnableNanite: boolean;
	CollisionType: ECollisionTypeEnum;
	ImplicitType: EImplicitTypeEnum;
	MinLevelSetResolution: number;
	MaxLevelSetResolution: number;
	MinClusterLevelSetResolution: number;
	MaxClusterLevelSetResolution: number;
	CollisionObjectReductionPercentage: number;
	bMassAsDensity: boolean;
	Mass: number;
	MinimumMassClamp: number;
	bImportCollisionFromSource: boolean;
	CollisionParticlesFraction: number;
	MaximumCollisionParticles: number;
	bRemoveOnMaxSleep: boolean;
	MaximumSleepTime: Vector2D;
	RemovalDuration: Vector2D;
	bSlowMovingAsSleeping: boolean;
	SlowMovingVelocityThreshold: number;
	SizeSpecificData: GeometryCollectionSizeSpecificData[];
	EnableRemovePiecesOnFracture: boolean;
	RemoveOnFractureMaterials: MaterialInterface[];
	ThumbnailInfo: ThumbnailInfo;
	Dataflow: Dataflow;
	PersistentGuid: Guid;
	StateGuid: Guid;
	BoneSelectedMaterialIndex: number;
	static Load(ResourceName: string): GeometryCollection;
	static Find(Outer: UObject, ResourceName: string): GeometryCollection;
	static GetDefaultObject(): GeometryCollection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCollection;
	static C(Other: UObject | any): GeometryCollection;
}

declare type EObjectStateTypeEnum = 'Chaos_NONE' | 'Chaos_Object_Sleeping' | 'Chaos_Object_Kinematic' | 'Chaos_Object_Static' | 'Chaos_Object_Dynamic' | 'Chaos_Object_UserDefined' | 'Chaos_Max';
declare var EObjectStateTypeEnum : { Chaos_NONE:'Chaos_NONE',Chaos_Object_Sleeping:'Chaos_Object_Sleeping',Chaos_Object_Kinematic:'Chaos_Object_Kinematic',Chaos_Object_Static:'Chaos_Object_Static',Chaos_Object_Dynamic:'Chaos_Object_Dynamic',Chaos_Object_UserDefined:'Chaos_Object_UserDefined',Chaos_Max:'Chaos_Max', };
declare type EInitialVelocityTypeEnum = 'Chaos_Initial_Velocity_User_Defined' | 'Chaos_Initial_Velocity_None' | 'Chaos_Max';
declare var EInitialVelocityTypeEnum : { Chaos_Initial_Velocity_User_Defined:'Chaos_Initial_Velocity_User_Defined',Chaos_Initial_Velocity_None:'Chaos_Initial_Velocity_None',Chaos_Max:'Chaos_Max', };
declare type EGeometryCollectionCacheType = 'None' | 'Record' | 'Play' | 'RecordAndPlay' | 'EGeometryCollectionCacheType_MAX';
declare var EGeometryCollectionCacheType : { None:'None',Record:'Record',Play:'Play',RecordAndPlay:'RecordAndPlay',EGeometryCollectionCacheType_MAX:'EGeometryCollectionCacheType_MAX', };
declare class SolverCollisionData { 
	Location: Vector;
	AccumulatedImpulse: Vector;
	Normal: Vector;
	Velocity1: Vector;
	Velocity2: Vector;
	AngularVelocity1: Vector;
	AngularVelocity2: Vector;
	Mass1: number;
	Mass2: number;
	ParticleIndex: number;
	LevelsetIndex: number;
	ParticleIndexMesh: number;
	LevelsetIndexMesh: number;
	clone() : SolverCollisionData;
	static C(Other: UObject | any): SolverCollisionData;
}

declare class SolverBreakingData { 
	Location: Vector;
	Velocity: Vector;
	AngularVelocity: Vector;
	Mass: number;
	ParticleIndex: number;
	ParticleIndexMesh: number;
	clone() : SolverBreakingData;
	static C(Other: UObject | any): SolverBreakingData;
}

declare class SolverTrailingData { 
	Location: Vector;
	Velocity: Vector;
	AngularVelocity: Vector;
	Mass: number;
	ParticleIndex: number;
	ParticleIndexMesh: number;
	clone() : SolverTrailingData;
	static C(Other: UObject | any): SolverTrailingData;
}

declare class RecordedFrame { 
	Transforms: Transform[];
	TransformIndices: number[];
	PreviousTransformIndices: number[];
	DisabledFlags: boolean[];
	Collisions: SolverCollisionData[];
	Breakings: SolverBreakingData[];
	Trailings: Set<SolverTrailingData>;
	Timestamp: number;
	clone() : RecordedFrame;
	static C(Other: UObject | any): RecordedFrame;
}

declare class RecordedTransformTrack { 
	Records: RecordedFrame[];
	clone() : RecordedTransformTrack;
	static C(Other: UObject | any): RecordedTransformTrack;
}

declare class GeometryCollectionCache extends UObject { 
	RecordedData: RecordedTransformTrack;
	SupportedCollection: GeometryCollection;
	CompatibleCollectionState: Guid;
	static Load(ResourceName: string): GeometryCollectionCache;
	static Find(Outer: UObject, ResourceName: string): GeometryCollectionCache;
	static GetDefaultObject(): GeometryCollectionCache;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCollectionCache;
	static C(Other: UObject | any): GeometryCollectionCache;
}

declare class GeomComponentCacheParameters { 
	CacheMode: EGeometryCollectionCacheType;
	TargetCache: GeometryCollectionCache;
	ReverseCacheBeginTime: number;
	SaveCollisionData: boolean;
	DoGenerateCollisionData: boolean;
	CollisionDataSizeMax: number;
	DoCollisionDataSpatialHash: boolean;
	CollisionDataSpatialHashRadius: number;
	MaxCollisionPerCell: number;
	SaveBreakingData: boolean;
	DoGenerateBreakingData: boolean;
	BreakingDataSizeMax: number;
	DoBreakingDataSpatialHash: boolean;
	BreakingDataSpatialHashRadius: number;
	MaxBreakingPerCell: number;
	SaveTrailingData: boolean;
	DoGenerateTrailingData: boolean;
	TrailingDataSizeMax: number;
	TrailingMinSpeedThreshold: number;
	TrailingMinVolumeThreshold: number;
	clone() : GeomComponentCacheParameters;
	static C(Other: UObject | any): GeomComponentCacheParameters;
}

declare class ChaosBreakEvent { 
	Component: PrimitiveComponent;
	Location: Vector;
	Velocity: Vector;
	AngularVelocity: Vector;
	Mass: number;
	Index: number;
	clone() : ChaosBreakEvent;
	static C(Other: UObject | any): ChaosBreakEvent;
}

declare class ChaosRemovalEvent { 
	Component: PrimitiveComponent;
	Location: Vector;
	Mass: number;
	clone() : ChaosRemovalEvent;
	static C(Other: UObject | any): ChaosRemovalEvent;
}

declare class ChaosCrumblingEvent { 
	Component: PrimitiveComponent;
	Location: Vector;
	Orientation: Quat;
	LinearVelocity: Vector;
	AngularVelocity: Vector;
	Mass: number;
	LocalBounds: Box;
	Children: number[];
	clone() : ChaosCrumblingEvent;
	static C(Other: UObject | any): ChaosCrumblingEvent;
}

declare class GeometryCollectionRepData { 
	clone() : GeometryCollectionRepData;
	static C(Other: UObject | any): GeometryCollectionRepData;
}

declare class InstancedStaticMeshInstanceData { 
	Transform: Matrix;
	clone() : InstancedStaticMeshInstanceData;
	static C(Other: UObject | any): InstancedStaticMeshInstanceData;
}

declare class InstancedStaticMeshRandomSeed { 
	StartInstanceIndex: number;
	RandomSeed: number;
	clone() : InstancedStaticMeshRandomSeed;
	static C(Other: UObject | any): InstancedStaticMeshRandomSeed;
}

declare class InstancedStaticMeshMappingInfo { 
	clone() : InstancedStaticMeshMappingInfo;
	static C(Other: UObject | any): InstancedStaticMeshMappingInfo;
}

declare class InstancedStaticMeshComponent extends StaticMeshComponent { 
	PerInstanceSMData: InstancedStaticMeshInstanceData[];
	PerInstancePrevTransform: Matrix[];
	NumCustomDataFloats: number;
	PerInstanceSMCustomData: number[];
	InstancingRandomSeed: number;
	AdditionalRandomSeeds: InstancedStaticMeshRandomSeed[];
	InstanceStartCullDistance: number;
	InstanceEndCullDistance: number;
	InstanceReorderTable: number[];
	NumPendingLightmaps: number;
	CachedMappings: InstancedStaticMeshMappingInfo[];
	static Load(ResourceName: string): InstancedStaticMeshComponent;
	static Find(Outer: UObject, ResourceName: string): InstancedStaticMeshComponent;
	static GetDefaultObject(): InstancedStaticMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InstancedStaticMeshComponent;
	UpdateInstanceTransform(InstanceIndex: number,NewInstanceTransform: Transform,bWorldSpace: boolean,bMarkRenderStateDirty: boolean,bTeleport: boolean): boolean;
	SetCustomDataValue(InstanceIndex: number,CustomDataIndex: number,CustomDataValue: number,bMarkRenderStateDirty: boolean): boolean;
	SetCullDistances(StartCullDistance: number,EndCullDistance: number): void;
	RemoveInstances(InstancesToRemove: number[]): boolean;
	RemoveInstance(InstanceIndex: number): boolean;
	IsValidInstance(InstanceIndex: number): boolean;
	GetInstanceTransform(InstanceIndex: number,OutInstanceTransform?: Transform,bWorldSpace?: boolean): {OutInstanceTransform: Transform, $: boolean};
	GetInstancesOverlappingSphere(Center: Vector,Radius: number,bSphereInWorldSpace: boolean): number[];
	GetInstancesOverlappingBox(Box: Box,bBoxInWorldSpace: boolean): number[];
	GetInstanceCount(): number;
	ClearInstances(): void;
	BatchUpdateInstancesTransforms(StartInstanceIndex: number,NewInstancesTransforms: Transform[],bWorldSpace: boolean,bMarkRenderStateDirty: boolean,bTeleport: boolean): boolean;
	BatchUpdateInstancesTransform(StartInstanceIndex: number,NumInstances: number,NewInstancesTransform: Transform,bWorldSpace: boolean,bMarkRenderStateDirty: boolean,bTeleport: boolean): boolean;
	AddInstanceWorldSpace(WorldTransform: Transform): number;
	AddInstances(InstanceTransforms: Transform[],bShouldReturnIndices: boolean,bWorldSpace: boolean): number[];
	AddInstance(InstanceTransform: Transform,bWorldSpace: boolean): number;
	static C(Other: UObject | any): InstancedStaticMeshComponent;
	K2_AcquireEditorSMInstanceElementHandle(InstanceIndex: number,bAllowCreate: boolean): ScriptTypedElementHandle;
	static K2_AcquireEditorSMInstanceElementHandle(ISMComponent: InstancedStaticMeshComponent,InstanceIndex: number,bAllowCreate: boolean): ScriptTypedElementHandle;
}

declare type EGeometryCollectionPhysicsTypeEnum = 'Chaos_AngularVelocity' | 'Chaos_DynamicState' | 'Chaos_LinearVelocity' | 'Chaos_InitialAngularVelocity' | 'Chaos_InitialLinearVelocity' | 'Chaos_CollisionGroup' | 'Chaos_LinearForce' | 'Chaos_AngularTorque' | 'Chaos_DisableThreshold' | 'Chaos_SleepingThreshold' | 'Chaos_ExternalClusterStrain' | 'Chaos_InternalClusterStrain' | 'Chaos_LinearImpulse' | 'Chaos_Max';
declare var EGeometryCollectionPhysicsTypeEnum : { Chaos_AngularVelocity:'Chaos_AngularVelocity',Chaos_DynamicState:'Chaos_DynamicState',Chaos_LinearVelocity:'Chaos_LinearVelocity',Chaos_InitialAngularVelocity:'Chaos_InitialAngularVelocity',Chaos_InitialLinearVelocity:'Chaos_InitialLinearVelocity',Chaos_CollisionGroup:'Chaos_CollisionGroup',Chaos_LinearForce:'Chaos_LinearForce',Chaos_AngularTorque:'Chaos_AngularTorque',Chaos_DisableThreshold:'Chaos_DisableThreshold',Chaos_SleepingThreshold:'Chaos_SleepingThreshold',Chaos_ExternalClusterStrain:'Chaos_ExternalClusterStrain',Chaos_InternalClusterStrain:'Chaos_InternalClusterStrain',Chaos_LinearImpulse:'Chaos_LinearImpulse',Chaos_Max:'Chaos_Max', };
declare class GeometryCollectionComponent extends MeshComponent { 
	ChaosSolverActor: ChaosSolverActor;
	RestCollection: GeometryCollection;
	InitializationFields: FieldSystemActor[];
	Simulating: boolean;
	ObjectType: EObjectStateTypeEnum;
	bForceMotionBlur: boolean;
	EnableClustering: boolean;
	ClusterGroupIndex: number;
	MaxClusterLevel: number;
	DamageThreshold: number[];
	bUseSizeSpecificDamageThreshold: boolean;
	DamagePropagationData: GeometryCollectionDamagePropagationData;
	bAllowRemovalOnSleep: boolean;
	bAllowRemovalOnBreak: boolean;
	ClusterConnectionType: EClusterConnectionTypeEnum;
	CollisionGroup: number;
	CollisionSampleFraction: number;
	LinearEtherDrag: number;
	AngularEtherDrag: number;
	PhysicalMaterial: ChaosPhysicalMaterial;
	InitialVelocityType: EInitialVelocityTypeEnum;
	InitialLinearVelocity: Vector;
	InitialAngularVelocity: Vector;
	PhysicalMaterialOverride: PhysicalMaterial;
	CacheParameters: GeomComponentCacheParameters;
	RestTransforms: Transform[];
	NotifyGeometryCollectionPhysicsStateChange: UnrealEngineMulticastDelegate<(FracturedComponent: GeometryCollectionComponent) => void>;
	NotifyGeometryCollectionPhysicsLoadingStateChange: UnrealEngineMulticastDelegate<(FracturedComponent: GeometryCollectionComponent) => void>;
	OnChaosBreakEvent: UnrealEngineMulticastDelegate<(BreakEvent: ChaosBreakEvent) => void>;
	OnChaosRemovalEvent: UnrealEngineMulticastDelegate<(RemovalEvent: ChaosRemovalEvent) => void>;
	OnChaosCrumblingEvent: UnrealEngineMulticastDelegate<(CrumbleEvent: ChaosCrumblingEvent) => void>;
	DesiredCacheTime: number;
	CachePlayback: boolean;
	OnChaosPhysicsCollision: UnrealEngineMulticastDelegate<(CollisionInfo: ChaosPhysicsCollisionInfo) => void>;
	bNotifyBreaks: boolean;
	bNotifyCollisions: boolean;
	bNotifyTrailing: boolean;
	bNotifyRemovals: boolean;
	bNotifyCrumblings: boolean;
	bCrumblingEventIncludesChildren: boolean;
	bStoreVelocities: boolean;
	bShowBoneColors: boolean;
	bEnableRunTimeDataCollection: boolean;
	RunTimeDataCollectionGuid: Guid;
	ISMPool: GeometryCollectionISMPoolActor;
	bEnableReplication: boolean;
	bEnableAbandonAfterLevel: boolean;
	ReplicationAbandonClusterLevel: number;
	ReplicationAbandonAfterLevel: number;
	RepData: GeometryCollectionRepData;
	SelectedBones: number[];
	HighlightedBones: number[];
	DummyBodySetup: BodySetup;
	EditorActor: Actor;
	EmbeddedGeometryComponents: InstancedStaticMeshComponent[];
	static Load(ResourceName: string): GeometryCollectionComponent;
	static Find(Outer: UObject, ResourceName: string): GeometryCollectionComponent;
	static GetDefaultObject(): GeometryCollectionComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCollectionComponent;
	SetRestCollection(RestCollectionIn: GeometryCollection): void;
	SetNotifyRemovals(bNewNotifyRemovals: boolean): void;
	SetNotifyCrumblings(bNewNotifyCrumblings: boolean): void;
	SetNotifyBreaks(bNewNotifyBreaks: boolean): void;
	RemoveAllAnchors(): void;
	ReceivePhysicsCollision(CollisionInfo: ChaosPhysicsCollisionInfo): void;
	GetMassAndExtents(ItemIndex: number,OutMass?: number,OutExtents?: Box): {OutMass: number, OutExtents: Box};
	GetInitialLevel(ItemIndex: number): number;
	CrumbleCluster(ItemIndex: number): void;
	CrumbleActiveClusters(): void;
	ApplyPhysicsField(Enabled: boolean,Target: EGeometryCollectionPhysicsTypeEnum,MetaData: FieldSystemMetaData,Field: FieldNodeBase): void;
	ApplyLinearVelocity(ItemIndex: number,LinearVelocity: Vector): void;
	ApplyKinematicField(Radius: number,Position: Vector): void;
	ApplyInternalStrain(ItemIndex: number,Location: Vector,Radius: number,PropagationDepth: number,PropagationFactor: number,Strain: number): void;
	ApplyExternalStrain(ItemIndex: number,Location: Vector,Radius: number,PropagationDepth: number,PropagationFactor: number,Strain: number): void;
	ApplyBreakingLinearVelocity(ItemIndex: number,LinearVelocity: Vector): void;
	ApplyBreakingAngularVelocity(ItemIndex: number,AngularVelocity: Vector): void;
	ApplyAngularVelocity(ItemIndex: number,AngularVelocity: Vector): void;
	static C(Other: UObject | any): GeometryCollectionComponent;
}

declare class GeometryCollectionDebugDrawWarningMessage { 
	clone() : GeometryCollectionDebugDrawWarningMessage;
	static C(Other: UObject | any): GeometryCollectionDebugDrawWarningMessage;
}

declare class GeometryCollectionDebugDrawActorSelectedRigidBody { 
	ID: number;
	Solver: ChaosSolverActor;
	GeometryCollection: GeometryCollectionActor;
	clone() : GeometryCollectionDebugDrawActorSelectedRigidBody;
	static C(Other: UObject | any): GeometryCollectionDebugDrawActorSelectedRigidBody;
}

declare type EGeometryCollectionDebugDrawActorHideGeometry = 'HideNone' | 'HideWithCollision' | 'HideSelected' | 'HideWholeCollection' | 'HideAll' | 'EGeometryCollectionDebugDrawActorHideGeometry_MAX';
declare var EGeometryCollectionDebugDrawActorHideGeometry : { HideNone:'HideNone',HideWithCollision:'HideWithCollision',HideSelected:'HideSelected',HideWholeCollection:'HideWholeCollection',HideAll:'HideAll',EGeometryCollectionDebugDrawActorHideGeometry_MAX:'EGeometryCollectionDebugDrawActorHideGeometry_MAX', };
declare class GeometryCollectionDebugDrawActor extends Actor { 
	WarningMessage: GeometryCollectionDebugDrawWarningMessage;
	SelectedRigidBody: GeometryCollectionDebugDrawActorSelectedRigidBody;
	bDebugDrawWholeCollection: boolean;
	bDebugDrawHierarchy: boolean;
	bDebugDrawClustering: boolean;
	HideGeometry: EGeometryCollectionDebugDrawActorHideGeometry;
	bShowRigidBodyId: boolean;
	bShowRigidBodyCollision: boolean;
	bCollisionAtOrigin: boolean;
	bShowRigidBodyTransform: boolean;
	bShowRigidBodyInertia: boolean;
	bShowRigidBodyVelocity: boolean;
	bShowRigidBodyForce: boolean;
	bShowRigidBodyInfos: boolean;
	bShowTransformIndex: boolean;
	bShowTransform: boolean;
	bShowParent: boolean;
	bShowLevel: boolean;
	bShowConnectivityEdges: boolean;
	bShowGeometryIndex: boolean;
	bShowGeometryTransform: boolean;
	bShowBoundingBox: boolean;
	bShowFaces: boolean;
	bShowFaceIndices: boolean;
	bShowFaceNormals: boolean;
	bShowSingleFace: boolean;
	SingleFaceIndex: number;
	bShowVertices: boolean;
	bShowVertexIndices: boolean;
	bShowVertexNormals: boolean;
	bUseActiveVisualization: boolean;
	PointThickness: number;
	LineThickness: number;
	bTextShadow: boolean;
	TextScale: number;
	NormalScale: number;
	AxisScale: number;
	ArrowScale: number;
	RigidBodyIdColor: Color;
	RigidBodyTransformScale: number;
	RigidBodyCollisionColor: Color;
	RigidBodyInertiaColor: Color;
	RigidBodyVelocityColor: Color;
	RigidBodyForceColor: Color;
	RigidBodyInfoColor: Color;
	TransformIndexColor: Color;
	TransformScale: number;
	LevelColor: Color;
	ParentColor: Color;
	ConnectivityEdgeThickness: number;
	GeometryIndexColor: Color;
	GeometryTransformScale: number;
	BoundingBoxColor: Color;
	FaceColor: Color;
	FaceIndexColor: Color;
	FaceNormalColor: Color;
	SingleFaceColor: Color;
	VertexColor: Color;
	VertexIndexColor: Color;
	VertexNormalColor: Color;
	SpriteComponent: BillboardComponent;
	static GetDefaultObject(): GeometryCollectionDebugDrawActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCollectionDebugDrawActor;
	static C(Other: UObject | any): GeometryCollectionDebugDrawActor;
}

declare class GeometryCollectionRenderLevelSetActor extends Actor { 
	TargetVolumeTexture: VolumeTexture;
	RayMarchMaterial: Material;
	SurfaceTolerance: number;
	Isovalue: number;
	Enabled: boolean;
	RenderVolumeBoundingBox: boolean;
	static GetDefaultObject(): GeometryCollectionRenderLevelSetActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCollectionRenderLevelSetActor;
	static C(Other: UObject | any): GeometryCollectionRenderLevelSetActor;
}

declare class GeometryCollectionDebugDrawComponent extends ActorComponent { 
	GeometryCollectionDebugDrawActor: GeometryCollectionDebugDrawActor;
	GeometryCollectionRenderLevelSetActor: GeometryCollectionRenderLevelSetActor;
	static Load(ResourceName: string): GeometryCollectionDebugDrawComponent;
	static Find(Outer: UObject, ResourceName: string): GeometryCollectionDebugDrawComponent;
	static GetDefaultObject(): GeometryCollectionDebugDrawComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCollectionDebugDrawComponent;
	static C(Other: UObject | any): GeometryCollectionDebugDrawComponent;
}

declare class GeometryCollectionActor extends Actor { 
	GeometryCollectionComponent: GeometryCollectionComponent;
	GeometryCollectionDebugDrawComponent: GeometryCollectionDebugDrawComponent;
	static GetDefaultObject(): GeometryCollectionActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCollectionActor;
	RaycastSingle(Start: Vector,End: Vector,OutHit?: HitResult): {OutHit: HitResult, $: boolean};
	static C(Other: UObject | any): GeometryCollectionActor;
}

declare class ChaosCollisionEventData { 
	Location: Vector;
	Normal: Vector;
	Velocity1: Vector;
	Velocity2: Vector;
	Mass1: number;
	Mass2: number;
	Impulse: Vector;
	clone() : ChaosCollisionEventData;
	static C(Other: UObject | any): ChaosCollisionEventData;
}

declare class ChaosBreakingEventData { 
	Location: Vector;
	Velocity: Vector;
	Mass: number;
	clone() : ChaosBreakingEventData;
	static C(Other: UObject | any): ChaosBreakingEventData;
}

declare class ChaosTrailingEventData { 
	Location: Vector;
	Velocity: Vector;
	AngularVelocity: Vector;
	Mass: number;
	ParticleIndex: number;
	clone() : ChaosTrailingEventData;
	static C(Other: UObject | any): ChaosTrailingEventData;
}

declare class ChaosRemovalEventData { 
	Location: Vector;
	Mass: number;
	ParticleIndex: number;
	clone() : ChaosRemovalEventData;
	static C(Other: UObject | any): ChaosRemovalEventData;
}

declare class ChaosDestructionListener extends SceneComponent { 
	bIsCollisionEventListeningEnabled: boolean;
	bIsBreakingEventListeningEnabled: boolean;
	bIsTrailingEventListeningEnabled: boolean;
	bIsRemovalEventListeningEnabled: boolean;
	CollisionEventRequestSettings: ChaosCollisionEventRequestSettings;
	BreakingEventRequestSettings: ChaosBreakingEventRequestSettings;
	TrailingEventRequestSettings: ChaosTrailingEventRequestSettings;
	RemovalEventRequestSettings: ChaosRemovalEventRequestSettings;
	ChaosSolverActors: Set<ChaosSolverActor>;
	GeometryCollectionActors: Set<GeometryCollectionActor>;
	OnCollisionEvents: UnrealEngineMulticastDelegate<(CollisionEvents: ChaosCollisionEventData[]) => void>;
	OnBreakingEvents: UnrealEngineMulticastDelegate<(BreakingEvents: ChaosBreakingEventData[]) => void>;
	OnTrailingEvents: UnrealEngineMulticastDelegate<(TrailingEvents: ChaosTrailingEventData[]) => void>;
	OnRemovalEvents: UnrealEngineMulticastDelegate<(RemovalEvents: ChaosRemovalEventData[]) => void>;
	static Load(ResourceName: string): ChaosDestructionListener;
	static Find(Outer: UObject, ResourceName: string): ChaosDestructionListener;
	static GetDefaultObject(): ChaosDestructionListener;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosDestructionListener;
	SortTrailingEvents(TrailingEvents?: ChaosTrailingEventData[],SortMethod?: EChaosTrailingSortMethod): {TrailingEvents: ChaosTrailingEventData[]};
	SortRemovalEvents(RemovalEvents?: ChaosRemovalEventData[],SortMethod?: EChaosRemovalSortMethod): {RemovalEvents: ChaosRemovalEventData[]};
	SortCollisionEvents(CollisionEvents?: ChaosCollisionEventData[],SortMethod?: EChaosCollisionSortMethod): {CollisionEvents: ChaosCollisionEventData[]};
	SortBreakingEvents(BreakingEvents?: ChaosBreakingEventData[],SortMethod?: EChaosBreakingSortMethod): {BreakingEvents: ChaosBreakingEventData[]};
	SetTrailingEventRequestSettings(InSettings: ChaosTrailingEventRequestSettings): void;
	SetTrailingEventEnabled(bIsEnabled: boolean): void;
	SetRemovalEventRequestSettings(InSettings: ChaosRemovalEventRequestSettings): void;
	SetRemovalEventEnabled(bIsEnabled: boolean): void;
	SetCollisionEventRequestSettings(InSettings: ChaosCollisionEventRequestSettings): void;
	SetCollisionEventEnabled(bIsEnabled: boolean): void;
	SetBreakingEventRequestSettings(InSettings: ChaosBreakingEventRequestSettings): void;
	SetBreakingEventEnabled(bIsEnabled: boolean): void;
	RemoveGeometryCollectionActor(GeometryCollectionActor: GeometryCollectionActor): void;
	RemoveChaosSolverActor(ChaosSolverActor: ChaosSolverActor): void;
	IsEventListening(): boolean;
	AddGeometryCollectionActor(GeometryCollectionActor: GeometryCollectionActor): void;
	AddChaosSolverActor(ChaosSolverActor: ChaosSolverActor): void;
	static C(Other: UObject | any): ChaosDestructionListener;
}

declare type EAnimExecutionContextConversionResult = 'Succeeded' | 'Failed' | 'EAnimExecutionContextConversionResult_MAX';
declare var EAnimExecutionContextConversionResult : { Succeeded:'Succeeded',Failed:'Failed',EAnimExecutionContextConversionResult_MAX:'EAnimExecutionContextConversionResult_MAX', };
declare class AnimComponentSpacePoseContext extends AnimExecutionContext { 
	clone() : AnimComponentSpacePoseContext;
	static C(Other: UObject | any): AnimComponentSpacePoseContext;
}

declare class AnimInitializationContext extends AnimExecutionContext { 
	clone() : AnimInitializationContext;
	static C(Other: UObject | any): AnimInitializationContext;
}

declare class AnimPoseContext extends AnimExecutionContext { 
	clone() : AnimPoseContext;
	static C(Other: UObject | any): AnimPoseContext;
}

declare class AnimExecutionContext { 
	clone() : AnimExecutionContext;
	static C(Other: UObject | any): AnimExecutionContext;
	ConvertToComponentSpacePoseContext(result?: EAnimExecutionContextConversionResult): {result: EAnimExecutionContextConversionResult, $: AnimComponentSpacePoseContext};
	ConvertToInitializationContext(result?: EAnimExecutionContextConversionResult): {result: EAnimExecutionContextConversionResult, $: AnimInitializationContext};
	ConvertToPoseContext(result?: EAnimExecutionContextConversionResult): {result: EAnimExecutionContextConversionResult, $: AnimPoseContext};
	ConvertToUpdateContext(result?: EAnimExecutionContextConversionResult): {result: EAnimExecutionContextConversionResult, $: AnimUpdateContext};
	GetAnimInstance(): AnimInstance;
	static ConvertToComponentSpacePoseContext(Context: AnimExecutionContext,result?: EAnimExecutionContextConversionResult): {result: EAnimExecutionContextConversionResult, $: AnimComponentSpacePoseContext};
	static ConvertToInitializationContext(Context: AnimExecutionContext,result?: EAnimExecutionContextConversionResult): {result: EAnimExecutionContextConversionResult, $: AnimInitializationContext};
	static ConvertToPoseContext(Context: AnimExecutionContext,result?: EAnimExecutionContextConversionResult): {result: EAnimExecutionContextConversionResult, $: AnimPoseContext};
	static ConvertToUpdateContext(Context: AnimExecutionContext,result?: EAnimExecutionContextConversionResult): {result: EAnimExecutionContextConversionResult, $: AnimUpdateContext};
	static GetAnimInstance(Context: AnimExecutionContext): AnimInstance;
}

declare type ETransitionLogicType = 'TLT_StandardBlend' | 'TLT_Inertialization' | 'TLT_Custom' | 'TLT_MAX';
declare var ETransitionLogicType : { TLT_StandardBlend:'TLT_StandardBlend',TLT_Inertialization:'TLT_Inertialization',TLT_Custom:'TLT_Custom',TLT_MAX:'TLT_MAX', };
declare class AnimUpdateContext extends AnimExecutionContext { 
	clone() : AnimUpdateContext;
	static C(Other: UObject | any): AnimUpdateContext;
	SetSequenceWithInertialBlending(SequencePlayer: SequencePlayerReference,Sequence: AnimSequenceBase,BlendTime: number): SequencePlayerReference;
	AdvanceTime(SequenceEvaluator: SequenceEvaluatorReference,PlayRate: number): SequenceEvaluatorReference;
	SetSequenceWithInertialBlending(SequenceEvaluator: SequenceEvaluatorReference,Sequence: AnimSequenceBase,BlendTime: number): SequenceEvaluatorReference;
	GetCurrentWeight(): number;
	GetDeltaTime(): number;
	GetRelevantAnimTimeRemaining(UNode: AnimationStateResultReference): number;
	GetRelevantAnimTimeRemainingFraction(UNode: AnimationStateResultReference): number;
	GetState(UNode: AnimationStateMachineReference): string;
	IsStateBlendingIn(UNode: AnimationStateResultReference): boolean;
	IsStateBlendingOut(UNode: AnimationStateResultReference): boolean;
	SetState(UNode: AnimationStateMachineReference,TargetState: string,Duration: number,BlendType: ETransitionLogicType,BlendProfile: BlendProfile,AlphaBlendOption: EAlphaBlendOption,CustomBlendCurve: CurveFloat): void;
	SetBlendMask(LayeredBoneBlend: LayeredBoneBlendReference,PoseIndex: number,BlendMaskName: string): LayeredBoneBlendReference;
	SetBlendSpaceWithInertialBlending(BlendSpacePlayer: BlendSpacePlayerReference,BlendSpace: BlendSpace,BlendTime: number): BlendSpacePlayerReference;
	static SetSequenceWithInertialBlending(UpdateContext: AnimUpdateContext,SequencePlayer: SequencePlayerReference,Sequence: AnimSequenceBase,BlendTime: number): SequencePlayerReference;
	static AdvanceTime(UpdateContext: AnimUpdateContext,SequenceEvaluator: SequenceEvaluatorReference,PlayRate: number): SequenceEvaluatorReference;
	static SetSequenceWithInertialBlending(UpdateContext: AnimUpdateContext,SequenceEvaluator: SequenceEvaluatorReference,Sequence: AnimSequenceBase,BlendTime: number): SequenceEvaluatorReference;
	static GetCurrentWeight(Context: AnimUpdateContext): number;
	static GetDeltaTime(Context: AnimUpdateContext): number;
	static GetRelevantAnimTimeRemaining(UpdateContext: AnimUpdateContext,UNode: AnimationStateResultReference): number;
	static GetRelevantAnimTimeRemainingFraction(UpdateContext: AnimUpdateContext,UNode: AnimationStateResultReference): number;
	static GetState(UpdateContext: AnimUpdateContext,UNode: AnimationStateMachineReference): string;
	static IsStateBlendingIn(UpdateContext: AnimUpdateContext,UNode: AnimationStateResultReference): boolean;
	static IsStateBlendingOut(UpdateContext: AnimUpdateContext,UNode: AnimationStateResultReference): boolean;
	static SetState(UpdateContext: AnimUpdateContext,UNode: AnimationStateMachineReference,TargetState: string,Duration: number,BlendType: ETransitionLogicType,BlendProfile: BlendProfile,AlphaBlendOption: EAlphaBlendOption,CustomBlendCurve: CurveFloat): void;
	static SetBlendMask(UpdateContext: AnimUpdateContext,LayeredBoneBlend: LayeredBoneBlendReference,PoseIndex: number,BlendMaskName: string): LayeredBoneBlendReference;
	static SetBlendSpaceWithInertialBlending(UpdateContext: AnimUpdateContext,BlendSpacePlayer: BlendSpacePlayerReference,BlendSpace: BlendSpace,BlendTime: number): BlendSpacePlayerReference;
}

declare class BlendSpacePlayerLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): BlendSpacePlayerLibrary;
	static Find(Outer: UObject, ResourceName: string): BlendSpacePlayerLibrary;
	static GetDefaultObject(): BlendSpacePlayerLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlendSpacePlayerLibrary;
	static ShouldResetPlayTimeWhenBlendSpaceChanges(BlendSpacePlayer: BlendSpacePlayerReference): boolean;
	static SetResetPlayTimeWhenBlendSpaceChanges(BlendSpacePlayer: BlendSpacePlayerReference,bReset: boolean): BlendSpacePlayerReference;
	static SetPlayRate(BlendSpacePlayer: BlendSpacePlayerReference,PlayRate: number): BlendSpacePlayerReference;
	static SetLoop(BlendSpacePlayer: BlendSpacePlayerReference,bLoop: boolean): BlendSpacePlayerReference;
	static SetBlendSpaceWithInertialBlending(UpdateContext: AnimUpdateContext,BlendSpacePlayer: BlendSpacePlayerReference,BlendSpace: BlendSpace,BlendTime: number): BlendSpacePlayerReference;
	static SetBlendSpace(BlendSpacePlayer: BlendSpacePlayerReference,BlendSpace: BlendSpace): BlendSpacePlayerReference;
	static GetStartPosition(BlendSpacePlayer: BlendSpacePlayerReference): number;
	static GetPosition(BlendSpacePlayer: BlendSpacePlayerReference): Vector;
	static GetPlayRate(BlendSpacePlayer: BlendSpacePlayerReference): number;
	static GetLoop(BlendSpacePlayer: BlendSpacePlayerReference): boolean;
	static GetBlendSpace(BlendSpacePlayer: BlendSpacePlayerReference): BlendSpace;
	static ConvertToBlendSpacePlayerPure(UNode: AnimNodeReference,BlendSpacePlayer?: BlendSpacePlayerReference,result?: boolean): {BlendSpacePlayer: BlendSpacePlayerReference, result: boolean};
	static ConvertToBlendSpacePlayer(UNode: AnimNodeReference,result?: EAnimNodeReferenceConversionResult): {result: EAnimNodeReferenceConversionResult, $: BlendSpacePlayerReference};
	static C(Other: UObject | any): BlendSpacePlayerLibrary;
}

declare class LayeredBoneBlendLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): LayeredBoneBlendLibrary;
	static Find(Outer: UObject, ResourceName: string): LayeredBoneBlendLibrary;
	static GetDefaultObject(): LayeredBoneBlendLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LayeredBoneBlendLibrary;
	static SetBlendMask(UpdateContext: AnimUpdateContext,LayeredBoneBlend: LayeredBoneBlendReference,PoseIndex: number,BlendMaskName: string): LayeredBoneBlendReference;
	static GetNumPoses(LayeredBoneBlend: LayeredBoneBlendReference): number;
	static ConvertToLayeredBoneBlend(UNode: AnimNodeReference,result?: EAnimNodeReferenceConversionResult): {result: EAnimNodeReferenceConversionResult, $: LayeredBoneBlendReference};
	static ConvertToLayeredBlendPerBonePure(UNode: AnimNodeReference,LayeredBoneBlend?: LayeredBoneBlendReference,result?: boolean): {LayeredBoneBlend: LayeredBoneBlendReference, result: boolean};
	static C(Other: UObject | any): LayeredBoneBlendLibrary;
}

declare class AnimationStateMachineLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): AnimationStateMachineLibrary;
	static Find(Outer: UObject, ResourceName: string): AnimationStateMachineLibrary;
	static GetDefaultObject(): AnimationStateMachineLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationStateMachineLibrary;
	static SetState(UpdateContext: AnimUpdateContext,UNode: AnimationStateMachineReference,TargetState: string,Duration: number,BlendType: ETransitionLogicType,BlendProfile: BlendProfile,AlphaBlendOption: EAlphaBlendOption,CustomBlendCurve: CurveFloat): void;
	static IsStateBlendingOut(UpdateContext: AnimUpdateContext,UNode: AnimationStateResultReference): boolean;
	static IsStateBlendingIn(UpdateContext: AnimUpdateContext,UNode: AnimationStateResultReference): boolean;
	static GetState(UpdateContext: AnimUpdateContext,UNode: AnimationStateMachineReference): string;
	static GetRelevantAnimTimeRemainingFraction(UpdateContext: AnimUpdateContext,UNode: AnimationStateResultReference): number;
	static GetRelevantAnimTimeRemaining(UpdateContext: AnimUpdateContext,UNode: AnimationStateResultReference): number;
	static ConvertToAnimationStateResultPure(UNode: AnimNodeReference,AnimationState?: AnimationStateResultReference,result?: boolean): {AnimationState: AnimationStateResultReference, result: boolean};
	static ConvertToAnimationStateResult(UNode: AnimNodeReference,AnimationState?: AnimationStateResultReference,result?: EAnimNodeReferenceConversionResult): {AnimationState: AnimationStateResultReference, result: EAnimNodeReferenceConversionResult};
	static ConvertToAnimationStateMachinePure(UNode: AnimNodeReference,AnimationState?: AnimationStateMachineReference,result?: boolean): {AnimationState: AnimationStateMachineReference, result: boolean};
	static ConvertToAnimationStateMachine(UNode: AnimNodeReference,AnimationState?: AnimationStateMachineReference,result?: EAnimNodeReferenceConversionResult): {AnimationState: AnimationStateMachineReference, result: EAnimNodeReferenceConversionResult};
	static C(Other: UObject | any): AnimationStateMachineLibrary;
}

declare class AnimExecutionContextLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): AnimExecutionContextLibrary;
	static Find(Outer: UObject, ResourceName: string): AnimExecutionContextLibrary;
	static GetDefaultObject(): AnimExecutionContextLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimExecutionContextLibrary;
	Prototype_ThreadSafeAnimUpdateCall(Context: AnimUpdateContext,UNode: AnimNodeReference): void;
	Prototype_ThreadSafeAnimNodeCall(Context: AnimExecutionContext,UNode: AnimNodeReference): void;
	static GetDeltaTime(Context: AnimUpdateContext): number;
	static GetCurrentWeight(Context: AnimUpdateContext): number;
	static GetAnimNodeReference(Instance: AnimInstance,Index: number): AnimNodeReference;
	static GetAnimInstance(Context: AnimExecutionContext): AnimInstance;
	static ConvertToUpdateContext(Context: AnimExecutionContext,result?: EAnimExecutionContextConversionResult): {result: EAnimExecutionContextConversionResult, $: AnimUpdateContext};
	static ConvertToPoseContext(Context: AnimExecutionContext,result?: EAnimExecutionContextConversionResult): {result: EAnimExecutionContextConversionResult, $: AnimPoseContext};
	static ConvertToInitializationContext(Context: AnimExecutionContext,result?: EAnimExecutionContextConversionResult): {result: EAnimExecutionContextConversionResult, $: AnimInitializationContext};
	static ConvertToComponentSpacePoseContext(Context: AnimExecutionContext,result?: EAnimExecutionContextConversionResult): {result: EAnimExecutionContextConversionResult, $: AnimComponentSpacePoseContext};
	static C(Other: UObject | any): AnimExecutionContextLibrary;
}

declare class AnimNotify_PlayMontageNotify extends AnimNotify { 
	NotifyName: string;
	static Load(ResourceName: string): AnimNotify_PlayMontageNotify;
	static Find(Outer: UObject, ResourceName: string): AnimNotify_PlayMontageNotify;
	static GetDefaultObject(): AnimNotify_PlayMontageNotify;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimNotify_PlayMontageNotify;
	static C(Other: UObject | any): AnimNotify_PlayMontageNotify;
}

declare class AnimNotify_PlayMontageNotifyWindow extends AnimNotifyState { 
	NotifyName: string;
	static Load(ResourceName: string): AnimNotify_PlayMontageNotifyWindow;
	static Find(Outer: UObject, ResourceName: string): AnimNotify_PlayMontageNotifyWindow;
	static GetDefaultObject(): AnimNotify_PlayMontageNotifyWindow;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimNotify_PlayMontageNotifyWindow;
	static C(Other: UObject | any): AnimNotify_PlayMontageNotifyWindow;
}

declare class AnimSequencerInstance extends AnimInstance { 
	static Load(ResourceName: string): AnimSequencerInstance;
	static Find(Outer: UObject, ResourceName: string): AnimSequencerInstance;
	static GetDefaultObject(): AnimSequencerInstance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimSequencerInstance;
	static C(Other: UObject | any): AnimSequencerInstance;
}

declare class PositionHistory { 
	Positions: Vector[];
	Range: number;
	clone() : PositionHistory;
	static C(Other: UObject | any): PositionHistory;
}

declare type EEasingFuncType = 'Linear' | 'Sinusoidal' | 'Cubic' | 'QuadraticInOut' | 'CubicInOut' | 'HermiteCubic' | 'QuarticInOut' | 'QuinticInOut' | 'CircularIn' | 'CircularOut' | 'CircularInOut' | 'ExpIn' | 'ExpOut' | 'ExpInOut' | 'CustomCurve' | 'EEasingFuncType_MAX';
declare var EEasingFuncType : { Linear:'Linear',Sinusoidal:'Sinusoidal',Cubic:'Cubic',QuadraticInOut:'QuadraticInOut',CubicInOut:'CubicInOut',HermiteCubic:'HermiteCubic',QuarticInOut:'QuarticInOut',QuinticInOut:'QuinticInOut',CircularIn:'CircularIn',CircularOut:'CircularOut',CircularInOut:'CircularInOut',ExpIn:'ExpIn',ExpOut:'ExpOut',ExpInOut:'ExpInOut',CustomCurve:'CustomCurve',EEasingFuncType_MAX:'EEasingFuncType_MAX', };
declare class KismetAnimationLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): KismetAnimationLibrary;
	static Find(Outer: UObject, ResourceName: string): KismetAnimationLibrary;
	static GetDefaultObject(): KismetAnimationLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): KismetAnimationLibrary;
	static K2_TwoBoneIK(RootPos: Vector,JointPos: Vector,EndPos: Vector,JointTarget: Vector,Effector: Vector,OutJointPos?: Vector,OutEndPos?: Vector,bAllowStretching?: boolean,StartStretchRatio?: number,MaxStretchScale?: number): {OutJointPos: Vector, OutEndPos: Vector};
	static K2_StartProfilingTimer(): void;
	static K2_MakePerlinNoiseVectorAndRemap(X: number,Y: number,Z: number,RangeOutMinX: number,RangeOutMaxX: number,RangeOutMinY: number,RangeOutMaxY: number,RangeOutMinZ: number,RangeOutMaxZ: number): Vector;
	static K2_MakePerlinNoiseAndRemap(Value: number,RangeOutMin: number,RangeOutMax: number): number;
	static K2_LookAt(CurrentTransform: Transform,TargetPosition: Vector,LookAtVector: Vector,bUseUpVector: boolean,UpVector: Vector,ClampConeInDegree: number): Transform;
	static K2_EndProfilingTimer(bLog: boolean,LogPrefix: string): number;
	static K2_DistanceBetweenTwoSocketsAndMapRange(Component: SkeletalMeshComponent,SocketOrBoneNameA: string,SocketSpaceA: ERelativeTransformSpace,SocketOrBoneNameB: string,SocketSpaceB: ERelativeTransformSpace,bRemapRange: boolean,InRangeMin: number,InRangeMax: number,OutRangeMin: number,OutRangeMax: number): number;
	static K2_DirectionBetweenSockets(Component: SkeletalMeshComponent,SocketOrBoneNameFrom: string,SocketOrBoneNameTo: string): Vector;
	static K2_CalculateVelocityFromSockets(DeltaSeconds: number,Component: SkeletalMeshComponent,SocketOrBoneName: string,ReferenceSocketOrBone: string,SocketSpace: ERelativeTransformSpace,OffsetInBoneSpace: Vector,History?: PositionHistory,NumberOfSamples?: number,VelocityMin?: number,VelocityMax?: number,EasingType?: EEasingFuncType,CustomCurve?: RuntimeFloatCurve): {History: PositionHistory, $: number};
	static K2_CalculateVelocityFromPositionHistory(DeltaSeconds: number,Position: Vector,History?: PositionHistory,NumberOfSamples?: number,VelocityMin?: number,VelocityMax?: number): {History: PositionHistory, $: number};
	static CalculateDirection(Velocity: Vector,BaseRotation: Rotator): number;
	static C(Other: UObject | any): KismetAnimationLibrary;
}

declare class LinkedAnimGraphLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): LinkedAnimGraphLibrary;
	static Find(Outer: UObject, ResourceName: string): LinkedAnimGraphLibrary;
	static GetDefaultObject(): LinkedAnimGraphLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LinkedAnimGraphLibrary;
	static HasLinkedAnimInstance(UNode: LinkedAnimGraphReference): boolean;
	static GetLinkedAnimInstance(UNode: LinkedAnimGraphReference): AnimInstance;
	static ConvertToLinkedAnimGraphPure(UNode: AnimNodeReference,LinkedAnimGraph?: LinkedAnimGraphReference,result?: boolean): {LinkedAnimGraph: LinkedAnimGraphReference, result: boolean};
	static ConvertToLinkedAnimGraph(UNode: AnimNodeReference,result?: EAnimNodeReferenceConversionResult): {result: EAnimNodeReferenceConversionResult, $: LinkedAnimGraphReference};
	static C(Other: UObject | any): LinkedAnimGraphLibrary;
}

declare class BranchingPointNotifyPayload { 
	clone() : BranchingPointNotifyPayload;
	static C(Other: UObject | any): BranchingPointNotifyPayload;
}

declare class PlayMontageCallbackProxy extends UObject { 
	OnCompleted: UnrealEngineMulticastDelegate<(NotifyName: string) => void>;
	OnBlendOut: UnrealEngineMulticastDelegate<(NotifyName: string) => void>;
	OnInterrupted: UnrealEngineMulticastDelegate<(NotifyName: string) => void>;
	OnNotifyBegin: UnrealEngineMulticastDelegate<(NotifyName: string) => void>;
	OnNotifyEnd: UnrealEngineMulticastDelegate<(NotifyName: string) => void>;
	static Load(ResourceName: string): PlayMontageCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): PlayMontageCallbackProxy;
	static GetDefaultObject(): PlayMontageCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlayMontageCallbackProxy;
	OnNotifyEndReceived(NotifyName: string,BranchingPointNotifyPayload: BranchingPointNotifyPayload): void;
	OnNotifyBeginReceived(NotifyName: string,BranchingPointNotifyPayload: BranchingPointNotifyPayload): void;
	OnMontageEnded(Montage: AnimMontage,bInterrupted: boolean): void;
	OnMontageBlendingOut(Montage: AnimMontage,bInterrupted: boolean): void;
	static CreateProxyObjectForPlayMontage(InSkeletalMeshComponent: SkeletalMeshComponent,MontageToPlay: AnimMontage,PlayRate: number,StartingPosition: number,StartingSection: string): PlayMontageCallbackProxy;
	static C(Other: UObject | any): PlayMontageCallbackProxy;
}

declare class SequenceEvaluatorLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): SequenceEvaluatorLibrary;
	static Find(Outer: UObject, ResourceName: string): SequenceEvaluatorLibrary;
	static GetDefaultObject(): SequenceEvaluatorLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequenceEvaluatorLibrary;
	static SetSequenceWithInertialBlending(UpdateContext: AnimUpdateContext,SequenceEvaluator: SequenceEvaluatorReference,Sequence: AnimSequenceBase,BlendTime: number): SequenceEvaluatorReference;
	static SetSequence(SequenceEvaluator: SequenceEvaluatorReference,Sequence: AnimSequenceBase): SequenceEvaluatorReference;
	static SetExplicitTime(SequenceEvaluator: SequenceEvaluatorReference,Time: number): SequenceEvaluatorReference;
	static GetSequence(SequenceEvaluator: SequenceEvaluatorReference): AnimSequenceBase;
	static GetAccumulatedTime(SequenceEvaluator: SequenceEvaluatorReference): number;
	static ConvertToSequenceEvaluatorPure(UNode: AnimNodeReference,SequenceEvaluator?: SequenceEvaluatorReference,result?: boolean): {SequenceEvaluator: SequenceEvaluatorReference, result: boolean};
	static ConvertToSequenceEvaluator(UNode: AnimNodeReference,result?: EAnimNodeReferenceConversionResult): {result: EAnimNodeReferenceConversionResult, $: SequenceEvaluatorReference};
	static AdvanceTime(UpdateContext: AnimUpdateContext,SequenceEvaluator: SequenceEvaluatorReference,PlayRate: number): SequenceEvaluatorReference;
	static C(Other: UObject | any): SequenceEvaluatorLibrary;
}

declare class SequencePlayerLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): SequencePlayerLibrary;
	static Find(Outer: UObject, ResourceName: string): SequencePlayerLibrary;
	static GetDefaultObject(): SequencePlayerLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequencePlayerLibrary;
	static SetStartPosition(SequencePlayer: SequencePlayerReference,StartPosition: number): SequencePlayerReference;
	static SetSequenceWithInertialBlending(UpdateContext: AnimUpdateContext,SequencePlayer: SequencePlayerReference,Sequence: AnimSequenceBase,BlendTime: number): SequencePlayerReference;
	static SetSequence(SequencePlayer: SequencePlayerReference,Sequence: AnimSequenceBase): SequencePlayerReference;
	static SetPlayRate(SequencePlayer: SequencePlayerReference,PlayRate: number): SequencePlayerReference;
	static SetAccumulatedTime(SequencePlayer: SequencePlayerReference,Time: number): SequencePlayerReference;
	static GetStartPosition(SequencePlayer: SequencePlayerReference): number;
	static GetSequencePure(SequencePlayer: SequencePlayerReference): AnimSequenceBase;
	static GetSequence(SequencePlayer: SequencePlayerReference,SequenceBase?: AnimSequenceBase): {SequenceBase: AnimSequenceBase, $: SequencePlayerReference};
	static GetPlayRate(SequencePlayer: SequencePlayerReference): number;
	static GetLoopAnimation(SequencePlayer: SequencePlayerReference): boolean;
	static GetAccumulatedTime(SequencePlayer: SequencePlayerReference): number;
	static ConvertToSequencePlayerPure(UNode: AnimNodeReference,SequencePlayer?: SequencePlayerReference,result?: boolean): {SequencePlayer: SequencePlayerReference, result: boolean};
	static ConvertToSequencePlayer(UNode: AnimNodeReference,result?: EAnimNodeReferenceConversionResult): {result: EAnimNodeReferenceConversionResult, $: SequencePlayerReference};
	static ComputePlayRateFromDuration(SequencePlayer: SequencePlayerReference,Duration: number): number;
	static C(Other: UObject | any): SequencePlayerLibrary;
}

declare class SequencerAnimationSupport extends Interface { 
	static Load(ResourceName: string): SequencerAnimationSupport;
	static Find(Outer: UObject, ResourceName: string): SequencerAnimationSupport;
	static GetDefaultObject(): SequencerAnimationSupport;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequencerAnimationSupport;
	static C(Other: UObject | any): SequencerAnimationSupport;
}

declare class SkeletalControlLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): SkeletalControlLibrary;
	static Find(Outer: UObject, ResourceName: string): SkeletalControlLibrary;
	static GetDefaultObject(): SkeletalControlLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkeletalControlLibrary;
	static SetAlpha(SkeletalControl: SkeletalControlReference,Alpha: number): SkeletalControlReference;
	static GetAlpha(SkeletalControl: SkeletalControlReference): number;
	static ConvertToSkeletalControlPure(UNode: AnimNodeReference,SkeletalControl?: SkeletalControlReference,result?: boolean): {SkeletalControl: SkeletalControlReference, result: boolean};
	static ConvertToSkeletalControl(UNode: AnimNodeReference,result?: EAnimNodeReferenceConversionResult): {result: EAnimNodeReferenceConversionResult, $: SkeletalControlReference};
	static C(Other: UObject | any): SkeletalControlLibrary;
}

declare class EditorConfigBase extends UObject { 
	static Load(ResourceName: string): EditorConfigBase;
	static Find(Outer: UObject, ResourceName: string): EditorConfigBase;
	static GetDefaultObject(): EditorConfigBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorConfigBase;
	static C(Other: UObject | any): EditorConfigBase;
}

declare class EditorConfigSubsystem extends EditorSubsystem { 
	static Load(ResourceName: string): EditorConfigSubsystem;
	static Find(Outer: UObject, ResourceName: string): EditorConfigSubsystem;
	static GetDefaultObject(): EditorConfigSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorConfigSubsystem;
	static C(Other: UObject | any): EditorConfigSubsystem;
}

declare class EditorConfigTestSimpleStruct { 
	bool: boolean;
	int: number;
	string: string;
	float: number;
	Array: string[];
	clone() : EditorConfigTestSimpleStruct;
	static C(Other: UObject | any): EditorConfigTestSimpleStruct;
}

declare class EditorConfigTestObject extends UObject { 
	UObject: UObject;
	struct: EditorConfigTestSimpleStruct;
	Number: number;
	static Load(ResourceName: string): EditorConfigTestObject;
	static Find(Outer: UObject, ResourceName: string): EditorConfigTestObject;
	static GetDefaultObject(): EditorConfigTestObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorConfigTestObject;
	static C(Other: UObject | any): EditorConfigTestObject;
}

declare class EditorMetadataOverrides extends EditorSubsystem { 
	static Load(ResourceName: string): EditorMetadataOverrides;
	static Find(Outer: UObject, ResourceName: string): EditorMetadataOverrides;
	static GetDefaultObject(): EditorMetadataOverrides;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorMetadataOverrides;
	static C(Other: UObject | any): EditorMetadataOverrides;
}

declare class CustomTextFilterData { 
	FilterLabel: string;
	FilterString: string;
	FilterColor: LinearColor;
	clone() : CustomTextFilterData;
	static C(Other: UObject | any): CustomTextFilterData;
}

declare class CustomTextFilterState { 
	bIsChecked: boolean;
	bIsActive: boolean;
	FilterData: CustomTextFilterData;
	clone() : CustomTextFilterState;
	static C(Other: UObject | any): CustomTextFilterState;
}

declare type EFilterBarLayout = 'Horizontal' | 'Vertical' | 'EFilterBarLayout_MAX';
declare var EFilterBarLayout : { Horizontal:'Horizontal',Vertical:'Vertical',EFilterBarLayout_MAX:'EFilterBarLayout_MAX', };
declare class FilterBarSettings { 
	CustomFilters: Map<string, boolean>;
	TypeFilters: Map<string, boolean>;
	CustomTextFilters: CustomTextFilterState[];
	bIsLayoutSaved: boolean;
	FilterBarLayout: EFilterBarLayout;
	clone() : FilterBarSettings;
	static C(Other: UObject | any): FilterBarSettings;
}

declare class FilterBarConfig extends EditorConfigBase { 
	FilterBars: Map<string, FilterBarSettings>;
	static Load(ResourceName: string): FilterBarConfig;
	static Find(Outer: UObject, ResourceName: string): FilterBarConfig;
	static GetDefaultObject(): FilterBarConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FilterBarConfig;
	static C(Other: UObject | any): FilterBarConfig;
}

declare class AssetFilterBarContext extends UObject { 
	static Load(ResourceName: string): AssetFilterBarContext;
	static Find(Outer: UObject, ResourceName: string): AssetFilterBarContext;
	static GetDefaultObject(): AssetFilterBarContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetFilterBarContext;
	static C(Other: UObject | any): AssetFilterBarContext;
}

declare class CurveEditorFilterBase extends UObject { 
	static Load(ResourceName: string): CurveEditorFilterBase;
	static Find(Outer: UObject, ResourceName: string): CurveEditorFilterBase;
	static GetDefaultObject(): CurveEditorFilterBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveEditorFilterBase;
	static C(Other: UObject | any): CurveEditorFilterBase;
}

declare class CurveEditorBakeFilter extends CurveEditorFilterBase { 
	bUseFrameBake: boolean;
	BakeIntervalInFrames: FrameNumber;
	BakeIntervalInSeconds: number;
	static Load(ResourceName: string): CurveEditorBakeFilter;
	static Find(Outer: UObject, ResourceName: string): CurveEditorBakeFilter;
	static GetDefaultObject(): CurveEditorBakeFilter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveEditorBakeFilter;
	static C(Other: UObject | any): CurveEditorBakeFilter;
}

declare class KeyPosition { 
	InputValue: number;
	OutputValue: number;
	clone() : KeyPosition;
	static C(Other: UObject | any): KeyPosition;
}

declare class KeyAttributes { 
	bHasArriveTangent: boolean;
	bHasLeaveTangent: boolean;
	bHasInterpMode: boolean;
	bHasTangentMode: boolean;
	bHasTangentWeightMode: boolean;
	bHasArriveTangentWeight: boolean;
	bHasLeaveTangentWeight: boolean;
	ArriveTangent: number;
	LeaveTangent: number;
	InterpMode: ERichCurveInterpMode;
	TangentMode: ERichCurveTangentMode;
	TangentWeightMode: ERichCurveTangentWeightMode;
	ArriveTangentWeight: number;
	LeaveTangentWeight: number;
	clone() : KeyAttributes;
	static C(Other: UObject | any): KeyAttributes;
}

declare class CurveEditorCopyableCurveKeys extends UObject { 
	KeyPositions: KeyPosition[];
	KeyAttributes: KeyAttributes[];
	ShortDisplayName: string;
	LongDisplayName: string;
	IntentionName: string;
	LongIntentionName: string;
	static Load(ResourceName: string): CurveEditorCopyableCurveKeys;
	static Find(Outer: UObject, ResourceName: string): CurveEditorCopyableCurveKeys;
	static GetDefaultObject(): CurveEditorCopyableCurveKeys;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveEditorCopyableCurveKeys;
	static C(Other: UObject | any): CurveEditorCopyableCurveKeys;
}

declare class CurveEditorCopyBuffer extends UObject { 
	Curves: CurveEditorCopyableCurveKeys[];
	TimeOffset: number;
	bAbsolutePosition: boolean;
	static Load(ResourceName: string): CurveEditorCopyBuffer;
	static Find(Outer: UObject, ResourceName: string): CurveEditorCopyBuffer;
	static GetDefaultObject(): CurveEditorCopyBuffer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveEditorCopyBuffer;
	static C(Other: UObject | any): CurveEditorCopyBuffer;
}

declare class CurveEditorEulerFilter extends CurveEditorFilterBase { 
	static Load(ResourceName: string): CurveEditorEulerFilter;
	static Find(Outer: UObject, ResourceName: string): CurveEditorEulerFilter;
	static GetDefaultObject(): CurveEditorEulerFilter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveEditorEulerFilter;
	static C(Other: UObject | any): CurveEditorEulerFilter;
}

declare class CurveEditorKeyProxy extends Interface { 
	static Load(ResourceName: string): CurveEditorKeyProxy;
	static Find(Outer: UObject, ResourceName: string): CurveEditorKeyProxy;
	static GetDefaultObject(): CurveEditorKeyProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveEditorKeyProxy;
	static C(Other: UObject | any): CurveEditorKeyProxy;
}

declare class CurveEditorReduceFilter extends CurveEditorFilterBase { 
	Tolerance: number;
	bTryRemoveUserSetTangentKeys: boolean;
	SampleRate: FrameRate;
	static Load(ResourceName: string): CurveEditorReduceFilter;
	static Find(Outer: UObject, ResourceName: string): CurveEditorReduceFilter;
	static GetDefaultObject(): CurveEditorReduceFilter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveEditorReduceFilter;
	static C(Other: UObject | any): CurveEditorReduceFilter;
}

declare type ECurveEditorTangentVisibility = 'AllTangents' | 'SelectedKeys' | 'NoTangents' | 'ECurveEditorTangentVisibility_MAX';
declare var ECurveEditorTangentVisibility : { AllTangents:'AllTangents',SelectedKeys:'SelectedKeys',NoTangents:'NoTangents',ECurveEditorTangentVisibility_MAX:'ECurveEditorTangentVisibility_MAX', };
declare type ECurveEditorZoomPosition = 'CurrentTime' | 'MousePosition' | 'ECurveEditorZoomPosition_MAX';
declare var ECurveEditorZoomPosition : { CurrentTime:'CurrentTime',MousePosition:'MousePosition',ECurveEditorZoomPosition_MAX:'ECurveEditorZoomPosition_MAX', };
declare class CustomColorForChannel { 
	UObject: Class;
	PropertyName: string;
	Color: LinearColor;
	clone() : CustomColorForChannel;
	static C(Other: UObject | any): CustomColorForChannel;
}

declare class CustomColorForSpaceSwitch { 
	ControlName: string;
	Color: LinearColor;
	clone() : CustomColorForSpaceSwitch;
	static C(Other: UObject | any): CustomColorForSpaceSwitch;
}

declare class CurveEditorSettings extends UObject { 
	bAutoFrameCurveEditor: boolean;
	FrameInputPadding: number;
	FrameOutputPadding: number;
	bShowBufferedCurves: boolean;
	bShowCurveEditorCurveToolTips: boolean;
	TangentVisibility: ECurveEditorTangentVisibility;
	ZoomPosition: ECurveEditorZoomPosition;
	bSnapTimeToSelection: boolean;
	SelectionColor: LinearColor;
	CustomColors: CustomColorForChannel[];
	ParentSpaceCustomColor: LinearColor;
	WorldSpaceCustomColor: LinearColor;
	ControlSpaceCustomColors: CustomColorForSpaceSwitch[];
	static Load(ResourceName: string): CurveEditorSettings;
	static Find(Outer: UObject, ResourceName: string): CurveEditorSettings;
	static GetDefaultObject(): CurveEditorSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveEditorSettings;
	static C(Other: UObject | any): CurveEditorSettings;
}

declare class RichCurveKeyProxy extends UObject { 
	Value: RichCurveKey;
	static Load(ResourceName: string): RichCurveKeyProxy;
	static Find(Outer: UObject, ResourceName: string): RichCurveKeyProxy;
	static GetDefaultObject(): RichCurveKeyProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RichCurveKeyProxy;
	static C(Other: UObject | any): RichCurveKeyProxy;
}

declare class SourceControlState { 
	Filename: string;
	bIsValid: boolean;
	bIsUnknown: boolean;
	bCanCheckIn: boolean;
	bCanCheckOut: boolean;
	bIsCheckedOut: boolean;
	bIsCurrent: boolean;
	bIsSourceControlled: boolean;
	bIsAdded: boolean;
	bIsDeleted: boolean;
	bIsIgnored: boolean;
	bCanEdit: boolean;
	bCanDelete: boolean;
	bIsModified: boolean;
	bCanAdd: boolean;
	bIsConflicted: boolean;
	bCanRevert: boolean;
	bIsCheckedOutOther: boolean;
	CheckedOutOther: string;
	clone() : SourceControlState;
	static C(Other: UObject | any): SourceControlState;
}

declare class SourceControlHelpers extends UObject { 
	static Load(ResourceName: string): SourceControlHelpers;
	static Find(Outer: UObject, ResourceName: string): SourceControlHelpers;
	static GetDefaultObject(): SourceControlHelpers;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SourceControlHelpers;
	static SyncFiles(InFiles: string[],bSilent: boolean): boolean;
	static SyncFile(InFile: string,bSilent: boolean): boolean;
	static RevertUnchangedFiles(InFiles: string[],bSilent: boolean): boolean;
	static RevertUnchangedFile(InFile: string,bSilent: boolean): boolean;
	static RevertFiles(InFiles: string[],bSilent: boolean): boolean;
	static RevertFile(InFile: string,bSilent: boolean): boolean;
	static RevertAndReloadPackages(InFilenames: string[]): boolean;
	static QueryFileState(InFile: string,bSilent: boolean): SourceControlState;
	static MarkFilesForDelete(InFiles: string[],bSilent: boolean): boolean;
	static MarkFilesForAdd(InFiles: string[],bSilent: boolean): boolean;
	static MarkFileForDelete(InFile: string,bSilent: boolean): boolean;
	static MarkFileForAdd(InFile: string,bSilent: boolean): boolean;
	static LastErrorMsg(): string;
	static IsEnabled(): boolean;
	static IsAvailable(): boolean;
	static CurrentProvider(): string;
	static CopyFile(InSourceFile: string,InDestFile: string,bSilent: boolean): boolean;
	static CheckOutOrAddFiles(InFiles: string[],bSilent: boolean): boolean;
	static CheckOutOrAddFile(InFile: string,bSilent: boolean): boolean;
	static CheckOutFiles(InFiles: string[],bSilent: boolean): boolean;
	static CheckOutFile(InFile: string,bSilent: boolean): boolean;
	static CheckInFiles(InFiles: string[],InDescription: string,bSilent: boolean,bKeepCheckedOut: boolean): boolean;
	static CheckInFile(InFile: string,InDescription: string,bSilent: boolean,bKeepCheckedOut: boolean): boolean;
	static C(Other: UObject | any): SourceControlHelpers;
}

declare class SourceControlPreferences extends DeveloperSettings { 
	bEnableValidationTag: boolean;
	bShouldDeleteNewFilesOnRevert: boolean;
	bEnableUncontrolledChangelists: boolean;
	CollectionChangelistTags: string[];
	SpecificCollectionChangelistTags: Map<string, string>;
	static Load(ResourceName: string): SourceControlPreferences;
	static Find(Outer: UObject, ResourceName: string): SourceControlPreferences;
	static GetDefaultObject(): SourceControlPreferences;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SourceControlPreferences;
	static C(Other: UObject | any): SourceControlPreferences;
}

declare class HierarchicalInstancedStaticMeshComponent extends InstancedStaticMeshComponent { 
	bUseTranslatedInstanceSpace: boolean;
	TranslatedInstanceSpaceOrigin: Vector;
	SortedInstances: number[];
	NumBuiltInstances: number;
	BuiltInstanceBounds: Box;
	UnbuiltInstanceBounds: Box;
	UnbuiltInstanceBoundsList: Box[];
	bEnableDensityScaling: boolean;
	OcclusionLayerNumNodes: number;
	CacheMeshExtendedBounds: BoxSphereBounds;
	bDisableCollision: boolean;
	InstanceCountToRender: number;
	static Load(ResourceName: string): HierarchicalInstancedStaticMeshComponent;
	static Find(Outer: UObject, ResourceName: string): HierarchicalInstancedStaticMeshComponent;
	static GetDefaultObject(): HierarchicalInstancedStaticMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HierarchicalInstancedStaticMeshComponent;
	static C(Other: UObject | any): HierarchicalInstancedStaticMeshComponent;
}

declare class FoliageInstancedStaticMeshComponent extends HierarchicalInstancedStaticMeshComponent { 
	OnInstanceTakePointDamage: UnrealEngineMulticastDelegate<(InstanceIndex: number, Damage: number, InstigatedBy: Controller, HitLocation: Vector, ShotFromDirection: Vector, DamageType: DamageType, DamageCauser: Actor) => void>;
	OnInstanceTakeRadialDamage: UnrealEngineMulticastDelegate<(Instances: number[], Damages: number[], InstigatedBy: Controller, Origin: Vector, MaxRadius: number, DamageType: DamageType, DamageCauser: Actor) => void>;
	bEnableDiscardOnLoad: boolean;
	FoliageHiddenEditorViews: number;
	GenerationGuid: Guid;
	static Load(ResourceName: string): FoliageInstancedStaticMeshComponent;
	static Find(Outer: UObject, ResourceName: string): FoliageInstancedStaticMeshComponent;
	static GetDefaultObject(): FoliageInstancedStaticMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FoliageInstancedStaticMeshComponent;
	static C(Other: UObject | any): FoliageInstancedStaticMeshComponent;
}

declare type EFoliageScaling = 'Uniform' | 'Free' | 'LockXY' | 'LockXZ' | 'LockYZ' | 'EFoliageScaling_MAX';
declare var EFoliageScaling : { Uniform:'Uniform',Free:'Free',LockXY:'LockXY',LockXZ:'LockXZ',LockYZ:'LockYZ',EFoliageScaling_MAX:'EFoliageScaling_MAX', };
declare class FloatInterval { 
	Min: number;
	Max: number;
	clone() : FloatInterval;
	static C(Other: UObject | any): FloatInterval;
}

declare class FoliageVertexColorChannelMask { 
	UseMask: boolean;
	MaskThreshold: number;
	InvertMask: boolean;
	clone() : FoliageVertexColorChannelMask;
	static C(Other: UObject | any): FoliageVertexColorChannelMask;
}

declare type FoliageVertexColorMask = 'FOLIAGEVERTEXCOLORMASK_Disabled' | 'FOLIAGEVERTEXCOLORMASK_Red' | 'FOLIAGEVERTEXCOLORMASK_Green' | 'FOLIAGEVERTEXCOLORMASK_Blue' | 'FOLIAGEVERTEXCOLORMASK_Alpha' | 'FOLIAGEVERTEXCOLORMASK_MAX';
declare var FoliageVertexColorMask : { FOLIAGEVERTEXCOLORMASK_Disabled:'FOLIAGEVERTEXCOLORMASK_Disabled',FOLIAGEVERTEXCOLORMASK_Red:'FOLIAGEVERTEXCOLORMASK_Red',FOLIAGEVERTEXCOLORMASK_Green:'FOLIAGEVERTEXCOLORMASK_Green',FOLIAGEVERTEXCOLORMASK_Blue:'FOLIAGEVERTEXCOLORMASK_Blue',FOLIAGEVERTEXCOLORMASK_Alpha:'FOLIAGEVERTEXCOLORMASK_Alpha',FOLIAGEVERTEXCOLORMASK_MAX:'FOLIAGEVERTEXCOLORMASK_MAX', };
declare class Int32Interval { 
	Min: number;
	Max: number;
	clone() : Int32Interval;
	static C(Other: UObject | any): Int32Interval;
}

declare class FoliageDensityFalloff { 
	bUseFalloffCurve: boolean;
	FalloffCurve: RuntimeFloatCurve;
	clone() : FoliageDensityFalloff;
	static C(Other: UObject | any): FoliageDensityFalloff;
}

declare class FoliageType extends UObject { 
	UpdateGuid: Guid;
	Density: number;
	DensityAdjustmentFactor: number;
	Radius: number;
	bSingleInstanceModeOverrideRadius: boolean;
	SingleInstanceModeRadius: number;
	Scaling: EFoliageScaling;
	ScaleX: FloatInterval;
	ScaleY: FloatInterval;
	ScaleZ: FloatInterval;
	VertexColorMaskByChannel: FoliageVertexColorChannelMask;
	VertexColorMask: FoliageVertexColorMask;
	VertexColorMaskThreshold: number;
	VertexColorMaskInvert: boolean;
	ZOffset: FloatInterval;
	AlignToNormal: boolean;
	AverageNormal: boolean;
	AverageNormalSingleComponent: boolean;
	AlignMaxAngle: number;
	RandomYaw: boolean;
	RandomPitchAngle: number;
	GroundSlopeAngle: FloatInterval;
	Height: FloatInterval;
	LandscapeLayers: string[];
	MinimumLayerWeight: number;
	ExclusionLandscapeLayers: string[];
	MinimumExclusionLayerWeight: number;
	LandscapeLayer: string;
	CollisionWithWorld: boolean;
	CollisionScale: Vector;
	AverageNormalSampleCount: number;
	MeshBounds: BoxSphereBounds;
	LowBoundOriginRadius: Vector;
	Mobility: EComponentMobility;
	CullDistance: Int32Interval;
	bEnableStaticLighting: boolean;
	CastShadow: boolean;
	bAffectDynamicIndirectLighting: boolean;
	bAffectDistanceFieldLighting: boolean;
	bCastDynamicShadow: boolean;
	bCastStaticShadow: boolean;
	bCastContactShadow: boolean;
	bCastShadowAsTwoSided: boolean;
	bReceivesDecals: boolean;
	bOverrideLightMapRes: boolean;
	OverriddenLightMapRes: number;
	LightmapType: ELightmapType;
	bUseAsOccluder: boolean;
	bVisibleInRayTracing: boolean;
	bEvaluateWorldPositionOffset: boolean;
	WorldPositionOffsetDisableDistance: number;
	BodyInstance: BodyInstance;
	CustomNavigableGeometry: EHasCustomNavigableGeometry;
	LightingChannels: LightingChannels;
	bRenderCustomDepth: boolean;
	CustomDepthStencilWriteMask: ERendererStencilMask;
	CustomDepthStencilValue: number;
	TranslucencySortPriority: number;
	HiddenEditorViews: number;
	IsSelected: boolean;
	CollisionRadius: number;
	ShadeRadius: number;
	NumSteps: number;
	InitialSeedDensity: number;
	AverageSpreadDistance: number;
	SpreadVariance: number;
	SeedsPerStep: number;
	DistributionSeed: number;
	MaxInitialSeedOffset: number;
	bCanGrowInShade: boolean;
	bSpawnsInShade: boolean;
	MaxInitialAge: number;
	MaxAge: number;
	OverlapPriority: number;
	ProceduralScale: FloatInterval;
	ScaleCurve: RuntimeFloatCurve;
	DensityFalloff: FoliageDensityFalloff;
	ChangeCount: number;
	ReapplyDensity: boolean;
	ReapplyRadius: boolean;
	ReapplyAlignToNormal: boolean;
	ReapplyRandomYaw: boolean;
	ReapplyScaling: boolean;
	ReapplyScaleX: boolean;
	ReapplyScaleY: boolean;
	ReapplyScaleZ: boolean;
	ReapplyRandomPitchAngle: boolean;
	ReapplyGroundSlope: boolean;
	ReapplyHeight: boolean;
	ReapplyLandscapeLayers: boolean;
	ReapplyZOffset: boolean;
	ReapplyCollisionWithWorld: boolean;
	ReapplyVertexColorMask: boolean;
	bEnableDensityScaling: boolean;
	bEnableDiscardOnLoad: boolean;
	RuntimeVirtualTextures: RuntimeVirtualTexture[];
	VirtualTextureCullMips: number;
	VirtualTextureRenderPassType: ERuntimeVirtualTextureMainPassType;
	bIncludeInHLOD: boolean;
	ScaleMinX: number;
	ScaleMinY: number;
	ScaleMinZ: number;
	ScaleMaxX: number;
	ScaleMaxY: number;
	ScaleMaxZ: number;
	HeightMin: number;
	HeightMax: number;
	ZOffsetMin: number;
	ZOffsetMax: number;
	StartCullDistance: number;
	EndCullDistance: number;
	UniformScale: boolean;
	LockScaleX: boolean;
	LockScaleY: boolean;
	LockScaleZ: boolean;
	GroundSlope: number;
	MinGroundSlope: number;
	MinScale: number;
	MaxScale: number;
	static Load(ResourceName: string): FoliageType;
	static Find(Outer: UObject, ResourceName: string): FoliageType;
	static GetDefaultObject(): FoliageType;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FoliageType;
	static C(Other: UObject | any): FoliageType;
}

declare class FoliageType_Actor extends FoliageType { 
	ActorClass: UnrealEngineClass;
	bShouldAttachToBaseComponent: boolean;
	bStaticMeshOnly: boolean;
	StaticMeshOnlyComponentClass: UnrealEngineClass;
	static Load(ResourceName: string): FoliageType_Actor;
	static Find(Outer: UObject, ResourceName: string): FoliageType_Actor;
	static GetDefaultObject(): FoliageType_Actor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FoliageType_Actor;
	static C(Other: UObject | any): FoliageType_Actor;
}

declare class FoliageType_InstancedStaticMesh extends FoliageType { 
	Mesh: StaticMesh;
	OverrideMaterials: MaterialInterface[];
	NaniteOverrideMaterials: MaterialInterface[];
	ComponentClass: UnrealEngineClass;
	static Load(ResourceName: string): FoliageType_InstancedStaticMesh;
	static Find(Outer: UObject, ResourceName: string): FoliageType_InstancedStaticMesh;
	static GetDefaultObject(): FoliageType_InstancedStaticMesh;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FoliageType_InstancedStaticMesh;
	static C(Other: UObject | any): FoliageType_InstancedStaticMesh;
}

declare class PartitionActor extends Actor { 
	GridSize: number;
	static GetDefaultObject(): PartitionActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PartitionActor;
	static C(Other: UObject | any): PartitionActor;
}

declare class ISMComponentDescriptor { 
	Hash: number;
	ComponentClass: UnrealEngineClass;
	StaticMesh: StaticMesh;
	OverrideMaterials: MaterialInterface[];
	RuntimeVirtualTextures: RuntimeVirtualTexture[];
	Mobility: EComponentMobility;
	VirtualTextureRenderPassType: ERuntimeVirtualTextureMainPassType;
	LightmapType: ELightmapType;
	LightingChannels: LightingChannels;
	RayTracingGroupId: number;
	RayTracingGroupCullingPriority: ERayTracingGroupCullingPriority;
	bHasCustomNavigableGeometry: EHasCustomNavigableGeometry;
	CustomDepthStencilWriteMask: ERendererStencilMask;
	BodyInstance: BodyInstance;
	InstanceStartCullDistance: number;
	InstanceEndCullDistance: number;
	VirtualTextureCullMips: number;
	TranslucencySortPriority: number;
	OverriddenLightMapRes: number;
	CustomDepthStencilValue: number;
	HLODBatchingPolicy: EHLODBatchingPolicy;
	bCastShadow: boolean;
	bCastDynamicShadow: boolean;
	bCastStaticShadow: boolean;
	bCastContactShadow: boolean;
	bCastShadowAsTwoSided: boolean;
	bAffectDynamicIndirectLighting: boolean;
	bAffectDistanceFieldLighting: boolean;
	bReceivesDecals: boolean;
	bOverrideLightMapRes: boolean;
	bUseAsOccluder: boolean;
	bEnableDensityScaling: boolean;
	bEnableDiscardOnLoad: boolean;
	bRenderCustomDepth: boolean;
	bIncludeInHLOD: boolean;
	bVisibleInRayTracing: boolean;
	bHiddenInGame: boolean;
	bIsEditorOnly: boolean;
	bVisible: boolean;
	bConsiderForActorPlacementWhenHidden: boolean;
	bEvaluateWorldPositionOffset: boolean;
	bIsLocalToWorldDeterminantNegative: boolean;
	clone() : ISMComponentDescriptor;
	static C(Other: UObject | any): ISMComponentDescriptor;
}

declare class ISMComponentInstance { 
	ClientIndex: number;
	InstanceIndex: number;
	InstanceSubIndex: number;
	clone() : ISMComponentInstance;
	static C(Other: UObject | any): ISMComponentInstance;
}

declare class ISMClientInstance { 
	ComponentIndices: number[];
	clone() : ISMClientInstance;
	static C(Other: UObject | any): ISMClientInstance;
}

declare class ISMClientData { 
	Instances: ISMClientInstance[];
	clone() : ISMClientData;
	static C(Other: UObject | any): ISMClientData;
}

declare class ISMComponentData { 
	Instances: ISMComponentInstance[];
	ClientInstances: ISMClientData[];
	Component: InstancedStaticMeshComponent;
	clone() : ISMComponentData;
	static C(Other: UObject | any): ISMComponentData;
}

declare class ISMClientInstanceManagerData { 
	clone() : ISMClientInstanceManagerData;
	static C(Other: UObject | any): ISMClientInstanceManagerData;
}

declare class ISMPartitionActor extends PartitionActor { 
	Clients: Guid[];
	Descriptors: ISMComponentDescriptor[];
	DescriptorComponents: ISMComponentData[];
	ClientInstanceManagers: Map<Guid, ISMClientInstanceManagerData>;
	static GetDefaultObject(): ISMPartitionActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ISMPartitionActor;
	static C(Other: UObject | any): ISMPartitionActor;
}

declare class InstancedFoliageActor extends ISMPartitionActor { 
	static GetDefaultObject(): InstancedFoliageActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InstancedFoliageActor;
	static RemoveAllInstances(WorldContextObject: UObject,InFoliageType: FoliageType): void;
	static AddInstances(WorldContextObject: UObject,InFoliageType: FoliageType,InTransforms: Transform[]): void;
	static C(Other: UObject | any): InstancedFoliageActor;
}

declare class InteractiveFoliageComponent extends StaticMeshComponent { 
	static Load(ResourceName: string): InteractiveFoliageComponent;
	static Find(Outer: UObject, ResourceName: string): InteractiveFoliageComponent;
	static GetDefaultObject(): InteractiveFoliageComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveFoliageComponent;
	static C(Other: UObject | any): InteractiveFoliageComponent;
}

declare class FoliageStatistics extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): FoliageStatistics;
	static Find(Outer: UObject, ResourceName: string): FoliageStatistics;
	static GetDefaultObject(): FoliageStatistics;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FoliageStatistics;
	static FoliageOverlappingSphereCount(WorldContextObject: UObject,StaticMesh: StaticMesh,CenterPosition: Vector,Radius: number): number;
	static FoliageOverlappingBoxTransforms(WorldContextObject: UObject,StaticMesh: StaticMesh,Box: Box,OutTransforms?: Transform[]): {OutTransforms: Transform[]};
	static FoliageOverlappingBoxCount(WorldContextObject: UObject,StaticMesh: StaticMesh,Box: Box): number;
	static C(Other: UObject | any): FoliageStatistics;
}

declare class GrassInstancedStaticMeshComponent extends HierarchicalInstancedStaticMeshComponent { 
	static Load(ResourceName: string): GrassInstancedStaticMeshComponent;
	static Find(Outer: UObject, ResourceName: string): GrassInstancedStaticMeshComponent;
	static GetDefaultObject(): GrassInstancedStaticMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GrassInstancedStaticMeshComponent;
	static C(Other: UObject | any): GrassInstancedStaticMeshComponent;
}

declare type ENavDataGatheringMode = 'Default' | 'Instant' | 'Lazy' | 'ENavDataGatheringMode_MAX';
declare var ENavDataGatheringMode : { Default:'Default',Instant:'Instant',Lazy:'Lazy',ENavDataGatheringMode_MAX:'ENavDataGatheringMode_MAX', };
declare class StaticMeshActor extends Actor { 
	StaticMeshComponent: StaticMeshComponent;
	bStaticMeshReplicateMovement: boolean;
	NavigationGeometryGatheringMode: ENavDataGatheringMode;
	static GetDefaultObject(): StaticMeshActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StaticMeshActor;
	SetMobility(InMobility: EComponentMobility): void;
	static C(Other: UObject | any): StaticMeshActor;
}

declare class InteractiveFoliageActor extends StaticMeshActor { 
	CapsuleComponent: CapsuleComponent;
	TouchingActorEntryPosition: Vector;
	FoliageVelocity: Vector;
	FoliageForce: Vector;
	FoliagePosition: Vector;
	FoliageDamageImpulseScale: number;
	FoliageTouchImpulseScale: number;
	FoliageStiffness: number;
	FoliageStiffnessQuadratic: number;
	FoliageDamping: number;
	MaxDamageImpulse: number;
	MaxTouchImpulse: number;
	MaxForce: number;
	Mass: number;
	static GetDefaultObject(): InteractiveFoliageActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveFoliageActor;
	CapsuleTouched(OverlappedComp: PrimitiveComponent,Other: Actor,OtherComp: PrimitiveComponent,OtherBodyIndex: number,bFromSweep: boolean,OverlapInfo: HitResult): void;
	static C(Other: UObject | any): InteractiveFoliageActor;
}

declare class FoliageTypeObject { 
	FoliageTypeObject: UObject;
	TypeInstance: FoliageType;
	bIsAsset: boolean;
	Type: UnrealEngineClass;
	clone() : FoliageTypeObject;
	static C(Other: UObject | any): FoliageTypeObject;
}

declare class ProceduralFoliageSpawner extends UObject { 
	RandomSeed: number;
	TileSize: number;
	NumUniqueTiles: number;
	MinimumQuadTreeSize: number;
	FoliageTypes: FoliageTypeObject[];
	static Load(ResourceName: string): ProceduralFoliageSpawner;
	static Find(Outer: UObject, ResourceName: string): ProceduralFoliageSpawner;
	static GetDefaultObject(): ProceduralFoliageSpawner;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProceduralFoliageSpawner;
	Simulate(NumSteps: number): void;
	static C(Other: UObject | any): ProceduralFoliageSpawner;
}

declare class ProceduralFoliageComponent extends ActorComponent { 
	FoliageSpawner: ProceduralFoliageSpawner;
	TileOverlap: number;
	bAllowLandscape: boolean;
	bAllowBSP: boolean;
	bAllowStaticMesh: boolean;
	bAllowTranslucent: boolean;
	bAllowFoliage: boolean;
	bShowDebugTiles: boolean;
	SpawningVolume: Volume;
	ProceduralGuid: Guid;
	static Load(ResourceName: string): ProceduralFoliageComponent;
	static Find(Outer: UObject, ResourceName: string): ProceduralFoliageComponent;
	static GetDefaultObject(): ProceduralFoliageComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProceduralFoliageComponent;
	static C(Other: UObject | any): ProceduralFoliageComponent;
}

declare class ProceduralFoliageVolume extends Volume { 
	ProceduralComponent: ProceduralFoliageComponent;
	static GetDefaultObject(): ProceduralFoliageVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProceduralFoliageVolume;
	static C(Other: UObject | any): ProceduralFoliageVolume;
}

declare class ProceduralFoliageBlockingVolume extends Volume { 
	ProceduralFoliageVolume: ProceduralFoliageVolume;
	DensityFalloff: FoliageDensityFalloff;
	static GetDefaultObject(): ProceduralFoliageBlockingVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProceduralFoliageBlockingVolume;
	static C(Other: UObject | any): ProceduralFoliageBlockingVolume;
}

declare class ProceduralFoliageInstance { 
	Rotation: Quat;
	Location: Vector;
	Age: number;
	Normal: Vector;
	Scale: number;
	Type: FoliageType;
	clone() : ProceduralFoliageInstance;
	static C(Other: UObject | any): ProceduralFoliageInstance;
}

declare class ProceduralFoliageTile extends UObject { 
	FoliageSpawner: ProceduralFoliageSpawner;
	InstancesArray: ProceduralFoliageInstance[];
	static Load(ResourceName: string): ProceduralFoliageTile;
	static Find(Outer: UObject, ResourceName: string): ProceduralFoliageTile;
	static GetDefaultObject(): ProceduralFoliageTile;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProceduralFoliageTile;
	static C(Other: UObject | any): ProceduralFoliageTile;
}

declare class SourceControlMenuContext extends UObject { 
	SelectedFiles: string[];
	static Load(ResourceName: string): SourceControlMenuContext;
	static Find(Outer: UObject, ResourceName: string): SourceControlMenuContext;
	static GetDefaultObject(): SourceControlMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SourceControlMenuContext;
	static C(Other: UObject | any): SourceControlMenuContext;
}

declare class SourceControlSettings extends UObject { 
	bShowAssetTypeColumn: boolean;
	bShowAssetLastModifiedTimeColumn: boolean;
	bShowAssetCheckedOutByColumn: boolean;
	bEnableSubmitContentMenuAction: boolean;
	static Load(ResourceName: string): SourceControlSettings;
	static Find(Outer: UObject, ResourceName: string): SourceControlSettings;
	static GetDefaultObject(): SourceControlSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SourceControlSettings;
	static C(Other: UObject | any): SourceControlSettings;
}

declare type EContentBrowserDataMenuContext_AddNewMenuDomain = 'Toolbar' | 'AssetView' | 'PathView' | 'EContentBrowserDataMenuContext_MAX';
declare var EContentBrowserDataMenuContext_AddNewMenuDomain : { Toolbar:'Toolbar',AssetView:'AssetView',PathView:'PathView',EContentBrowserDataMenuContext_MAX:'EContentBrowserDataMenuContext_MAX', };
declare class ContentBrowserDataMenuContext_AddNewMenu extends UObject { 
	SelectedPaths: string[];
	bContainsValidPackagePath: boolean;
	bCanBeModified: boolean;
	OwnerDomain: EContentBrowserDataMenuContext_AddNewMenuDomain;
	static Load(ResourceName: string): ContentBrowserDataMenuContext_AddNewMenu;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserDataMenuContext_AddNewMenu;
	static GetDefaultObject(): ContentBrowserDataMenuContext_AddNewMenu;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserDataMenuContext_AddNewMenu;
	static C(Other: UObject | any): ContentBrowserDataMenuContext_AddNewMenu;
}

declare class ContentBrowserItem { 
	clone() : ContentBrowserItem;
	static C(Other: UObject | any): ContentBrowserItem;
	GetDisplayName(): string;
	GetVirtualPath(): string;
	IsFile(): boolean;
	IsFolder(): boolean;
	static GetDisplayName(Item: ContentBrowserItem): string;
	static GetVirtualPath(Item: ContentBrowserItem): string;
	static IsFile(Item: ContentBrowserItem): boolean;
	static IsFolder(Item: ContentBrowserItem): boolean;
}

declare class ContentBrowserDataMenuContext_FolderMenu extends UObject { 
	SelectedItems: ContentBrowserItem[];
	bCanBeModified: boolean;
	static Load(ResourceName: string): ContentBrowserDataMenuContext_FolderMenu;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserDataMenuContext_FolderMenu;
	static GetDefaultObject(): ContentBrowserDataMenuContext_FolderMenu;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserDataMenuContext_FolderMenu;
	static C(Other: UObject | any): ContentBrowserDataMenuContext_FolderMenu;
}

declare class ContentBrowserDataMenuContext_FileMenu extends UObject { 
	SelectedItems: ContentBrowserItem[];
	bCanBeModified: boolean;
	static Load(ResourceName: string): ContentBrowserDataMenuContext_FileMenu;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserDataMenuContext_FileMenu;
	static GetDefaultObject(): ContentBrowserDataMenuContext_FileMenu;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserDataMenuContext_FileMenu;
	static C(Other: UObject | any): ContentBrowserDataMenuContext_FileMenu;
}

declare class ContentBrowserDataMenuContext_DragDropMenu extends UObject { 
	DropTargetItem: ContentBrowserItem;
	DraggedItems: ContentBrowserItem[];
	bCanMove: boolean;
	bCanCopy: boolean;
	static Load(ResourceName: string): ContentBrowserDataMenuContext_DragDropMenu;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserDataMenuContext_DragDropMenu;
	static GetDefaultObject(): ContentBrowserDataMenuContext_DragDropMenu;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserDataMenuContext_DragDropMenu;
	static C(Other: UObject | any): ContentBrowserDataMenuContext_DragDropMenu;
}

declare class ContentBrowserDataSource extends UObject { 
	static Load(ResourceName: string): ContentBrowserDataSource;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserDataSource;
	static GetDefaultObject(): ContentBrowserDataSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserDataSource;
	static C(Other: UObject | any): ContentBrowserDataSource;
}

declare type EContentBrowserItemTypeFilter = 'IncludeNone' | 'IncludeFolders' | 'IncludeFiles' | 'IncludeAll' | 'EContentBrowserItemTypeFilter_MAX';
declare var EContentBrowserItemTypeFilter : { IncludeNone:'IncludeNone',IncludeFolders:'IncludeFolders',IncludeFiles:'IncludeFiles',IncludeAll:'IncludeAll',EContentBrowserItemTypeFilter_MAX:'EContentBrowserItemTypeFilter_MAX', };
declare type EContentBrowserItemCategoryFilter = 'IncludeNone' | 'IncludeAssets' | 'IncludeClasses' | 'IncludeCollections' | 'IncludeMisc' | 'IncludeAll' | 'EContentBrowserItemCategoryFilter_MAX';
declare var EContentBrowserItemCategoryFilter : { IncludeNone:'IncludeNone',IncludeAssets:'IncludeAssets',IncludeClasses:'IncludeClasses',IncludeCollections:'IncludeCollections',IncludeMisc:'IncludeMisc',IncludeAll:'IncludeAll',EContentBrowserItemCategoryFilter_MAX:'EContentBrowserItemCategoryFilter_MAX', };
declare type EContentBrowserItemAttributeFilter = 'IncludeNone' | 'IncludeProject' | 'IncludeEngine' | 'IncludePlugins' | 'IncludeDeveloper' | 'IncludeLocalized' | 'IncludeAll' | 'EContentBrowserItemAttributeFilter_MAX';
declare var EContentBrowserItemAttributeFilter : { IncludeNone:'IncludeNone',IncludeProject:'IncludeProject',IncludeEngine:'IncludeEngine',IncludePlugins:'IncludePlugins',IncludeDeveloper:'IncludeDeveloper',IncludeLocalized:'IncludeLocalized',IncludeAll:'IncludeAll',EContentBrowserItemAttributeFilter_MAX:'EContentBrowserItemAttributeFilter_MAX', };
declare class ContentBrowserDataFilter { 
	bRecursivePaths: boolean;
	ItemTypeFilter: EContentBrowserItemTypeFilter;
	ItemCategoryFilter: EContentBrowserItemCategoryFilter;
	ItemAttributeFilter: EContentBrowserItemAttributeFilter;
	clone() : ContentBrowserDataFilter;
	static C(Other: UObject | any): ContentBrowserDataFilter;
}

declare class ContentBrowserDataSubsystem extends EditorSubsystem { 
	EnabledDataSources: string[];
	static Load(ResourceName: string): ContentBrowserDataSubsystem;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserDataSubsystem;
	static GetDefaultObject(): ContentBrowserDataSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserDataSubsystem;
	GetItemsUnderPath(InPath: string,InFilter: ContentBrowserDataFilter): ContentBrowserItem[];
	GetItemsAtPath(InPath: string,InItemTypeFilter: EContentBrowserItemTypeFilter): ContentBrowserItem[];
	GetItemAtPath(InPath: string,InItemTypeFilter: EContentBrowserItemTypeFilter): ContentBrowserItem;
	GetAvailableDataSources(): string[];
	GetActiveDataSources(): string[];
	DeactivateDataSource(Name: string): boolean;
	DeactivateAllDataSources(): void;
	ActivateDataSource(Name: string): boolean;
	ActivateAllDataSources(): void;
	static C(Other: UObject | any): ContentBrowserDataSubsystem;
}

declare class ContentBrowserItemLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): ContentBrowserItemLibrary;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserItemLibrary;
	static GetDefaultObject(): ContentBrowserItemLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserItemLibrary;
	static IsFolder(Item: ContentBrowserItem): boolean;
	static IsFile(Item: ContentBrowserItem): boolean;
	static GetVirtualPath(Item: ContentBrowserItem): string;
	static GetDisplayName(Item: ContentBrowserItem): string;
	static C(Other: UObject | any): ContentBrowserItemLibrary;
}

declare type EContentBrowserPathType = 'None' | 'Internal' | 'Virtual' | 'EContentBrowserPathType_MAX';
declare var EContentBrowserPathType : { None:'None',Internal:'Internal',Virtual:'Virtual',EContentBrowserPathType_MAX:'EContentBrowserPathType_MAX', };
declare class ContentBrowserItemPath { 
	clone() : ContentBrowserItemPath;
	static C(Other: UObject | any): ContentBrowserItemPath;
	BreakContentBrowserItemPath(VirtualPath?: string,InternalPath?: string): {VirtualPath: string, InternalPath: string};
	GetInternalPath(): string;
	GetVirtualPath(): string;
	SetPath(InPath?: string,InPathType?: EContentBrowserPathType): {ItemPath: ContentBrowserItemPath};
	static BreakContentBrowserItemPath(ItemPath: ContentBrowserItemPath,VirtualPath?: string,InternalPath?: string): {VirtualPath: string, InternalPath: string};
	static GetInternalPath(ItemPath: ContentBrowserItemPath): string;
	static GetVirtualPath(ItemPath: ContentBrowserItemPath): string;
	static SetPath(ItemPath?: ContentBrowserItemPath,InPath?: string,InPathType?: EContentBrowserPathType): {ItemPath: ContentBrowserItemPath};
	static MakeContentBrowserItemPath(InPath: string,InPathType: EContentBrowserPathType): ContentBrowserItemPath;
}

declare class ContentBrowserItemPathExtensions extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): ContentBrowserItemPathExtensions;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserItemPathExtensions;
	static GetDefaultObject(): ContentBrowserItemPathExtensions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserItemPathExtensions;
	static SetPath(ItemPath?: ContentBrowserItemPath,InPath?: string,InPathType?: EContentBrowserPathType): {ItemPath: ContentBrowserItemPath};
	static MakeContentBrowserItemPath(InPath: string,InPathType: EContentBrowserPathType): ContentBrowserItemPath;
	static GetVirtualPath(ItemPath: ContentBrowserItemPath): string;
	static GetInternalPath(ItemPath: ContentBrowserItemPath): string;
	static BreakContentBrowserItemPath(ItemPath: ContentBrowserItemPath,VirtualPath?: string,InternalPath?: string): {VirtualPath: string, InternalPath: string};
	static C(Other: UObject | any): ContentBrowserItemPathExtensions;
}

declare class ClassViewerProjectSettings extends UObject { 
	InternalOnlyPaths: DirectoryPath[];
	InternalOnlyClasses: SoftClassPath[];
	static Load(ResourceName: string): ClassViewerProjectSettings;
	static Find(Outer: UObject, ResourceName: string): ClassViewerProjectSettings;
	static GetDefaultObject(): ClassViewerProjectSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClassViewerProjectSettings;
	static C(Other: UObject | any): ClassViewerProjectSettings;
}

declare type EHardwareClass = 'Unspecified' | 'Desktop' | 'Mobile' | 'EHardwareClass_MAX';
declare var EHardwareClass : { Unspecified:'Unspecified',Desktop:'Desktop',Mobile:'Mobile',EHardwareClass_MAX:'EHardwareClass_MAX', };
declare type EGraphicsPreset = 'Unspecified' | 'Maximum' | 'Scalable' | 'EGraphicsPreset_MAX';
declare var EGraphicsPreset : { Unspecified:'Unspecified',Maximum:'Maximum',Scalable:'Scalable',EGraphicsPreset_MAX:'EGraphicsPreset_MAX', };
declare class HardwareTargetingSettings extends UObject { 
	TargetedHardwareClass: EHardwareClass;
	AppliedTargetedHardwareClass: EHardwareClass;
	DefaultGraphicsPerformance: EGraphicsPreset;
	AppliedDefaultGraphicsPerformance: EGraphicsPreset;
	static Load(ResourceName: string): HardwareTargetingSettings;
	static Find(Outer: UObject, ResourceName: string): HardwareTargetingSettings;
	static GetDefaultObject(): HardwareTargetingSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HardwareTargetingSettings;
	static C(Other: UObject | any): HardwareTargetingSettings;
}

declare class ClassTemplate extends UObject { 
	GeneratedBaseClass: UnrealEngineClass;
	static Load(ResourceName: string): ClassTemplate;
	static Find(Outer: UObject, ResourceName: string): ClassTemplate;
	static GetDefaultObject(): ClassTemplate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClassTemplate;
	static C(Other: UObject | any): ClassTemplate;
}

declare class PluginClassTemplate extends ClassTemplate { 
	PluginName: string;
	static Load(ResourceName: string): PluginClassTemplate;
	static Find(Outer: UObject, ResourceName: string): PluginClassTemplate;
	static GetDefaultObject(): PluginClassTemplate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PluginClassTemplate;
	static C(Other: UObject | any): PluginClassTemplate;
}

declare class ClassTemplateEditorSubsystem extends EditorSubsystem { 
	static Load(ResourceName: string): ClassTemplateEditorSubsystem;
	static Find(Outer: UObject, ResourceName: string): ClassTemplateEditorSubsystem;
	static GetDefaultObject(): ClassTemplateEditorSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClassTemplateEditorSubsystem;
	static C(Other: UObject | any): ClassTemplateEditorSubsystem;
}

declare class LocalizedTemplateString { 
	Language: string;
	Text: string;
	clone() : LocalizedTemplateString;
	static C(Other: UObject | any): LocalizedTemplateString;
}

declare class TemplateFolderRename { 
	From: string;
	To: string;
	clone() : TemplateFolderRename;
	static C(Other: UObject | any): TemplateFolderRename;
}

declare class TemplateReplacement { 
	Extensions: string[];
	From: string;
	To: string;
	bCaseSensitive: boolean;
	clone() : TemplateReplacement;
	static C(Other: UObject | any): TemplateReplacement;
}

declare type ETemplateSetting = 'Languages' | 'HardwareTarget' | 'GraphicsPreset' | 'StarterContent' | 'XR' | 'Raytracing' | 'All' | 'ETemplateSetting_MAX';
declare var ETemplateSetting : { Languages:'Languages',HardwareTarget:'HardwareTarget',GraphicsPreset:'GraphicsPreset',StarterContent:'StarterContent',XR:'XR',Raytracing:'Raytracing',All:'All',ETemplateSetting_MAX:'ETemplateSetting_MAX', };
declare type EFeaturePackDetailLevel = 'Standard' | 'High' | 'EFeaturePackDetailLevel_MAX';
declare var EFeaturePackDetailLevel : { Standard:'Standard',High:'High',EFeaturePackDetailLevel_MAX:'EFeaturePackDetailLevel_MAX', };
declare class FeaturePackLevelSet { 
	DetailLevels: EFeaturePackDetailLevel[];
	MountName: string;
	clone() : FeaturePackLevelSet;
	static C(Other: UObject | any): FeaturePackLevelSet;
}

declare class TemplateProjectDefs extends UObject { 
	LocalizedDisplayNames: LocalizedTemplateString[];
	LocalizedDescriptions: LocalizedTemplateString[];
	FoldersToIgnore: string[];
	FilesToIgnore: string[];
	FolderRenames: TemplateFolderRename[];
	FilenameReplacements: TemplateReplacement[];
	ReplacementsInFiles: TemplateReplacement[];
	SortKey: string;
	Categories: string[];
	ClassTypes: string;
	AssetTypes: string;
	bAllowProjectCreation: boolean;
	bIsEnterprise: boolean;
	bIsBlank: boolean;
	bThumbnailAsIcon: boolean;
	HiddenSettings: ETemplateSetting[];
	PacksToInclude: string[];
	EditDetailLevelPreference: EFeaturePackDetailLevel;
	SharedContentPacks: FeaturePackLevelSet[];
	StarterContent: string;
	static Load(ResourceName: string): TemplateProjectDefs;
	static Find(Outer: UObject, ResourceName: string): TemplateProjectDefs;
	static GetDefaultObject(): TemplateProjectDefs;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TemplateProjectDefs;
	static C(Other: UObject | any): TemplateProjectDefs;
}

declare class DefaultTemplateProjectDefs extends TemplateProjectDefs { 
	static Load(ResourceName: string): DefaultTemplateProjectDefs;
	static Find(Outer: UObject, ResourceName: string): DefaultTemplateProjectDefs;
	static GetDefaultObject(): DefaultTemplateProjectDefs;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DefaultTemplateProjectDefs;
	static C(Other: UObject | any): DefaultTemplateProjectDefs;
}

declare class TemplateCategoryDef { 
	Key: string;
	LocalizedDisplayNames: LocalizedTemplateString[];
	LocalizedDescriptions: LocalizedTemplateString[];
	Icon: string;
	IsMajorCategory: boolean;
	clone() : TemplateCategoryDef;
	static C(Other: UObject | any): TemplateCategoryDef;
}

declare class TemplateCategories extends UObject { 
	Categories: TemplateCategoryDef[];
	static Load(ResourceName: string): TemplateCategories;
	static Find(Outer: UObject, ResourceName: string): TemplateCategories;
	static GetDefaultObject(): TemplateCategories;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TemplateCategories;
	static C(Other: UObject | any): TemplateCategories;
}

declare class StatusBarSubsystem extends EditorSubsystem { 
	static Load(ResourceName: string): StatusBarSubsystem;
	static Find(Outer: UObject, ResourceName: string): StatusBarSubsystem;
	static GetDefaultObject(): StatusBarSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StatusBarSubsystem;
	static C(Other: UObject | any): StatusBarSubsystem;
}

declare type ELogTimes = 'None' | 'UTC' | 'SinceGStartTime' | 'Local' | 'ELogTimes_MAX';
declare var ELogTimes : { None:'None',UTC:'UTC',SinceGStartTime:'SinceGStartTime',Local:'Local',ELogTimes_MAX:'ELogTimes_MAX', };
declare type ELogCategoryColorizationMode = 'None' | 'ColorizeWholeLine' | 'ColorizeCategoryOnly' | 'ColorizeCategoryAsBadge' | 'ELogCategoryColorizationMode_MAX';
declare var ELogCategoryColorizationMode : { None:'None',ColorizeWholeLine:'ColorizeWholeLine',ColorizeCategoryOnly:'ColorizeCategoryOnly',ColorizeCategoryAsBadge:'ColorizeCategoryAsBadge',ELogCategoryColorizationMode_MAX:'ELogCategoryColorizationMode_MAX', };
declare class OutputLogSettings extends UObject { 
	LogFontSize: number;
	LogTimestampMode: ELogTimes;
	CategoryColorizationMode: ELogCategoryColorizationMode;
	bCycleToOutputLogDrawer: boolean;
	bEnableOutputLogWordWrap: boolean;
	bEnableOutputLogClearOnPIE: boolean;
	static Load(ResourceName: string): OutputLogSettings;
	static Find(Outer: UObject, ResourceName: string): OutputLogSettings;
	static GetDefaultObject(): OutputLogSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OutputLogSettings;
	static C(Other: UObject | any): OutputLogSettings;
}

declare class SourceCodeAccessSettings extends UObject { 
	PreferredAccessor: string;
	static Load(ResourceName: string): SourceCodeAccessSettings;
	static Find(Outer: UObject, ResourceName: string): SourceCodeAccessSettings;
	static GetDefaultObject(): SourceCodeAccessSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SourceCodeAccessSettings;
	static C(Other: UObject | any): SourceCodeAccessSettings;
}

declare class ContentBrowserFrontEndFilterExtension extends UObject { 
	static Load(ResourceName: string): ContentBrowserFrontEndFilterExtension;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserFrontEndFilterExtension;
	static GetDefaultObject(): ContentBrowserFrontEndFilterExtension;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserFrontEndFilterExtension;
	static C(Other: UObject | any): ContentBrowserFrontEndFilterExtension;
}

declare class ContentBrowserAssetContextMenuContext extends UObject { 
	SelectedAssets: AssetData[];
	CommonClass: UnrealEngineClass;
	bCanBeModified: boolean;
	static Load(ResourceName: string): ContentBrowserAssetContextMenuContext;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserAssetContextMenuContext;
	static GetDefaultObject(): ContentBrowserAssetContextMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserAssetContextMenuContext;
	LoadSelectedObjects(): UObject[];
	GetSelectedObjects(): UObject[];
	static C(Other: UObject | any): ContentBrowserAssetContextMenuContext;
}

declare class ContentBrowserAssetViewContextMenuContext extends UObject { 
	static Load(ResourceName: string): ContentBrowserAssetViewContextMenuContext;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserAssetViewContextMenuContext;
	static GetDefaultObject(): ContentBrowserAssetViewContextMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserAssetViewContextMenuContext;
	static C(Other: UObject | any): ContentBrowserAssetViewContextMenuContext;
}

declare class ContentBrowserMenuContext extends UObject { 
	static Load(ResourceName: string): ContentBrowserMenuContext;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserMenuContext;
	static GetDefaultObject(): ContentBrowserMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserMenuContext;
	static C(Other: UObject | any): ContentBrowserMenuContext;
}

declare class ContentBrowserFolderContext extends ContentBrowserMenuContext { 
	bCanBeModified: boolean;
	bNoFolderOnDisk: boolean;
	NumAssetPaths: number;
	NumClassPaths: number;
	SelectedPackagePaths: string[];
	static Load(ResourceName: string): ContentBrowserFolderContext;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserFolderContext;
	static GetDefaultObject(): ContentBrowserFolderContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserFolderContext;
	static C(Other: UObject | any): ContentBrowserFolderContext;
}

declare class ContentBrowserFilterListContext extends UObject { 
	static Load(ResourceName: string): ContentBrowserFilterListContext;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserFilterListContext;
	static GetDefaultObject(): ContentBrowserFilterListContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserFilterListContext;
	static C(Other: UObject | any): ContentBrowserFilterListContext;
}

declare class ContentBrowserAddNewContextMenuContext extends UObject { 
	static Load(ResourceName: string): ContentBrowserAddNewContextMenuContext;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserAddNewContextMenuContext;
	static GetDefaultObject(): ContentBrowserAddNewContextMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserAddNewContextMenuContext;
	static C(Other: UObject | any): ContentBrowserAddNewContextMenuContext;
}

declare class ContentBrowserToolbarMenuContext extends UObject { 
	static Load(ResourceName: string): ContentBrowserToolbarMenuContext;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserToolbarMenuContext;
	static GetDefaultObject(): ContentBrowserToolbarMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserToolbarMenuContext;
	static C(Other: UObject | any): ContentBrowserToolbarMenuContext;
}

declare class TextFilterKeyValueHandler extends UObject { 
	static Load(ResourceName: string): TextFilterKeyValueHandler;
	static Find(Outer: UObject, ResourceName: string): TextFilterKeyValueHandler;
	static GetDefaultObject(): TextFilterKeyValueHandler;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextFilterKeyValueHandler;
	static C(Other: UObject | any): TextFilterKeyValueHandler;
}

declare class TextFilterKeyValueHandlerEntry { 
	Key: string;
	HandlerClass: Class;
	clone() : TextFilterKeyValueHandlerEntry;
	static C(Other: UObject | any): TextFilterKeyValueHandlerEntry;
}

declare class TextFilterKeyValueHandlers extends UObject { 
	TextFilterKeyValueHandlers: TextFilterKeyValueHandlerEntry[];
	static Load(ResourceName: string): TextFilterKeyValueHandlers;
	static Find(Outer: UObject, ResourceName: string): TextFilterKeyValueHandlers;
	static GetDefaultObject(): TextFilterKeyValueHandlers;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextFilterKeyValueHandlers;
	static C(Other: UObject | any): TextFilterKeyValueHandlers;
}

declare class TextFilterValueHandler extends UObject { 
	static Load(ResourceName: string): TextFilterValueHandler;
	static Find(Outer: UObject, ResourceName: string): TextFilterValueHandler;
	static GetDefaultObject(): TextFilterValueHandler;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextFilterValueHandler;
	static C(Other: UObject | any): TextFilterValueHandler;
}

declare class TextFilterValueHandlers extends UObject { 
	TextFilterValueHandlers: Class[];
	static Load(ResourceName: string): TextFilterValueHandlers;
	static Find(Outer: UObject, ResourceName: string): TextFilterValueHandlers;
	static GetDefaultObject(): TextFilterValueHandlers;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextFilterValueHandlers;
	static C(Other: UObject | any): TextFilterValueHandlers;
}

declare class DocumentationBaseUrl { 
	ID: string;
	URL: string;
	clone() : DocumentationBaseUrl;
	static C(Other: UObject | any): DocumentationBaseUrl;
}

declare class DocumentationSettings extends DeveloperSettings { 
	DocumentationBaseUrls: DocumentationBaseUrl[];
	static Load(ResourceName: string): DocumentationSettings;
	static Find(Outer: UObject, ResourceName: string): DocumentationSettings;
	static GetDefaultObject(): DocumentationSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DocumentationSettings;
	static C(Other: UObject | any): DocumentationSettings;
}

declare type ELocalizationTargetConflictStatus = 'Unknown' | 'ConflictsPresent' | 'Clear' | 'ELocalizationTargetConflictStatus_MAX';
declare var ELocalizationTargetConflictStatus : { Unknown:'Unknown',ConflictsPresent:'ConflictsPresent',Clear:'Clear',ELocalizationTargetConflictStatus_MAX:'ELocalizationTargetConflictStatus_MAX', };
declare type ELocalizationGatherPathRoot = 'Auto' | 'Engine' | 'Project' | 'ELocalizationGatherPathRoot_MAX';
declare var ELocalizationGatherPathRoot : { Auto:'Auto',Engine:'Engine',Project:'Project',ELocalizationGatherPathRoot_MAX:'ELocalizationGatherPathRoot_MAX', };
declare class GatherTextSearchDirectory { 
	PathRoot: ELocalizationGatherPathRoot;
	Path: string;
	clone() : GatherTextSearchDirectory;
	static C(Other: UObject | any): GatherTextSearchDirectory;
}

declare class GatherTextExcludePath { 
	PathRoot: ELocalizationGatherPathRoot;
	Pattern: string;
	clone() : GatherTextExcludePath;
	static C(Other: UObject | any): GatherTextExcludePath;
}

declare class GatherTextFileExtension { 
	Pattern: string;
	clone() : GatherTextFileExtension;
	static C(Other: UObject | any): GatherTextFileExtension;
}

declare class GatherTextFromTextFilesConfiguration { 
	IsEnabled: boolean;
	SearchDirectories: GatherTextSearchDirectory[];
	ExcludePathWildcards: GatherTextExcludePath[];
	FileExtensions: GatherTextFileExtension[];
	ShouldGatherFromEditorOnlyData: boolean;
	clone() : GatherTextFromTextFilesConfiguration;
	static C(Other: UObject | any): GatherTextFromTextFilesConfiguration;
}

declare class GatherTextIncludePath { 
	PathRoot: ELocalizationGatherPathRoot;
	Pattern: string;
	clone() : GatherTextIncludePath;
	static C(Other: UObject | any): GatherTextIncludePath;
}

declare class GatherTextFromPackagesConfiguration { 
	IsEnabled: boolean;
	IncludePathWildcards: GatherTextIncludePath[];
	ExcludePathWildcards: GatherTextExcludePath[];
	FileExtensions: GatherTextFileExtension[];
	Collections: string[];
	ExcludeClasses: SoftClassPath[];
	ShouldExcludeDerivedClasses: boolean;
	ShouldGatherFromEditorOnlyData: boolean;
	SkipGatherCache: boolean;
	clone() : GatherTextFromPackagesConfiguration;
	static C(Other: UObject | any): GatherTextFromPackagesConfiguration;
}

declare class MetaDataKeyName { 
	Name: string;
	clone() : MetaDataKeyName;
	static C(Other: UObject | any): MetaDataKeyName;
}

declare class MetaDataTextKeyPattern { 
	Pattern: string;
	clone() : MetaDataTextKeyPattern;
	static C(Other: UObject | any): MetaDataTextKeyPattern;
}

declare class MetaDataKeyGatherSpecification { 
	MetaDataKey: MetaDataKeyName;
	TextNamespace: string;
	TextKeyPattern: MetaDataTextKeyPattern;
	clone() : MetaDataKeyGatherSpecification;
	static C(Other: UObject | any): MetaDataKeyGatherSpecification;
}

declare class GatherTextFromMetaDataConfiguration { 
	IsEnabled: boolean;
	IncludePathWildcards: GatherTextIncludePath[];
	ExcludePathWildcards: GatherTextExcludePath[];
	KeySpecifications: MetaDataKeyGatherSpecification[];
	ShouldGatherFromEditorOnlyData: boolean;
	clone() : GatherTextFromMetaDataConfiguration;
	static C(Other: UObject | any): GatherTextFromMetaDataConfiguration;
}

declare type ELocalizedTextCollapseMode = 'IdenticalTextIdAndSource' | 'IdenticalPackageIdTextIdAndSource' | 'IdenticalNamespaceAndSource' | 'ELocalizedTextCollapseMode_MAX';
declare var ELocalizedTextCollapseMode : { IdenticalTextIdAndSource:'IdenticalTextIdAndSource',IdenticalPackageIdTextIdAndSource:'IdenticalPackageIdTextIdAndSource',IdenticalNamespaceAndSource:'IdenticalNamespaceAndSource',ELocalizedTextCollapseMode_MAX:'ELocalizedTextCollapseMode_MAX', };
declare type EPortableObjectFormat = 'Unreal' | 'Crowdin' | 'EPortableObjectFormat_MAX';
declare var EPortableObjectFormat : { Unreal:'Unreal',Crowdin:'Crowdin',EPortableObjectFormat_MAX:'EPortableObjectFormat_MAX', };
declare class LocalizationExportingSettings { 
	CollapseMode: ELocalizedTextCollapseMode;
	POFormat: EPortableObjectFormat;
	ShouldPersistCommentsOnExport: boolean;
	ShouldAddSourceLocationsAsComments: boolean;
	clone() : LocalizationExportingSettings;
	static C(Other: UObject | any): LocalizationExportingSettings;
}

declare class LocalizationCompilationSettings { 
	SkipSourceCheck: boolean;
	ValidateFormatPatterns: boolean;
	ValidateSafeWhitespace: boolean;
	clone() : LocalizationCompilationSettings;
	static C(Other: UObject | any): LocalizationCompilationSettings;
}

declare class LocalizationImportDialogueSettings { 
	RawAudioPath: DirectoryPath;
	ImportedDialogueFolder: string;
	bImportNativeAsSource: boolean;
	clone() : LocalizationImportDialogueSettings;
	static C(Other: UObject | any): LocalizationImportDialogueSettings;
}

declare class CultureStatistics { 
	CultureName: string;
	WordCount: number;
	clone() : CultureStatistics;
	static C(Other: UObject | any): CultureStatistics;
}

declare class LocalizationTargetSettings { 
	Name: string;
	Guid: Guid;
	ConflictStatus: ELocalizationTargetConflictStatus;
	TargetDependencies: Guid[];
	AdditionalManifestDependencies: FilePath[];
	RequiredModuleNames: string[];
	GatherFromTextFiles: GatherTextFromTextFilesConfiguration;
	GatherFromPackages: GatherTextFromPackagesConfiguration;
	GatherFromMetaData: GatherTextFromMetaDataConfiguration;
	ExportSettings: LocalizationExportingSettings;
	CompileSettings: LocalizationCompilationSettings;
	ImportDialogueSettings: LocalizationImportDialogueSettings;
	NativeCultureIndex: number;
	SupportedCulturesStatistics: CultureStatistics[];
	clone() : LocalizationTargetSettings;
	static C(Other: UObject | any): LocalizationTargetSettings;
}

declare class LocalizationTarget extends UObject { 
	Settings: LocalizationTargetSettings;
	static Load(ResourceName: string): LocalizationTarget;
	static Find(Outer: UObject, ResourceName: string): LocalizationTarget;
	static GetDefaultObject(): LocalizationTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalizationTarget;
	static C(Other: UObject | any): LocalizationTarget;
}

declare class LocalizationTargetSet extends UObject { 
	TargetObjects: LocalizationTarget[];
	static Load(ResourceName: string): LocalizationTargetSet;
	static Find(Outer: UObject, ResourceName: string): LocalizationTargetSet;
	static GetDefaultObject(): LocalizationTargetSet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalizationTargetSet;
	static C(Other: UObject | any): LocalizationTargetSet;
}

declare class LocalizationSettings extends UObject { 
	EngineTargetSet: LocalizationTargetSet;
	EngineTargetsSettings: LocalizationTargetSettings[];
	GameTargetSet: LocalizationTargetSet;
	GameTargetsSettings: LocalizationTargetSettings[];
	static Load(ResourceName: string): LocalizationSettings;
	static Find(Outer: UObject, ResourceName: string): LocalizationSettings;
	static GetDefaultObject(): LocalizationSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalizationSettings;
	static C(Other: UObject | any): LocalizationSettings;
}

declare class InternationalizationExportSettings extends UObject { 
	CulturesToGenerate: string[];
	CommandletClass: string;
	SourcePath: string;
	DestinationPath: string;
	PortableObjectName: string;
	ManifestName: string;
	ArchiveName: string;
	bExportLoc: boolean;
	bImportLoc: boolean;
	bUseCultureDirectory: boolean;
	static Load(ResourceName: string): InternationalizationExportSettings;
	static Find(Outer: UObject, ResourceName: string): InternationalizationExportSettings;
	static GetDefaultObject(): InternationalizationExportSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InternationalizationExportSettings;
	static C(Other: UObject | any): InternationalizationExportSettings;
}

declare class TranslationPickerSettings extends UObject { 
	bSubmitTranslationPickerChangesToLocalizationService: boolean;
	static Load(ResourceName: string): TranslationPickerSettings;
	static Find(Outer: UObject, ResourceName: string): TranslationPickerSettings;
	static GetDefaultObject(): TranslationPickerSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TranslationPickerSettings;
	static C(Other: UObject | any): TranslationPickerSettings;
}

declare class TranslationChange { 
	Version: string;
	DateAndTime: DateTime;
	Source: string;
	Translation: string;
	clone() : TranslationChange;
	static C(Other: UObject | any): TranslationChange;
}

declare class TranslationContextInfo { 
	Key: string;
	Context: string;
	Changes: TranslationChange[];
	clone() : TranslationContextInfo;
	static C(Other: UObject | any): TranslationContextInfo;
}

declare class TranslationUnit extends UObject { 
	Namespace: string;
	Key: string;
	Source: string;
	Translation: string;
	Contexts: TranslationContextInfo[];
	HasBeenReviewed: boolean;
	TranslationBeforeImport: string;
	LocresPath: string;
	static Load(ResourceName: string): TranslationUnit;
	static Find(Outer: UObject, ResourceName: string): TranslationUnit;
	static GetDefaultObject(): TranslationUnit;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TranslationUnit;
	static C(Other: UObject | any): TranslationUnit;
}

declare class CookerStats extends UObject { 
	Assets: UObject[];
	SizeBefore: number;
	SizeAfter: number;
	Path: string;
	static Load(ResourceName: string): CookerStats;
	static Find(Outer: UObject, ResourceName: string): CookerStats;
	static GetDefaultObject(): CookerStats;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CookerStats;
	static C(Other: UObject | any): CookerStats;
}

declare class LightingBuildInfo extends UObject { 
	UObject: UObject;
	LightingTime: number;
	UnmappedTexelsPercentage: number;
	UnmappedTexelsMemory: number;
	TotalTexelMemory: number;
	LevelName: string;
	static Load(ResourceName: string): LightingBuildInfo;
	static Find(Outer: UObject, ResourceName: string): LightingBuildInfo;
	static GetDefaultObject(): LightingBuildInfo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightingBuildInfo;
	static C(Other: UObject | any): LightingBuildInfo;
}

declare class PrimitiveStats extends UObject { 
	UObject: UObject;
	Actors: Actor[];
	Type: string;
	Count: number;
	Sections: number;
	HWInstances: number;
	InstSections: number;
	Triangles: number;
	InstTriangles: number;
	ResourceSize: number;
	VertexColorMem: number;
	InstVertexColorMem: number;
	LightsLM: number;
	LightsOther: number;
	LightsTotal: number;
	ObjLightCost: number;
	LightMapData: number;
	LMSMResolution: number;
	RadiusMin: number;
	RadiusMax: number;
	RadiusAvg: number;
	static Load(ResourceName: string): PrimitiveStats;
	static Find(Outer: UObject, ResourceName: string): PrimitiveStats;
	static GetDefaultObject(): PrimitiveStats;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PrimitiveStats;
	static C(Other: UObject | any): PrimitiveStats;
}

declare class ShaderCookerStats extends UObject { 
	Name: string;
	Platform: string;
	Category: string;
	Compiled: number;
	Cooked: number;
	Permutations: number;
	CompileTime: number;
	Path: string;
	static Load(ResourceName: string): ShaderCookerStats;
	static Find(Outer: UObject, ResourceName: string): ShaderCookerStats;
	static GetDefaultObject(): ShaderCookerStats;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ShaderCookerStats;
	static C(Other: UObject | any): ShaderCookerStats;
}

declare class StaticMeshLightingInfo extends UObject { 
	StaticMeshActor: Actor;
	StaticMesh: StaticMesh;
	LevelName: string;
	TextureMapping: string;
	bTextureMapping: boolean;
	bHasLightmapTexCoords: boolean;
	StaticLightingResolution: number;
	TextureLightMapMemoryUsage: number;
	VertexLightMapMemoryUsage: number;
	LightMapLightCount: number;
	TextureShadowMapMemoryUsage: number;
	VertexShadowMapMemoryUsage: number;
	ShadowMapLightCount: number;
	LightmapTextureNames: string[];
	static Load(ResourceName: string): StaticMeshLightingInfo;
	static Find(Outer: UObject, ResourceName: string): StaticMeshLightingInfo;
	static GetDefaultObject(): StaticMeshLightingInfo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StaticMeshLightingInfo;
	static C(Other: UObject | any): StaticMeshLightingInfo;
}

declare class TextureStats extends UObject { 
	Texture: Texture;
	Actors: Actor[];
	Type: string;
	Virtual: string;
	MaxDim: Vector2D;
	CurrentDim: Vector2D;
	Format: EPixelFormat;
	Group: TextureGroup;
	LODBias: number;
	CurrentKB: number;
	FullyLoadedKB: number;
	NumUses: number;
	LastTimeRendered: number;
	Path: string;
	static Load(ResourceName: string): TextureStats;
	static Find(Outer: UObject, ResourceName: string): TextureStats;
	static GetDefaultObject(): TextureStats;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureStats;
	static C(Other: UObject | any): TextureStats;
}

declare type EPIEPreviewDeviceType = 'Unset' | 'Android' | 'IOS' | 'TVOS' | 'Switch' | 'MAX';
declare var EPIEPreviewDeviceType : { Unset:'Unset',Android:'Android',IOS:'IOS',TVOS:'TVOS',Switch:'Switch',MAX:'MAX', };
declare class PIEPreviewDeviceSpecification extends UObject { 
	PreviewDeviceType: EPIEPreviewDeviceType;
	GPUFamily: string;
	GLVersion: string;
	VulkanVersion: string;
	AndroidVersion: string;
	DeviceMake: string;
	DeviceModel: string;
	DeviceBuildNumber: string;
	UsingHoudini: boolean;
	Hardware: string;
	Chipset: string;
	static Load(ResourceName: string): PIEPreviewDeviceSpecification;
	static Find(Outer: UObject, ResourceName: string): PIEPreviewDeviceSpecification;
	static GetDefaultObject(): PIEPreviewDeviceSpecification;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PIEPreviewDeviceSpecification;
	static C(Other: UObject | any): PIEPreviewDeviceSpecification;
}

declare class JsonUtilitiesDummyObject extends UObject { 
	static Load(ResourceName: string): JsonUtilitiesDummyObject;
	static Find(Outer: UObject, ResourceName: string): JsonUtilitiesDummyObject;
	static GetDefaultObject(): JsonUtilitiesDummyObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JsonUtilitiesDummyObject;
	static C(Other: UObject | any): JsonUtilitiesDummyObject;
}

declare class Commandlet extends UObject { 
	HelpDescription: string;
	HelpUsage: string;
	HelpWebLink: string;
	HelpParamNames: string[];
	HelpParamDescriptions: string[];
	IsServer: boolean;
	IsClient: boolean;
	IsEditor: boolean;
	LogToConsole: boolean;
	ShowErrorCount: boolean;
	ShowProgress: boolean;
	static Load(ResourceName: string): Commandlet;
	static Find(Outer: UObject, ResourceName: string): Commandlet;
	static GetDefaultObject(): Commandlet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Commandlet;
	static C(Other: UObject | any): Commandlet;
}

declare class CheckAndroidDeviceProfileCommandlet extends Commandlet { 
	static Load(ResourceName: string): CheckAndroidDeviceProfileCommandlet;
	static Find(Outer: UObject, ResourceName: string): CheckAndroidDeviceProfileCommandlet;
	static GetDefaultObject(): CheckAndroidDeviceProfileCommandlet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CheckAndroidDeviceProfileCommandlet;
	static C(Other: UObject | any): CheckAndroidDeviceProfileCommandlet;
}

declare class ActorBrowsingModeConfig { 
	bHideTemporaryActors: boolean;
	bShowOnlyActorsInCurrentLevel: boolean;
	bShowOnlySelectedActors: boolean;
	bHideActorComponents: boolean;
	bHideLevelInstanceHierarchy: boolean;
	bHideUnloadedActors: boolean;
	bHideEmptyFolders: boolean;
	bAlwaysFrameSelection: boolean;
	clone() : ActorBrowsingModeConfig;
	static C(Other: UObject | any): ActorBrowsingModeConfig;
}

declare class ActorBrowserConfig extends EditorConfigBase { 
	ActorBrowsers: Map<string, ActorBrowsingModeConfig>;
	static Load(ResourceName: string): ActorBrowserConfig;
	static Find(Outer: UObject, ResourceName: string): ActorBrowserConfig;
	static GetDefaultObject(): ActorBrowserConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorBrowserConfig;
	static C(Other: UObject | any): ActorBrowserConfig;
}

declare class SceneOutlinerConfig { 
	ColumnVisibilities: Map<string, boolean>;
	bShouldStackHierarchyHeaders: boolean;
	clone() : SceneOutlinerConfig;
	static C(Other: UObject | any): SceneOutlinerConfig;
}

declare class OutlinerConfig extends EditorConfigBase { 
	Outliners: Map<string, SceneOutlinerConfig>;
	static Load(ResourceName: string): OutlinerConfig;
	static Find(Outer: UObject, ResourceName: string): OutlinerConfig;
	static GetDefaultObject(): OutlinerConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OutlinerConfig;
	static C(Other: UObject | any): OutlinerConfig;
}

declare class SceneOutlinerMenuContext extends UObject { 
	static Load(ResourceName: string): SceneOutlinerMenuContext;
	static Find(Outer: UObject, ResourceName: string): SceneOutlinerMenuContext;
	static GetDefaultObject(): SceneOutlinerMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SceneOutlinerMenuContext;
	static C(Other: UObject | any): SceneOutlinerMenuContext;
}

declare class PinTypeSelectorFilter extends UObject { 
	FilterClass: Class;
	static Load(ResourceName: string): PinTypeSelectorFilter;
	static Find(Outer: UObject, ResourceName: string): PinTypeSelectorFilter;
	static GetDefaultObject(): PinTypeSelectorFilter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PinTypeSelectorFilter;
	static C(Other: UObject | any): PinTypeSelectorFilter;
}

declare class NamedLensPreset { 
	Name: string;
	LensSettings: CameraLensSettings;
	clone() : NamedLensPreset;
	static C(Other: UObject | any): NamedLensPreset;
}

declare class NamedFilmbackPreset { 
	Name: string;
	FilmbackSettings: CameraFilmbackSettings;
	clone() : NamedFilmbackPreset;
	static C(Other: UObject | any): NamedFilmbackPreset;
}

declare class PlateCropSettings { 
	AspectRatio: number;
	clone() : PlateCropSettings;
	static C(Other: UObject | any): PlateCropSettings;
}

declare class NamedPlateCropPreset { 
	Name: string;
	CropSettings: PlateCropSettings;
	clone() : NamedPlateCropPreset;
	static C(Other: UObject | any): NamedPlateCropPreset;
}

declare class CineCameraSettings extends DeveloperSettings { 
	DefaultLensPresetName: string;
	DefaultLensFocalLength: number;
	DefaultLensFStop: number;
	LensPresets: NamedLensPreset[];
	DefaultFilmbackPreset: string;
	FilmbackPresets: NamedFilmbackPreset[];
	DefaultCropPresetName: string;
	CropPresets: NamedPlateCropPreset[];
	static Load(ResourceName: string): CineCameraSettings;
	static Find(Outer: UObject, ResourceName: string): CineCameraSettings;
	static GetDefaultObject(): CineCameraSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CineCameraSettings;
	SetLensPresets(InLensPresets: NamedLensPreset[]): void;
	SetFilmbackPresets(InFilmbackPresets: NamedFilmbackPreset[]): void;
	SetDefaultLensPresetName(InDefaultLensPresetName: string): void;
	SetDefaultLensFStop(InDefaultLensFStop: number): void;
	SetDefaultLensFocalLength(InDefaultLensFocalLength: number): void;
	SetDefaultFilmbackPreset(InDefaultFilmbackPreset: string): void;
	SetDefaultCropPresetName(InDefaultCropPresetName: string): void;
	SetCropPresets(InCropPresets: NamedPlateCropPreset[]): void;
	GetLensPresetNames(): string[];
	GetLensPresetByName(PresetName: string,LensSettings?: CameraLensSettings): {LensSettings: CameraLensSettings, $: boolean};
	GetFilmbackPresetNames(): string[];
	GetFilmbackPresetByName(PresetName: string,FilmbackSettings?: CameraFilmbackSettings): {FilmbackSettings: CameraFilmbackSettings, $: boolean};
	GetCropPresetNames(): string[];
	GetCropPresetByName(PresetName: string,CropSettings?: PlateCropSettings): {CropSettings: PlateCropSettings, $: boolean};
	static GetCineCameraSettings(): CineCameraSettings;
	static C(Other: UObject | any): CineCameraSettings;
}

declare class CameraRig_Crane extends Actor { 
	CranePitch: number;
	CraneYaw: number;
	CraneArmLength: number;
	bLockMountPitch: boolean;
	bLockMountYaw: boolean;
	TransformComponent: SceneComponent;
	CraneYawControl: SceneComponent;
	CranePitchControl: SceneComponent;
	CraneCameraMount: SceneComponent;
	PreviewMesh_CraneArm: StaticMeshComponent;
	PreviewMesh_CraneBase: StaticMeshComponent;
	PreviewMesh_CraneMount: StaticMeshComponent;
	PreviewMesh_CraneCounterWeight: StaticMeshComponent;
	static GetDefaultObject(): CameraRig_Crane;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraRig_Crane;
	static C(Other: UObject | any): CameraRig_Crane;
}

declare type EInterpCurveMode = 'CIM_Linear' | 'CIM_CurveAuto' | 'CIM_Constant' | 'CIM_CurveUser' | 'CIM_CurveBreak' | 'CIM_CurveAutoClamped' | 'CIM_MAX';
declare var EInterpCurveMode : { CIM_Linear:'CIM_Linear',CIM_CurveAuto:'CIM_CurveAuto',CIM_Constant:'CIM_Constant',CIM_CurveUser:'CIM_CurveUser',CIM_CurveBreak:'CIM_CurveBreak',CIM_CurveAutoClamped:'CIM_CurveAutoClamped',CIM_MAX:'CIM_MAX', };
declare class InterpCurvePointVector { 
	InVal: number;
	OutVal: Vector;
	ArriveTangent: Vector;
	LeaveTangent: Vector;
	InterpMode: EInterpCurveMode;
	clone() : InterpCurvePointVector;
	static C(Other: UObject | any): InterpCurvePointVector;
}

declare class InterpCurveVector { 
	Points: InterpCurvePointVector[];
	bIsLooped: boolean;
	LoopKeyOffset: number;
	clone() : InterpCurveVector;
	static C(Other: UObject | any): InterpCurveVector;
}

declare class InterpCurvePointQuat { 
	InVal: number;
	OutVal: Quat;
	ArriveTangent: Quat;
	LeaveTangent: Quat;
	InterpMode: EInterpCurveMode;
	clone() : InterpCurvePointQuat;
	static C(Other: UObject | any): InterpCurvePointQuat;
}

declare class InterpCurveQuat { 
	Points: InterpCurvePointQuat[];
	bIsLooped: boolean;
	LoopKeyOffset: number;
	clone() : InterpCurveQuat;
	static C(Other: UObject | any): InterpCurveQuat;
}

declare class InterpCurvePointFloat { 
	InVal: number;
	OutVal: number;
	ArriveTangent: number;
	LeaveTangent: number;
	InterpMode: EInterpCurveMode;
	clone() : InterpCurvePointFloat;
	static C(Other: UObject | any): InterpCurvePointFloat;
}

declare class InterpCurveFloat { 
	Points: InterpCurvePointFloat[];
	bIsLooped: boolean;
	LoopKeyOffset: number;
	clone() : InterpCurveFloat;
	static C(Other: UObject | any): InterpCurveFloat;
}

declare class SplineMetadata extends UObject { 
	static Load(ResourceName: string): SplineMetadata;
	static Find(Outer: UObject, ResourceName: string): SplineMetadata;
	static GetDefaultObject(): SplineMetadata;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SplineMetadata;
	static C(Other: UObject | any): SplineMetadata;
}

declare class SplineCurves { 
	Position: InterpCurveVector;
	Rotation: InterpCurveQuat;
	Scale: InterpCurveVector;
	ReparamTable: InterpCurveFloat;
	MetaData: SplineMetadata;
	Version: number;
	clone() : SplineCurves;
	static C(Other: UObject | any): SplineCurves;
}

declare type ESplineCoordinateSpace = 'Local' | 'World' | 'ESplineCoordinateSpace_MAX';
declare var ESplineCoordinateSpace : { Local:'Local',World:'World',ESplineCoordinateSpace_MAX:'ESplineCoordinateSpace_MAX', };
declare type ESplinePointType = 'Linear' | 'Curve' | 'Constant' | 'CurveClamped' | 'CurveCustomTangent' | 'ESplinePointType_MAX';
declare var ESplinePointType : { Linear:'Linear',Curve:'Curve',Constant:'Constant',CurveClamped:'CurveClamped',CurveCustomTangent:'CurveCustomTangent',ESplinePointType_MAX:'ESplinePointType_MAX', };
declare class SplinePoint { 
	InputKey: number;
	Position: Vector;
	ArriveTangent: Vector;
	LeaveTangent: Vector;
	Rotation: Rotator;
	Scale: Vector;
	Type: ESplinePointType;
	clone() : SplinePoint;
	static C(Other: UObject | any): SplinePoint;
}

declare class SplineComponent extends PrimitiveComponent { 
	SplineCurves: SplineCurves;
	SplineInfo: InterpCurveVector;
	SplineRotInfo: InterpCurveQuat;
	SplineScaleInfo: InterpCurveVector;
	SplineReparamTable: InterpCurveFloat;
	bAllowSplineEditingPerInstance: boolean;
	ReparamStepsPerSegment: number;
	Duration: number;
	bStationaryEndpoints: boolean;
	bSplineHasBeenEdited: boolean;
	bModifiedByConstructionScript: boolean;
	bInputSplinePointsToConstructionScript: boolean;
	bDrawDebug: boolean;
	bClosedLoop: boolean;
	bLoopPositionOverride: boolean;
	LoopPosition: number;
	DefaultUpVector: Vector;
	EditorUnselectedSplineSegmentColor: LinearColor;
	EditorSelectedSplineSegmentColor: LinearColor;
	EditorTangentColor: LinearColor;
	bAllowDiscontinuousSpline: boolean;
	bShouldVisualizeScale: boolean;
	ScaleVisualizationWidth: number;
	static Load(ResourceName: string): SplineComponent;
	static Find(Outer: UObject, ResourceName: string): SplineComponent;
	static GetDefaultObject(): SplineComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SplineComponent;
	UpdateSpline(): void;
	SetWorldLocationAtSplinePoint(PointIndex: number,InLocation: Vector): void;
	SetUpVectorAtSplinePoint(PointIndex: number,InUpVector: Vector,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	SetUnselectedSplineSegmentColor(SegmentColor: LinearColor): void;
	SetTangentsAtSplinePoint(PointIndex: number,InArriveTangent: Vector,InLeaveTangent: Vector,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	SetTangentColor(TangentColor: LinearColor): void;
	SetTangentAtSplinePoint(PointIndex: number,InTangent: Vector,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	SetSplineWorldPoints(Points: Vector[]): void;
	SetSplinePointType(PointIndex: number,Type: ESplinePointType,bUpdateSpline: boolean): void;
	SetSplinePoints(Points: Vector[],CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	SetSplineLocalPoints(Points: Vector[]): void;
	SetSelectedSplineSegmentColor(SegmentColor: LinearColor): void;
	SetScaleAtSplinePoint(PointIndex: number,InScaleVector: Vector,bUpdateSpline: boolean): void;
	SetRotationAtSplinePoint(PointIndex: number,InRotation: Rotator,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	SetLocationAtSplinePoint(PointIndex: number,InLocation: Vector,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	SetDrawDebug(bShow: boolean): void;
	SetDefaultUpVector(UpVector: Vector,CoordinateSpace: ESplineCoordinateSpace): void;
	SetClosedLoopAtPosition(bInClosedLoop: boolean,Key: number,bUpdateSpline: boolean): void;
	SetClosedLoop(bInClosedLoop: boolean,bUpdateSpline: boolean): void;
	RemoveSplinePoint(Index: number,bUpdateSpline: boolean): void;
	IsClosedLoop(): boolean;
	GetWorldTangentAtDistanceAlongSpline(Distance: number): Vector;
	GetWorldRotationAtTime(Time: number,bUseConstantVelocity: boolean): Rotator;
	GetWorldRotationAtDistanceAlongSpline(Distance: number): Rotator;
	GetWorldLocationAtTime(Time: number,bUseConstantVelocity: boolean): Vector;
	GetWorldLocationAtSplinePoint(PointIndex: number): Vector;
	GetWorldLocationAtDistanceAlongSpline(Distance: number): Vector;
	GetWorldDirectionAtTime(Time: number,bUseConstantVelocity: boolean): Vector;
	GetWorldDirectionAtDistanceAlongSpline(Distance: number): Vector;
	GetVectorPropertyAtSplinePoint(Index: number,PropertyName: string): Vector;
	GetVectorPropertyAtSplineInputKey(InKey: number,PropertyName: string): Vector;
	GetUpVectorAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Vector;
	GetUpVectorAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetUpVectorAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetUpVectorAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetTransformAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean,bUseScale: boolean): Transform;
	GetTransformAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace,bUseScale: boolean): Transform;
	GetTransformAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace,bUseScale: boolean): Transform;
	GetTransformAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace,bUseScale: boolean): Transform;
	GetTimeAtDistanceAlongSpline(Distance: number): number;
	GetTangentAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Vector;
	GetTangentAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetTangentAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetTangentAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetSplinePointType(PointIndex: number): ESplinePointType;
	GetSplineLength(): number;
	GetScaleAtTime(Time: number,bUseConstantVelocity: boolean): Vector;
	GetScaleAtSplinePoint(PointIndex: number): Vector;
	GetScaleAtSplineInputKey(InKey: number): Vector;
	GetScaleAtDistanceAlongSpline(Distance: number): Vector;
	GetRotationAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Rotator;
	GetRotationAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Rotator;
	GetRotationAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace): Rotator;
	GetRotationAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Rotator;
	GetRollAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): number;
	GetRollAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): number;
	GetRollAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace): number;
	GetRollAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): number;
	GetRightVectorAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Vector;
	GetRightVectorAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetRightVectorAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetRightVectorAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetNumberOfSplineSegments(): number;
	GetNumberOfSplinePoints(): number;
	GetLocationAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Vector;
	GetLocationAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetLocationAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetLocationAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetLocationAndTangentAtSplinePoint(PointIndex: number,Location?: Vector,Tangent?: Vector,CoordinateSpace?: ESplineCoordinateSpace): {Location: Vector, Tangent: Vector};
	GetLocalLocationAndTangentAtSplinePoint(PointIndex: number,LocalLocation?: Vector,LocalTangent?: Vector): {LocalLocation: Vector, LocalTangent: Vector};
	GetLeaveTangentAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetInputKeyValueAtDistanceAlongSpline(Distance: number): number;
	GetInputKeyAtDistanceAlongSpline(Distance: number): number;
	GetFloatPropertyAtSplinePoint(Index: number,PropertyName: string): number;
	GetFloatPropertyAtSplineInputKey(InKey: number,PropertyName: string): number;
	GetDistanceAlongSplineAtSplinePoint(PointIndex: number): number;
	GetDistanceAlongSplineAtSplineInputKey(InKey: number): number;
	GetDirectionAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Vector;
	GetDirectionAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetDirectionAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetDirectionAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetDefaultUpVector(CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetArriveTangentAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	FindUpVectorClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): Vector;
	FindTransformClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace,bUseScale: boolean): Transform;
	FindTangentClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): Vector;
	FindScaleClosestToWorldLocation(WorldLocation: Vector): Vector;
	FindRotationClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): Rotator;
	FindRollClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): number;
	FindRightVectorClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): Vector;
	FindLocationClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): Vector;
	FindInputKeyClosestToWorldLocation(WorldLocation: Vector): number;
	FindDirectionClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): Vector;
	DivideSplineIntoPolylineRecursiveWithDistances(StartDistanceAlongSpline: number,EndDistanceAlongSpline: number,CoordinateSpace: ESplineCoordinateSpace,MaxSquareDistanceFromSpline: number,OutPoints?: Vector[],OutDistancesAlongSpline?: number[]): {OutPoints: Vector[], OutDistancesAlongSpline: number[], $: boolean};
	DivideSplineIntoPolylineRecursive(StartDistanceAlongSpline: number,EndDistanceAlongSpline: number,CoordinateSpace: ESplineCoordinateSpace,MaxSquareDistanceFromSpline: number,OutPoints?: Vector[]): {OutPoints: Vector[], $: boolean};
	ConvertSplineToPolyLine(CoordinateSpace: ESplineCoordinateSpace,MaxSquareDistanceFromSpline: number,OutPoints?: Vector[]): {OutPoints: Vector[], $: boolean};
	ConvertSplineSegmentToPolyLine(SplinePointStartIndex: number,CoordinateSpace: ESplineCoordinateSpace,MaxSquareDistanceFromSpline: number,OutPoints?: Vector[]): {OutPoints: Vector[], $: boolean};
	ClearSplinePoints(bUpdateSpline: boolean): void;
	AddSplineWorldPoint(Position: Vector): void;
	AddSplinePointAtIndex(Position: Vector,Index: number,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	AddSplinePoint(Position: Vector,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	AddSplineLocalPoint(Position: Vector): void;
	AddPoints(Points: SplinePoint[],bUpdateSpline: boolean): void;
	AddPoint(Point: SplinePoint,bUpdateSpline: boolean): void;
	static C(Other: UObject | any): SplineComponent;
}

declare class SplineMeshParams { 
	StartPos: Vector;
	StartTangent: Vector;
	StartScale: Vector2D;
	StartRoll: number;
	StartOffset: Vector2D;
	EndPos: Vector;
	EndScale: Vector2D;
	EndTangent: Vector;
	EndRoll: number;
	EndOffset: Vector2D;
	clone() : SplineMeshParams;
	static C(Other: UObject | any): SplineMeshParams;
}

declare type ESplineMeshAxis = 'X' | 'Y' | 'Z' | 'ESplineMeshAxis_MAX';
declare var ESplineMeshAxis : { X:'X',Y:'Y',Z:'Z',ESplineMeshAxis_MAX:'ESplineMeshAxis_MAX', };
declare class SplineMeshComponent extends StaticMeshComponent { 
	SplineParams: SplineMeshParams;
	SplineUpDir: Vector;
	SplineBoundaryMin: number;
	CachedMeshBodySetupGuid: Guid;
	BodySetup: BodySetup;
	SplineBoundaryMax: number;
	bAllowSplineEditingPerInstance: boolean;
	bSmoothInterpRollScale: boolean;
	bMeshDirty: boolean;
	ForwardAxis: ESplineMeshAxis;
	VirtualTextureMainPassMaxDrawDistance: number;
	bSelected: boolean;
	static Load(ResourceName: string): SplineMeshComponent;
	static Find(Outer: UObject, ResourceName: string): SplineMeshComponent;
	static GetDefaultObject(): SplineMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SplineMeshComponent;
	UpdateMesh(): void;
	SetStartTangent(StartTangent: Vector,bUpdateMesh: boolean): void;
	SetStartScale(StartScale: Vector2D,bUpdateMesh: boolean): void;
	SetStartRoll(StartRoll: number,bUpdateMesh: boolean): void;
	SetStartPosition(StartPos: Vector,bUpdateMesh: boolean): void;
	SetStartOffset(StartOffset: Vector2D,bUpdateMesh: boolean): void;
	SetStartAndEnd(StartPos: Vector,StartTangent: Vector,EndPos: Vector,EndTangent: Vector,bUpdateMesh: boolean): void;
	SetSplineUpDir(InSplineUpDir: Vector,bUpdateMesh: boolean): void;
	SetForwardAxis(InForwardAxis: ESplineMeshAxis,bUpdateMesh: boolean): void;
	SetEndTangent(EndTangent: Vector,bUpdateMesh: boolean): void;
	SetEndScale(EndScale: Vector2D,bUpdateMesh: boolean): void;
	SetEndRoll(EndRoll: number,bUpdateMesh: boolean): void;
	SetEndPosition(EndPos: Vector,bUpdateMesh: boolean): void;
	SetEndOffset(EndOffset: Vector2D,bUpdateMesh: boolean): void;
	SetBoundaryMin(InBoundaryMin: number,bUpdateMesh: boolean): void;
	SetBoundaryMax(InBoundaryMax: number,bUpdateMesh: boolean): void;
	GetStartTangent(): Vector;
	GetStartScale(): Vector2D;
	GetStartRoll(): number;
	GetStartPosition(): Vector;
	GetStartOffset(): Vector2D;
	GetSplineUpDir(): Vector;
	GetForwardAxis(): ESplineMeshAxis;
	GetEndTangent(): Vector;
	GetEndScale(): Vector2D;
	GetEndRoll(): number;
	GetEndPosition(): Vector;
	GetEndOffset(): Vector2D;
	GetBoundaryMin(): number;
	GetBoundaryMax(): number;
	static C(Other: UObject | any): SplineMeshComponent;
}

declare class CameraRig_Rail extends Actor { 
	CurrentPositionOnRail: number;
	bLockOrientationToRail: boolean;
	bShowRailVisualization: boolean;
	PreviewMeshScale: number;
	TransformComponent: SceneComponent;
	RailSplineComponent: SplineComponent;
	RailCameraMount: SceneComponent;
	PreviewMesh_Rail: SplineMeshComponent;
	PreviewRailMeshSegments: SplineMeshComponent[];
	PreviewRailStaticMesh: StaticMesh;
	PreviewMesh_Mount: StaticMeshComponent;
	static GetDefaultObject(): CameraRig_Rail;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraRig_Rail;
	GetRailSplineComponent(): SplineComponent;
	static C(Other: UObject | any): CameraRig_Rail;
}

declare class CameraLookatTrackingSettings { 
	bEnableLookAtTracking: boolean;
	bDrawDebugLookAtTrackingPosition: boolean;
	LookAtTrackingInterpSpeed: number;
	ActorToTrack: Actor;
	RelativeOffset: Vector;
	bAllowRoll: boolean;
	clone() : CameraLookatTrackingSettings;
	static C(Other: UObject | any): CameraLookatTrackingSettings;
}

declare class CineCameraComponent extends CameraComponent { 
	FilmbackSettings: CameraFilmbackSettings;
	Filmback: CameraFilmbackSettings;
	LensSettings: CameraLensSettings;
	FocusSettings: CameraFocusSettings;
	CropSettings: PlateCropSettings;
	CurrentFocalLength: number;
	CurrentAperture: number;
	CurrentFocusDistance: number;
	bOverride_CustomNearClippingPlane: boolean;
	CustomNearClippingPlane: number;
	CurrentHorizontalFOV: number;
	FocusPlaneVisualizationMesh: StaticMesh;
	FocusPlaneVisualizationMaterial: Material;
	DebugFocusPlaneComponent: StaticMeshComponent;
	DebugFocusPlaneMID: MaterialInstanceDynamic;
	FilmbackPresets: NamedFilmbackPreset[];
	LensPresets: NamedLensPreset[];
	DefaultFilmbackPresetName: string;
	DefaultFilmbackPreset: string;
	DefaultLensPresetName: string;
	DefaultLensFocalLength: number;
	DefaultLensFStop: number;
	static Load(ResourceName: string): CineCameraComponent;
	static Find(Outer: UObject, ResourceName: string): CineCameraComponent;
	static GetDefaultObject(): CineCameraComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CineCameraComponent;
	SetLensSettings(NewLensSettings: CameraLensSettings): void;
	SetLensPresetByName(InPresetName: string): void;
	SetFocusSettings(NewFocusSettings: CameraFocusSettings): void;
	SetFilmbackPresetByName(InPresetName: string): void;
	SetFilmback(NewFilmback: CameraFilmbackSettings): void;
	SetCurrentFocalLength(InFocalLength: number): void;
	SetCurrentAperture(NewCurrentAperture: number): void;
	SetCropSettings(NewCropSettings: PlateCropSettings): void;
	SetCropPresetByName(InPresetName: string): void;
	GetVerticalFieldOfView(): number;
	static GetLensPresetsCopy(): NamedLensPreset[];
	GetLensPresetName(): string;
	GetHorizontalFieldOfView(): number;
	static GetFilmbackPresetsCopy(): NamedFilmbackPreset[];
	GetFilmbackPresetName(): string;
	GetDefaultFilmbackPresetName(): string;
	GetCropPresetName(): string;
	static C(Other: UObject | any): CineCameraComponent;
}

declare class CineCameraActor extends CameraActor { 
	LookatTrackingSettings: CameraLookatTrackingSettings;
	static GetDefaultObject(): CineCameraActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CineCameraActor;
	GetCineCameraComponent(): CineCameraComponent;
	static C(Other: UObject | any): CineCameraActor;
}

declare class DataLayerCreationParameters { 
	DataLayerAsset: DataLayerAsset;
	WorldDataLayers: WorldDataLayers;
	clone() : DataLayerCreationParameters;
	static C(Other: UObject | any): DataLayerCreationParameters;
}

declare class DataLayerEditorSubsystem extends EditorSubsystem { 
	static Load(ResourceName: string): DataLayerEditorSubsystem;
	static Find(Outer: UObject, ResourceName: string): DataLayerEditorSubsystem;
	static GetDefaultObject(): DataLayerEditorSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DataLayerEditorSubsystem;
	UpdateAllViewVisibility(DataLayerThatChanged: DataLayer): void;
	UpdateAllActorsVisibility(bNotifySelectionChange: boolean,bRedrawViewports: boolean): boolean;
	UpdateActorVisibility(Actor: Actor,bOutSelectionChanged?: boolean,bOutActorModified?: boolean,bNotifySelectionChange?: boolean,bRedrawViewports?: boolean): {bOutSelectionChanged: boolean, bOutActorModified: boolean, $: boolean};
	UpdateActorAllViewsVisibility(Actor: Actor): void;
	ToggleDataLayerVisibility(DataLayer: DataLayerInstance): void;
	ToggleDataLayersVisibility(DataLayers: DataLayerInstance[]): void;
	ToggleDataLayersIsLoadedInEditor(DataLayers: DataLayerInstance[],bIsFromUserChange: boolean): boolean;
	ToggleDataLayersIsDynamicallyLoadedInEditor(DataLayers: DataLayer[],bIsFromUserChange: boolean): boolean;
	ToggleDataLayerIsLoadedInEditor(DataLayer: DataLayerInstance,bIsFromUserChange: boolean): boolean;
	ToggleDataLayerIsDynamicallyLoadedInEditor(DataLayer: DataLayer,bIsFromUserChange: boolean): boolean;
	SetParentDataLayer(DataLayer: DataLayerInstance,ParentDataLayer: DataLayerInstance): boolean;
	SetDataLayerVisibility(DataLayer: DataLayerInstance,bIsVisible: boolean): void;
	SetDataLayersVisibility(DataLayers: DataLayerInstance[],bIsVisible: boolean): void;
	SetDataLayersIsLoadedInEditor(DataLayers: DataLayerInstance[],bIsLoadedInEditor: boolean,bIsFromUserChange: boolean): boolean;
	SetDataLayersIsDynamicallyLoadedInEditor(DataLayers: DataLayer[],bIsLoadedInEditor: boolean,bIsFromUserChange: boolean): boolean;
	SetDataLayerIsLoadedInEditor(DataLayer: DataLayerInstance,bIsLoadedInEditor: boolean,bIsFromUserChange: boolean): boolean;
	SetDataLayerIsDynamicallyLoadedInEditor(DataLayer: DataLayer,bIsLoadedInEditor: boolean,bIsFromUserChange: boolean): boolean;
	SelectActorsInDataLayers(DataLayers: DataLayerInstance[],bSelect: boolean,bNotify: boolean,bSelectEvenIfHidden: boolean): boolean;
	SelectActorsInDataLayer(DataLayer: DataLayerInstance,bSelect: boolean,bNotify: boolean,bSelectEvenIfHidden: boolean): boolean;
	RenameDataLayer(DataLayer: DataLayerInstance,NewDataLayerLabel: string): boolean;
	RemoveSelectedActorsFromDataLayers(DataLayers: DataLayerInstance[]): boolean;
	RemoveSelectedActorsFromDataLayer(DataLayer: DataLayerInstance): boolean;
	RemoveActorsFromDataLayers(Actors: Actor[],DataLayers: DataLayerInstance[]): boolean;
	RemoveActorsFromDataLayer(Actors: Actor[],DataLayer: DataLayerInstance): boolean;
	RemoveActorsFromAllDataLayers(Actors: Actor[]): boolean;
	RemoveActorFromDataLayers(Actor: Actor,DataLayers: DataLayerInstance[]): boolean;
	RemoveActorFromDataLayer(Actor: Actor,DataLayerToRemove: DataLayerInstance): boolean;
	RemoveActorFromAllDataLayers(Actor: Actor): boolean;
	MakeAllDataLayersVisible(): void;
	IsActorValidForDataLayer(Actor: Actor): boolean;
	GetDataLayerInstances(DataLayerAssets: DataLayerAsset[]): DataLayerInstance[];
	GetDataLayerInstance(DataLayerAsset: DataLayerAsset): DataLayerInstance;
	GetDataLayerFromLabel(DataLayerLabel: string): DataLayerInstance;
	GetDataLayer(ActorDataLayer: ActorDataLayer): DataLayerInstance;
	GetAllDataLayers(): DataLayerInstance[];
	GetActorsFromDataLayers(DataLayers: DataLayerInstance[]): Actor[];
	GetActorsFromDataLayer(DataLayer: DataLayerInstance): Actor[];
	DeleteDataLayers(DataLayersToDelete: DataLayerInstance[]): void;
	DeleteDataLayer(DataLayerToDelete: DataLayerInstance): void;
	CreateDataLayerInstance(Parameters: DataLayerCreationParameters): DataLayerInstance;
	CreateDataLayer(ParentDataLayer: DataLayerInstance): DataLayerInstance;
	AppendActorsFromDataLayers(DataLayers: DataLayerInstance[],InOutActors?: Actor[]): {InOutActors: Actor[]};
	AppendActorsFromDataLayer(DataLayer: DataLayerInstance,InOutActors?: Actor[]): {InOutActors: Actor[]};
	AddSelectedActorsToDataLayers(DataLayers: DataLayerInstance[]): boolean;
	AddSelectedActorsToDataLayer(DataLayer: DataLayerInstance): boolean;
	AddActorToDataLayers(Actor: Actor,DataLayers: DataLayerInstance[]): boolean;
	AddActorToDataLayer(Actor: Actor,DataLayer: DataLayerInstance): boolean;
	AddActorsToDataLayers(Actors: Actor[],DataLayers: DataLayerInstance[]): boolean;
	AddActorsToDataLayer(Actors: Actor[],DataLayer: DataLayerInstance): boolean;
	static C(Other: UObject | any): DataLayerEditorSubsystem;
}

declare class AutomatedAssetImportData extends UObject { 
	GroupName: string;
	Filenames: string[];
	DestinationPath: string;
	FactoryName: string;
	bReplaceExisting: boolean;
	bSkipReadOnly: boolean;
	Factory: Factory;
	LevelToLoad: string;
	static Load(ResourceName: string): AutomatedAssetImportData;
	static Find(Outer: UObject, ResourceName: string): AutomatedAssetImportData;
	static GetDefaultObject(): AutomatedAssetImportData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AutomatedAssetImportData;
	static C(Other: UObject | any): AutomatedAssetImportData;
}

declare class AssetImportTask extends UObject { 
	Filename: string;
	DestinationPath: string;
	DestinationName: string;
	bReplaceExisting: boolean;
	bReplaceExistingSettings: boolean;
	bAutomated: boolean;
	bSave: boolean;
	bAsync: boolean;
	Factory: Factory;
	Options: UObject;
	ImportedObjectPaths: string[];
	result: UObject[];
	static Load(ResourceName: string): AssetImportTask;
	static Find(Outer: UObject, ResourceName: string): AssetImportTask;
	static GetDefaultObject(): AssetImportTask;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetImportTask;
	IsAsyncImportComplete(): boolean;
	GetObjects(): UObject[];
	static C(Other: UObject | any): AssetImportTask;
}

declare class Factory extends UObject { 
	bCreateNew: boolean;
	SupportedClass: UnrealEngineClass;
	ContextClass: UnrealEngineClass;
	Formats: string[];
	bEditAfterNew: boolean;
	bEditorImport: boolean;
	bText: boolean;
	ImportPriority: number;
	AutomatedImportData: AutomatedAssetImportData;
	AssetImportTask: AssetImportTask;
	OverwriteYesOrNoToAllState: number;
	static Load(ResourceName: string): Factory;
	static Find(Outer: UObject, ResourceName: string): Factory;
	static GetDefaultObject(): Factory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Factory;
	ScriptFactoryCreateFile(InTask: AssetImportTask): boolean;
	ScriptFactoryCanImport(Filename: string): boolean;
	static C(Other: UObject | any): Factory;
}

declare class DataLayerFactory extends Factory { 
	static Load(ResourceName: string): DataLayerFactory;
	static Find(Outer: UObject, ResourceName: string): DataLayerFactory;
	static GetDefaultObject(): DataLayerFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DataLayerFactory;
	static C(Other: UObject | any): DataLayerFactory;
}

declare class LiveLinkController extends UObject { 
	static Load(ResourceName: string): LiveLinkController;
	static Find(Outer: UObject, ResourceName: string): LiveLinkController;
	static GetDefaultObject(): LiveLinkController;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkController;
	static C(Other: UObject | any): LiveLinkController;
}

declare class LiveLinkFrameInterpolationProcessor extends UObject { 
	static Load(ResourceName: string): LiveLinkFrameInterpolationProcessor;
	static Find(Outer: UObject, ResourceName: string): LiveLinkFrameInterpolationProcessor;
	static GetDefaultObject(): LiveLinkFrameInterpolationProcessor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkFrameInterpolationProcessor;
	static C(Other: UObject | any): LiveLinkFrameInterpolationProcessor;
}

declare class LiveLinkFramePreProcessor extends UObject { 
	static Load(ResourceName: string): LiveLinkFramePreProcessor;
	static Find(Outer: UObject, ResourceName: string): LiveLinkFramePreProcessor;
	static GetDefaultObject(): LiveLinkFramePreProcessor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkFramePreProcessor;
	static C(Other: UObject | any): LiveLinkFramePreProcessor;
}

declare class LiveLinkRole extends UObject { 
	static Load(ResourceName: string): LiveLinkRole;
	static Find(Outer: UObject, ResourceName: string): LiveLinkRole;
	static GetDefaultObject(): LiveLinkRole;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkRole;
	static C(Other: UObject | any): LiveLinkRole;
}

declare type ELiveLinkSourceMode = 'Latest' | 'EngineTime' | 'Timecode' | 'ELiveLinkSourceMode_MAX';
declare var ELiveLinkSourceMode : { Latest:'Latest',EngineTime:'EngineTime',Timecode:'Timecode',ELiveLinkSourceMode_MAX:'ELiveLinkSourceMode_MAX', };
declare class LiveLinkSourceBufferManagementSettings { 
	bValidEngineTimeEnabled: boolean;
	ValidEngineTime: number;
	EngineTimeOffset: number;
	EngineTimeClockOffset: number;
	SmoothEngineTimeOffset: number;
	TimecodeFrameRate: FrameRate;
	bGenerateSubFrame: boolean;
	DetectedFrameRate: FrameRate;
	bUseTimecodeSmoothLatest: boolean;
	SourceTimecodeFrameRate: FrameRate;
	bValidTimecodeFrameEnabled: boolean;
	ValidTimecodeFrame: number;
	TimecodeFrameOffset: number;
	TimecodeClockOffset: number;
	LatestOffset: number;
	MaxNumberOfFrameToBuffered: number;
	bKeepAtLeastOneFrame: boolean;
	clone() : LiveLinkSourceBufferManagementSettings;
	static C(Other: UObject | any): LiveLinkSourceBufferManagementSettings;
}

declare class LiveLinkSourceFactory extends UObject { 
	static Load(ResourceName: string): LiveLinkSourceFactory;
	static Find(Outer: UObject, ResourceName: string): LiveLinkSourceFactory;
	static GetDefaultObject(): LiveLinkSourceFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkSourceFactory;
	static C(Other: UObject | any): LiveLinkSourceFactory;
}

declare class LiveLinkSubjectName { 
	Name: string;
	clone() : LiveLinkSubjectName;
	static C(Other: UObject | any): LiveLinkSubjectName;
}

declare class LiveLinkSourceDebugInfo { 
	SubjectName: LiveLinkSubjectName;
	SnapshotIndex: number;
	NumberOfBufferAtSnapshot: number;
	clone() : LiveLinkSourceDebugInfo;
	static C(Other: UObject | any): LiveLinkSourceDebugInfo;
}

declare class LiveLinkSourceSettings extends UObject { 
	Mode: ELiveLinkSourceMode;
	BufferSettings: LiveLinkSourceBufferManagementSettings;
	ConnectionString: string;
	Factory: UnrealEngineClass;
	SourceDebugInfos: LiveLinkSourceDebugInfo[];
	static Load(ResourceName: string): LiveLinkSourceSettings;
	static Find(Outer: UObject, ResourceName: string): LiveLinkSourceSettings;
	static GetDefaultObject(): LiveLinkSourceSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkSourceSettings;
	static C(Other: UObject | any): LiveLinkSourceSettings;
}

declare class LiveLinkCurveConversionSettings { 
	CurveConversionAssetMap: Map<string, SoftObjectPath>;
	clone() : LiveLinkCurveConversionSettings;
	static C(Other: UObject | any): LiveLinkCurveConversionSettings;
}

declare class LiveLinkCurveRemapSettings extends LiveLinkSourceSettings { 
	CurveConversionSettings: LiveLinkCurveConversionSettings;
	static Load(ResourceName: string): LiveLinkCurveRemapSettings;
	static Find(Outer: UObject, ResourceName: string): LiveLinkCurveRemapSettings;
	static GetDefaultObject(): LiveLinkCurveRemapSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkCurveRemapSettings;
	static C(Other: UObject | any): LiveLinkCurveRemapSettings;
}

declare class LiveLinkFrameTranslator extends UObject { 
	static Load(ResourceName: string): LiveLinkFrameTranslator;
	static Find(Outer: UObject, ResourceName: string): LiveLinkFrameTranslator;
	static GetDefaultObject(): LiveLinkFrameTranslator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkFrameTranslator;
	static C(Other: UObject | any): LiveLinkFrameTranslator;
}

declare class LiveLinkSubjectSettings extends UObject { 
	PreProcessors: LiveLinkFramePreProcessor[];
	InterpolationProcessor: LiveLinkFrameInterpolationProcessor;
	Translators: LiveLinkFrameTranslator[];
	Role: UnrealEngineClass;
	FrameRate: FrameRate;
	bRebroadcastSubject: boolean;
	static Load(ResourceName: string): LiveLinkSubjectSettings;
	static Find(Outer: UObject, ResourceName: string): LiveLinkSubjectSettings;
	static GetDefaultObject(): LiveLinkSubjectSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkSubjectSettings;
	static C(Other: UObject | any): LiveLinkSubjectSettings;
}

declare class LiveLinkVirtualSubject extends UObject { 
	Role: UnrealEngineClass;
	Subjects: LiveLinkSubjectName[];
	FrameTranslators: LiveLinkFrameTranslator[];
	bRebroadcastSubject: boolean;
	static Load(ResourceName: string): LiveLinkVirtualSubject;
	static Find(Outer: UObject, ResourceName: string): LiveLinkVirtualSubject;
	static GetDefaultObject(): LiveLinkVirtualSubject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkVirtualSubject;
	static C(Other: UObject | any): LiveLinkVirtualSubject;
}

declare class LiveLinkBasicRole extends LiveLinkRole { 
	static Load(ResourceName: string): LiveLinkBasicRole;
	static Find(Outer: UObject, ResourceName: string): LiveLinkBasicRole;
	static GetDefaultObject(): LiveLinkBasicRole;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkBasicRole;
	static C(Other: UObject | any): LiveLinkBasicRole;
}

declare class LiveLinkAnimationRole extends LiveLinkBasicRole { 
	static Load(ResourceName: string): LiveLinkAnimationRole;
	static Find(Outer: UObject, ResourceName: string): LiveLinkAnimationRole;
	static GetDefaultObject(): LiveLinkAnimationRole;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkAnimationRole;
	static C(Other: UObject | any): LiveLinkAnimationRole;
}

declare class LiveLinkTransformRole extends LiveLinkBasicRole { 
	static Load(ResourceName: string): LiveLinkTransformRole;
	static Find(Outer: UObject, ResourceName: string): LiveLinkTransformRole;
	static GetDefaultObject(): LiveLinkTransformRole;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkTransformRole;
	static C(Other: UObject | any): LiveLinkTransformRole;
}

declare class LiveLinkCameraRole extends LiveLinkTransformRole { 
	static Load(ResourceName: string): LiveLinkCameraRole;
	static Find(Outer: UObject, ResourceName: string): LiveLinkCameraRole;
	static GetDefaultObject(): LiveLinkCameraRole;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkCameraRole;
	static C(Other: UObject | any): LiveLinkCameraRole;
}

declare class LiveLinkLightRole extends LiveLinkTransformRole { 
	static Load(ResourceName: string): LiveLinkLightRole;
	static Find(Outer: UObject, ResourceName: string): LiveLinkLightRole;
	static GetDefaultObject(): LiveLinkLightRole;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkLightRole;
	static C(Other: UObject | any): LiveLinkLightRole;
}

declare class SequenceRecordingBase extends UObject { 
	static Load(ResourceName: string): SequenceRecordingBase;
	static Find(Outer: UObject, ResourceName: string): SequenceRecordingBase;
	static GetDefaultObject(): SequenceRecordingBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequenceRecordingBase;
	static C(Other: UObject | any): SequenceRecordingBase;
}

declare class ActorRecordingSettings { 
	Settings: UObject[];
	clone() : ActorRecordingSettings;
	static C(Other: UObject | any): ActorRecordingSettings;
}

declare class AnimationRecordingSettings { 
	bRecordInWorldSpace: boolean;
	bRemoveRootAnimation: boolean;
	bAutoSaveAsset: boolean;
	SampleFrameRate: FrameRate;
	Length: number;
	Interpolation: EAnimInterpolationType;
	InterpMode: ERichCurveInterpMode;
	TangentMode: ERichCurveTangentMode;
	bRecordTransforms: boolean;
	bRecordMorphTargets: boolean;
	bRecordAttributeCurves: boolean;
	bRecordMaterialCurves: boolean;
	IncludeAnimationNames: string[];
	ExcludeAnimationNames: string[];
	clone() : AnimationRecordingSettings;
	static C(Other: UObject | any): AnimationRecordingSettings;
}

declare class ActorRecording extends SequenceRecordingBase { 
	ActorSettings: ActorRecordingSettings;
	bActive: boolean;
	bCreateLevelSequence: boolean;
	TargetLevelSequence: LevelSequence;
	TargetName: string;
	TakeNumber: number;
	bSpecifyTargetAnimation: boolean;
	TargetAnimation: AnimSequence;
	AnimationSettings: AnimationRecordingSettings;
	bRecordToPossessable: boolean;
	ActorToRecord: Actor;
	static Load(ResourceName: string): ActorRecording;
	static Find(Outer: UObject, ResourceName: string): ActorRecording;
	static GetDefaultObject(): ActorRecording;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorRecording;
	static C(Other: UObject | any): ActorRecording;
}

declare class AnimationRecordingParameters extends UObject { 
	SampleFrameRate: FrameRate;
	bEndAfterDuration: boolean;
	MaximumDurationSeconds: number;
	SampleRate: number;
	static Load(ResourceName: string): AnimationRecordingParameters;
	static Find(Outer: UObject, ResourceName: string): AnimationRecordingParameters;
	static GetDefaultObject(): AnimationRecordingParameters;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationRecordingParameters;
	static C(Other: UObject | any): AnimationRecordingParameters;
}

declare class MovieScene3DTransformSectionRecorderSettings extends UObject { 
	bRecordTransforms: boolean;
	static Load(ResourceName: string): MovieScene3DTransformSectionRecorderSettings;
	static Find(Outer: UObject, ResourceName: string): MovieScene3DTransformSectionRecorderSettings;
	static GetDefaultObject(): MovieScene3DTransformSectionRecorderSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScene3DTransformSectionRecorderSettings;
	static C(Other: UObject | any): MovieScene3DTransformSectionRecorderSettings;
}

declare class SequenceRecorderActorGroup extends UObject { 
	GroupName: string;
	SequenceName: string;
	SequenceRecordingBasePath: DirectoryPath;
	bSpecifyTargetLevelSequence: boolean;
	TargetLevelSequence: LevelSequence;
	bDuplicateTargetLevelSequence: boolean;
	bRecordTargetLevelSequenceLength: boolean;
	RecordedActors: ActorRecording[];
	static Load(ResourceName: string): SequenceRecorderActorGroup;
	static Find(Outer: UObject, ResourceName: string): SequenceRecorderActorGroup;
	static GetDefaultObject(): SequenceRecorderActorGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequenceRecorderActorGroup;
	static C(Other: UObject | any): SequenceRecorderActorGroup;
}

declare class SequenceRecorderGroup extends Actor { 
	ActorGroups: SequenceRecorderActorGroup[];
	static GetDefaultObject(): SequenceRecorderGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequenceRecorderGroup;
	static C(Other: UObject | any): SequenceRecorderGroup;
}

declare class SequenceRecorderBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): SequenceRecorderBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): SequenceRecorderBlueprintLibrary;
	static GetDefaultObject(): SequenceRecorderBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequenceRecorderBlueprintLibrary;
	static StopRecordingSequence(): void;
	static StartRecordingSequence(ActorsToRecord: Actor[]): void;
	static IsRecordingSequence(): boolean;
	static C(Other: UObject | any): SequenceRecorderBlueprintLibrary;
}

declare type EAudioRecordingMode = 'None' | 'AudioTrack' | 'EAudioRecordingMode_MAX';
declare var EAudioRecordingMode : { None:'None',AudioTrack:'AudioTrack',EAudioRecordingMode_MAX:'EAudioRecordingMode_MAX', };
declare class SequenceRecorderActorFilter { 
	ActorClassesToRecord: UnrealEngineClass[];
	clone() : SequenceRecorderActorFilter;
	static C(Other: UObject | any): SequenceRecorderActorFilter;
}

declare class LevelSequencePlayer extends MovieSceneSequencePlayer { 
	OnCameraCut: UnrealEngineMulticastDelegate<(CameraComponent: CameraComponent) => void>;
	static Load(ResourceName: string): LevelSequencePlayer;
	static Find(Outer: UObject, ResourceName: string): LevelSequencePlayer;
	static GetDefaultObject(): LevelSequencePlayer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelSequencePlayer;
	GetActiveCameraComponent(): CameraComponent;
	static CreateLevelSequencePlayer(WorldContextObject: UObject,LevelSequence: LevelSequence,Settings: MovieSceneSequencePlaybackSettings,OutActor?: LevelSequenceActor): {OutActor: LevelSequenceActor, $: LevelSequencePlayer};
	static C(Other: UObject | any): LevelSequencePlayer;
}

declare class LevelSequenceCameraSettings { 
	bOverrideAspectRatioAxisConstraint: boolean;
	AspectRatioAxisConstraint: EAspectRatioAxisConstraint;
	clone() : LevelSequenceCameraSettings;
	static C(Other: UObject | any): LevelSequenceCameraSettings;
}

declare class LevelSequenceBurnInInitSettings extends UObject { 
	static Load(ResourceName: string): LevelSequenceBurnInInitSettings;
	static Find(Outer: UObject, ResourceName: string): LevelSequenceBurnInInitSettings;
	static GetDefaultObject(): LevelSequenceBurnInInitSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelSequenceBurnInInitSettings;
	static C(Other: UObject | any): LevelSequenceBurnInInitSettings;
}

declare class LevelSequenceBurnInOptions extends UObject { 
	bUseBurnIn: boolean;
	BurnInClass: SoftClassPath;
	Settings: LevelSequenceBurnInInitSettings;
	static Load(ResourceName: string): LevelSequenceBurnInOptions;
	static Find(Outer: UObject, ResourceName: string): LevelSequenceBurnInOptions;
	static GetDefaultObject(): LevelSequenceBurnInOptions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelSequenceBurnInOptions;
	SetBurnIn(InBurnInClass: SoftClassPath): void;
	static C(Other: UObject | any): LevelSequenceBurnInOptions;
}

declare class LevelSequencePlayerSnapshot { 
	MasterName: string;
	MasterTime: QualifiedFrameTime;
	SourceTime: QualifiedFrameTime;
	CurrentShotName: string;
	CurrentShotLocalTime: QualifiedFrameTime;
	CurrentShotSourceTime: QualifiedFrameTime;
	SourceTimecode: string;
	CameraComponent: CameraComponent;
	ActiveShot: LevelSequence;
	ShotID: MovieSceneSequenceID;
	clone() : LevelSequencePlayerSnapshot;
	static C(Other: UObject | any): LevelSequencePlayerSnapshot;
}

declare class LevelSequenceBurnIn extends UserWidget { 
	FrameInformation: LevelSequencePlayerSnapshot;
	LevelSequenceActor: LevelSequenceActor;
	static Load(ResourceName: string): LevelSequenceBurnIn;
	static Find(Outer: UObject, ResourceName: string): LevelSequenceBurnIn;
	static GetDefaultObject(): LevelSequenceBurnIn;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelSequenceBurnIn;
	SetSettings(InSettings: UObject): void;
	GetSettingsClass(): UnrealEngineClass;
	static C(Other: UObject | any): LevelSequenceBurnIn;
}

declare class LevelSequenceActor extends Actor { 
	PlaybackSettings: MovieSceneSequencePlaybackSettings;
	SequencePlayer: LevelSequencePlayer;
	LevelSequenceAsset: LevelSequence;
	LevelSequence: SoftObjectPath;
	CameraSettings: LevelSequenceCameraSettings;
	BurnInOptions: LevelSequenceBurnInOptions;
	BindingOverrides: MovieSceneBindingOverrides;
	bAutoPlay: boolean;
	bOverrideInstanceData: boolean;
	bReplicatePlayback: boolean;
	DefaultInstanceData: UObject;
	BurnInInstance: LevelSequenceBurnIn;
	bShowBurnin: boolean;
	static GetDefaultObject(): LevelSequenceActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelSequenceActor;
	ShowBurnin(): void;
	SetSequence(InSequence: LevelSequence): void;
	SetReplicatePlayback(ReplicatePlayback: boolean): void;
	SetBindingByTag(BindingTag: string,Actors: Actor[],bAllowBindingsFromAsset: boolean): void;
	SetBinding(Binding: MovieSceneObjectBindingID,Actors: Actor[],bAllowBindingsFromAsset: boolean): void;
	ResetBindings(): void;
	ResetBinding(Binding: MovieSceneObjectBindingID): void;
	RemoveBindingByTag(Tag: string,Actor: Actor): void;
	RemoveBinding(Binding: MovieSceneObjectBindingID,Actor: Actor): void;
	LoadSequence(): LevelSequence;
	HideBurnin(): void;
	GetSequencePlayer(): LevelSequencePlayer;
	GetSequence(): LevelSequence;
	FindNamedBindings(Tag: string): MovieSceneObjectBindingID[];
	FindNamedBinding(Tag: string): MovieSceneObjectBindingID;
	AddBindingByTag(BindingTag: string,Actor: Actor,bAllowBindingsFromAsset: boolean): void;
	AddBinding(Binding: MovieSceneObjectBindingID,Actor: Actor,bAllowBindingsFromAsset: boolean): void;
	static C(Other: UObject | any): LevelSequenceActor;
}

declare class PropertiesToRecordForClass { 
	Class: UnrealEngineClass;
	Properties: string[];
	clone() : PropertiesToRecordForClass;
	static C(Other: UObject | any): PropertiesToRecordForClass;
}

declare class PropertiesToRecordForActorClass { 
	Class: UnrealEngineClass;
	Properties: string[];
	clone() : PropertiesToRecordForActorClass;
	static C(Other: UObject | any): PropertiesToRecordForActorClass;
}

declare class SettingsForActorClass { 
	Class: UnrealEngineClass;
	bRecordToPossessable: boolean;
	clone() : SettingsForActorClass;
	static C(Other: UObject | any): SettingsForActorClass;
}

declare class SequenceRecorderSettings extends UObject { 
	bCreateLevelSequence: boolean;
	bImmersiveMode: boolean;
	SequenceLength: number;
	RecordingDelay: number;
	bAllowLooping: boolean;
	GlobalTimeDilation: number;
	bIgnoreTimeDilation: boolean;
	AnimationSubDirectory: string;
	RecordAudio: EAudioRecordingMode;
	AudioGain: number;
	bSplitAudioChannelsIntoSeparateTracks: boolean;
	bReplaceRecordedAudio: boolean;
	AudioTrackName: string;
	AudioSubDirectory: string;
	bRecordNearbySpawnedActors: boolean;
	NearbyActorRecordingProximity: number;
	bRecordWorldSettingsActor: boolean;
	bReduceKeys: boolean;
	bAutoSaveAsset: boolean;
	ActorFilter: SequenceRecorderActorFilter;
	LevelSequenceActorsToTrigger: LevelSequenceActor[];
	DefaultAnimationSettings: AnimationRecordingSettings;
	bRecordSequencerSpawnedActors: boolean;
	ClassesAndPropertiesToRecord: PropertiesToRecordForClass[];
	ActorsAndPropertiesToRecord: PropertiesToRecordForActorClass[];
	PerActorSettings: SettingsForActorClass[];
	static Load(ResourceName: string): SequenceRecorderSettings;
	static Find(Outer: UObject, ResourceName: string): SequenceRecorderSettings;
	static GetDefaultObject(): SequenceRecorderSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequenceRecorderSettings;
	static C(Other: UObject | any): SequenceRecorderSettings;
}

declare type EMovieSceneCaptureProtocolState = 'Idle' | 'Initialized' | 'Capturing' | 'Finalizing' | 'EMovieSceneCaptureProtocolState_MAX';
declare var EMovieSceneCaptureProtocolState : { Idle:'Idle',Initialized:'Initialized',Capturing:'Capturing',Finalizing:'Finalizing',EMovieSceneCaptureProtocolState_MAX:'EMovieSceneCaptureProtocolState_MAX', };
declare class MovieSceneCaptureProtocolBase extends UObject { 
	State: EMovieSceneCaptureProtocolState;
	static Load(ResourceName: string): MovieSceneCaptureProtocolBase;
	static Find(Outer: UObject, ResourceName: string): MovieSceneCaptureProtocolBase;
	static GetDefaultObject(): MovieSceneCaptureProtocolBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneCaptureProtocolBase;
	IsCapturing(): boolean;
	GetState(): EMovieSceneCaptureProtocolState;
	static C(Other: UObject | any): MovieSceneCaptureProtocolBase;
}

declare class MovieSceneAudioCaptureProtocolBase extends MovieSceneCaptureProtocolBase { 
	static Load(ResourceName: string): MovieSceneAudioCaptureProtocolBase;
	static Find(Outer: UObject, ResourceName: string): MovieSceneAudioCaptureProtocolBase;
	static GetDefaultObject(): MovieSceneAudioCaptureProtocolBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneAudioCaptureProtocolBase;
	static C(Other: UObject | any): MovieSceneAudioCaptureProtocolBase;
}

declare class NullAudioCaptureProtocol extends MovieSceneAudioCaptureProtocolBase { 
	static Load(ResourceName: string): NullAudioCaptureProtocol;
	static Find(Outer: UObject, ResourceName: string): NullAudioCaptureProtocol;
	static GetDefaultObject(): NullAudioCaptureProtocol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NullAudioCaptureProtocol;
	static C(Other: UObject | any): NullAudioCaptureProtocol;
}

declare class MasterAudioSubmixCaptureProtocol extends MovieSceneAudioCaptureProtocolBase { 
	Filename: string;
	static Load(ResourceName: string): MasterAudioSubmixCaptureProtocol;
	static Find(Outer: UObject, ResourceName: string): MasterAudioSubmixCaptureProtocol;
	static GetDefaultObject(): MasterAudioSubmixCaptureProtocol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MasterAudioSubmixCaptureProtocol;
	static C(Other: UObject | any): MasterAudioSubmixCaptureProtocol;
}

declare class MovieSceneImageCaptureProtocolBase extends MovieSceneCaptureProtocolBase { 
	static Load(ResourceName: string): MovieSceneImageCaptureProtocolBase;
	static Find(Outer: UObject, ResourceName: string): MovieSceneImageCaptureProtocolBase;
	static GetDefaultObject(): MovieSceneImageCaptureProtocolBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneImageCaptureProtocolBase;
	static C(Other: UObject | any): MovieSceneImageCaptureProtocolBase;
}

declare class CompositionGraphCapturePasses { 
	Value: string[];
	clone() : CompositionGraphCapturePasses;
	static C(Other: UObject | any): CompositionGraphCapturePasses;
}

declare type EHDRCaptureGamut = 'HCGM_Rec709' | 'HCGM_P3DCI' | 'HCGM_Rec2020' | 'HCGM_ACES' | 'HCGM_ACEScg' | 'HCGM_Linear' | 'HCGM_MAX';
declare var EHDRCaptureGamut : { HCGM_Rec709:'HCGM_Rec709',HCGM_P3DCI:'HCGM_P3DCI',HCGM_Rec2020:'HCGM_Rec2020',HCGM_ACES:'HCGM_ACES',HCGM_ACEScg:'HCGM_ACEScg',HCGM_Linear:'HCGM_Linear',HCGM_MAX:'HCGM_MAX', };
declare class CompositionGraphCaptureProtocol extends MovieSceneImageCaptureProtocolBase { 
	IncludeRenderPasses: CompositionGraphCapturePasses;
	bCaptureFramesInHDR: boolean;
	HDRCompressionQuality: number;
	CaptureGamut: EHDRCaptureGamut;
	PostProcessingMaterial: SoftObjectPath;
	bDisableScreenPercentage: boolean;
	PostProcessingMaterialPtr: MaterialInterface;
	static Load(ResourceName: string): CompositionGraphCaptureProtocol;
	static Find(Outer: UObject, ResourceName: string): CompositionGraphCaptureProtocol;
	static GetDefaultObject(): CompositionGraphCaptureProtocol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CompositionGraphCaptureProtocol;
	static C(Other: UObject | any): CompositionGraphCaptureProtocol;
}

declare class MovieSceneCaptureInterface extends Interface { 
	static Load(ResourceName: string): MovieSceneCaptureInterface;
	static Find(Outer: UObject, ResourceName: string): MovieSceneCaptureInterface;
	static GetDefaultObject(): MovieSceneCaptureInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneCaptureInterface;
	static C(Other: UObject | any): MovieSceneCaptureInterface;
}

declare class FrameGrabberProtocol extends MovieSceneImageCaptureProtocolBase { 
	static Load(ResourceName: string): FrameGrabberProtocol;
	static Find(Outer: UObject, ResourceName: string): FrameGrabberProtocol;
	static GetDefaultObject(): FrameGrabberProtocol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FrameGrabberProtocol;
	static C(Other: UObject | any): FrameGrabberProtocol;
}

declare class ImageSequenceProtocol extends FrameGrabberProtocol { 
	static Load(ResourceName: string): ImageSequenceProtocol;
	static Find(Outer: UObject, ResourceName: string): ImageSequenceProtocol;
	static GetDefaultObject(): ImageSequenceProtocol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ImageSequenceProtocol;
	static C(Other: UObject | any): ImageSequenceProtocol;
}

declare class CompressedImageSequenceProtocol extends ImageSequenceProtocol { 
	CompressionQuality: number;
	static Load(ResourceName: string): CompressedImageSequenceProtocol;
	static Find(Outer: UObject, ResourceName: string): CompressedImageSequenceProtocol;
	static GetDefaultObject(): CompressedImageSequenceProtocol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CompressedImageSequenceProtocol;
	static C(Other: UObject | any): CompressedImageSequenceProtocol;
}

declare class ImageSequenceProtocol_BMP extends ImageSequenceProtocol { 
	static Load(ResourceName: string): ImageSequenceProtocol_BMP;
	static Find(Outer: UObject, ResourceName: string): ImageSequenceProtocol_BMP;
	static GetDefaultObject(): ImageSequenceProtocol_BMP;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ImageSequenceProtocol_BMP;
	static C(Other: UObject | any): ImageSequenceProtocol_BMP;
}

declare class ImageSequenceProtocol_PNG extends CompressedImageSequenceProtocol { 
	static Load(ResourceName: string): ImageSequenceProtocol_PNG;
	static Find(Outer: UObject, ResourceName: string): ImageSequenceProtocol_PNG;
	static GetDefaultObject(): ImageSequenceProtocol_PNG;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ImageSequenceProtocol_PNG;
	static C(Other: UObject | any): ImageSequenceProtocol_PNG;
}

declare class ImageSequenceProtocol_JPG extends CompressedImageSequenceProtocol { 
	static Load(ResourceName: string): ImageSequenceProtocol_JPG;
	static Find(Outer: UObject, ResourceName: string): ImageSequenceProtocol_JPG;
	static GetDefaultObject(): ImageSequenceProtocol_JPG;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ImageSequenceProtocol_JPG;
	static C(Other: UObject | any): ImageSequenceProtocol_JPG;
}

declare class ImageSequenceProtocol_EXR extends ImageSequenceProtocol { 
	bCompressed: boolean;
	CaptureGamut: EHDRCaptureGamut;
	static Load(ResourceName: string): ImageSequenceProtocol_EXR;
	static Find(Outer: UObject, ResourceName: string): ImageSequenceProtocol_EXR;
	static GetDefaultObject(): ImageSequenceProtocol_EXR;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ImageSequenceProtocol_EXR;
	static C(Other: UObject | any): ImageSequenceProtocol_EXR;
}

declare class CaptureResolution { 
	ResX: number;
	ResY: number;
	clone() : CaptureResolution;
	static C(Other: UObject | any): CaptureResolution;
}

declare class MovieSceneCaptureSettings { 
	OutputDirectory: DirectoryPath;
	GameModeOverride: UnrealEngineClass;
	OutputFormat: string;
	bOverwriteExisting: boolean;
	bUseRelativeFrameNumbers: boolean;
	HandleFrames: number;
	MovieExtension: string;
	ZeroPadFrameNumbers: number;
	FrameRate: FrameRate;
	bUseCustomFrameRate: boolean;
	CustomFrameRate: FrameRate;
	Resolution: CaptureResolution;
	bEnableTextureStreaming: boolean;
	bCinematicEngineScalability: boolean;
	bCinematicMode: boolean;
	bAllowMovement: boolean;
	bAllowTurning: boolean;
	bShowPlayer: boolean;
	bShowHUD: boolean;
	bUsePathTracer: boolean;
	PathTracerSamplePerPixel: number;
	clone() : MovieSceneCaptureSettings;
	static C(Other: UObject | any): MovieSceneCaptureSettings;
}

declare class MovieSceneCapture extends UObject { 
	ImageCaptureProtocolType: SoftClassPath;
	AudioCaptureProtocolType: SoftClassPath;
	ImageCaptureProtocol: MovieSceneImageCaptureProtocolBase;
	AudioCaptureProtocol: MovieSceneAudioCaptureProtocolBase;
	Settings: MovieSceneCaptureSettings;
	bUseSeparateProcess: boolean;
	bCloseEditorWhenCaptureStarts: boolean;
	AdditionalCommandLineArguments: string;
	InheritedCommandLineArguments: string;
	static Load(ResourceName: string): MovieSceneCapture;
	static Find(Outer: UObject, ResourceName: string): MovieSceneCapture;
	static GetDefaultObject(): MovieSceneCapture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneCapture;
	SetImageCaptureProtocolType(ProtocolType: UnrealEngineClass): void;
	SetAudioCaptureProtocolType(ProtocolType: UnrealEngineClass): void;
	GetImageCaptureProtocol(): MovieSceneCaptureProtocolBase;
	GetAudioCaptureProtocol(): MovieSceneCaptureProtocolBase;
	static C(Other: UObject | any): MovieSceneCapture;
	RenderMovie(OnFinishedCallback: UnrealEngineDelegate<(bSuccess: boolean) => void>): boolean;
	static RenderMovie(InCaptureSettings: MovieSceneCapture,OnFinishedCallback: UnrealEngineDelegate<(bSuccess: boolean) => void>): boolean;
}

declare class LevelCapture extends MovieSceneCapture { 
	bAutoStartCapture: boolean;
	PrerequisiteActorId: Guid;
	static Load(ResourceName: string): LevelCapture;
	static Find(Outer: UObject, ResourceName: string): LevelCapture;
	static GetDefaultObject(): LevelCapture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelCapture;
	static C(Other: UObject | any): LevelCapture;
}

declare class MovieSceneCaptureEnvironment extends UObject { 
	static Load(ResourceName: string): MovieSceneCaptureEnvironment;
	static Find(Outer: UObject, ResourceName: string): MovieSceneCaptureEnvironment;
	static GetDefaultObject(): MovieSceneCaptureEnvironment;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneCaptureEnvironment;
	static IsCaptureInProgress(): boolean;
	static GetCaptureFrameNumber(): number;
	static GetCaptureElapsedTime(): number;
	static FindImageCaptureProtocol(): MovieSceneImageCaptureProtocolBase;
	static FindAudioCaptureProtocol(): MovieSceneAudioCaptureProtocolBase;
	static C(Other: UObject | any): MovieSceneCaptureEnvironment;
}

declare class CapturedPixelsID { 
	Identifiers: Map<string, string>;
	clone() : CapturedPixelsID;
	static C(Other: UObject | any): CapturedPixelsID;
}

declare class CapturedPixels { 
	clone() : CapturedPixels;
	static C(Other: UObject | any): CapturedPixels;
}

declare class FrameMetrics { 
	TotalElapsedTime: number;
	FrameDelta: number;
	FrameNumber: number;
	NumDroppedFrames: number;
	clone() : FrameMetrics;
	static C(Other: UObject | any): FrameMetrics;
}

declare class UserDefinedCaptureProtocol extends MovieSceneImageCaptureProtocolBase { 
	World: World;
	static Load(ResourceName: string): UserDefinedCaptureProtocol;
	static Find(Outer: UObject, ResourceName: string): UserDefinedCaptureProtocol;
	static GetDefaultObject(): UserDefinedCaptureProtocol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserDefinedCaptureProtocol;
	StopCapturingFinalPixels(): void;
	StartCapturingFinalPixels(StreamID: CapturedPixelsID): void;
	ResolveBuffer(Buffer: Texture,BufferID: CapturedPixelsID): void;
	OnWarmUp(): void;
	OnTick(): void;
	OnStartCapture(): void;
	OnSetup(): boolean;
	OnPreTick(): void;
	OnPixelsReceived(Pixels: CapturedPixels,ID: CapturedPixelsID,FrameMetrics: FrameMetrics): void;
	OnPauseCapture(): void;
	OnFinalize(): void;
	OnCaptureFrame(): void;
	OnCanFinalize(): boolean;
	OnBeginFinalize(): void;
	GetCurrentFrameMetrics(): FrameMetrics;
	GenerateFilename(InFrameMetrics: FrameMetrics): string;
	static C(Other: UObject | any): UserDefinedCaptureProtocol;
}

declare class UserDefinedImageCaptureProtocol extends UserDefinedCaptureProtocol { 
	Format: EDesiredImageFormat;
	bEnableCompression: boolean;
	CompressionQuality: number;
	static Load(ResourceName: string): UserDefinedImageCaptureProtocol;
	static Find(Outer: UObject, ResourceName: string): UserDefinedImageCaptureProtocol;
	static GetDefaultObject(): UserDefinedImageCaptureProtocol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserDefinedImageCaptureProtocol;
	WriteImageToDisk(PixelData: CapturedPixels,StreamID: CapturedPixelsID,FrameMetrics: FrameMetrics,bCopyImageData: boolean): void;
	GenerateFilenameForCurrentFrame(): string;
	GenerateFilenameForBuffer(Buffer: Texture,StreamID: CapturedPixelsID): string;
	static C(Other: UObject | any): UserDefinedImageCaptureProtocol;
}

declare class VideoCaptureProtocol extends FrameGrabberProtocol { 
	bUseCompression: boolean;
	CompressionQuality: number;
	static Load(ResourceName: string): VideoCaptureProtocol;
	static Find(Outer: UObject, ResourceName: string): VideoCaptureProtocol;
	static GetDefaultObject(): VideoCaptureProtocol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VideoCaptureProtocol;
	static C(Other: UObject | any): VideoCaptureProtocol;
}

declare class ConstraintsActor extends Actor { 
	ConstraintsManager: ConstraintsManager;
	static GetDefaultObject(): ConstraintsActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ConstraintsActor;
	static C(Other: UObject | any): ConstraintsActor;
}

declare class ConstraintsScriptingLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): ConstraintsScriptingLibrary;
	static Find(Outer: UObject, ResourceName: string): ConstraintsScriptingLibrary;
	static GetDefaultObject(): ConstraintsScriptingLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ConstraintsScriptingLibrary;
	static RemoveConstraint(InWorld: World,InIndex: number): boolean;
	static GetManager(InWorld: World): ConstraintsManager;
	static CreateTransformableComponentHandle(InWorld: World,InSceneComponent: SceneComponent,InSocketName: string): TransformableComponentHandle;
	static CreateFromType(InWorld: World,InType: ETransformConstraintType): TickableTransformConstraint;
	static AddConstraint(InWorld: World,InParentHandle: TransformableHandle,InChildHandle: TransformableHandle,InConstraint: TickableTransformConstraint,bMaintainOffset: boolean): boolean;
	static C(Other: UObject | any): ConstraintsScriptingLibrary;
}

declare class TickableTranslationConstraint extends TickableTransformConstraint { 
	OffsetTranslation: Vector;
	static Load(ResourceName: string): TickableTranslationConstraint;
	static Find(Outer: UObject, ResourceName: string): TickableTranslationConstraint;
	static GetDefaultObject(): TickableTranslationConstraint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TickableTranslationConstraint;
	static C(Other: UObject | any): TickableTranslationConstraint;
}

declare class TickableRotationConstraint extends TickableTransformConstraint { 
	OffsetRotation: Quat;
	static Load(ResourceName: string): TickableRotationConstraint;
	static Find(Outer: UObject, ResourceName: string): TickableRotationConstraint;
	static GetDefaultObject(): TickableRotationConstraint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TickableRotationConstraint;
	static C(Other: UObject | any): TickableRotationConstraint;
}

declare class TickableScaleConstraint extends TickableTransformConstraint { 
	OffsetScale: Vector;
	static Load(ResourceName: string): TickableScaleConstraint;
	static Find(Outer: UObject, ResourceName: string): TickableScaleConstraint;
	static GetDefaultObject(): TickableScaleConstraint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TickableScaleConstraint;
	static C(Other: UObject | any): TickableScaleConstraint;
}

declare class TickableParentConstraint extends TickableTransformConstraint { 
	OffsetTransform: Transform;
	bScaling: boolean;
	static Load(ResourceName: string): TickableParentConstraint;
	static Find(Outer: UObject, ResourceName: string): TickableParentConstraint;
	static GetDefaultObject(): TickableParentConstraint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TickableParentConstraint;
	static C(Other: UObject | any): TickableParentConstraint;
}

declare class TickableLookAtConstraint extends TickableTransformConstraint { 
	Axis: Vector;
	static Load(ResourceName: string): TickableLookAtConstraint;
	static Find(Outer: UObject, ResourceName: string): TickableLookAtConstraint;
	static GetDefaultObject(): TickableLookAtConstraint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TickableLookAtConstraint;
	static C(Other: UObject | any): TickableLookAtConstraint;
}

declare class AutomatedLevelSequenceCapture extends MovieSceneCapture { 
	LevelSequenceAsset: SoftObjectPath;
	ShotName: string;
	bUseCustomStartFrame: boolean;
	CustomStartFrame: FrameNumber;
	bUseCustomEndFrame: boolean;
	CustomEndFrame: FrameNumber;
	WarmUpFrameCount: number;
	DelayBeforeWarmUp: number;
	DelayBeforeShotWarmUp: number;
	DelayEveryFrame: number;
	BurnInOptions: LevelSequenceBurnInOptions;
	bWriteEditDecisionList: boolean;
	bWriteFinalCutProXML: boolean;
	LevelSequenceActor: LevelSequenceActor;
	static Load(ResourceName: string): AutomatedLevelSequenceCapture;
	static Find(Outer: UObject, ResourceName: string): AutomatedLevelSequenceCapture;
	static GetDefaultObject(): AutomatedLevelSequenceCapture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AutomatedLevelSequenceCapture;
	static C(Other: UObject | any): AutomatedLevelSequenceCapture;
}

declare class BoolChannelKeyProxy extends UObject { 
	Time: FrameNumber;
	bValue: boolean;
	static Load(ResourceName: string): BoolChannelKeyProxy;
	static Find(Outer: UObject, ResourceName: string): BoolChannelKeyProxy;
	static GetDefaultObject(): BoolChannelKeyProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BoolChannelKeyProxy;
	static C(Other: UObject | any): BoolChannelKeyProxy;
}

declare class MovieSceneDoubleValue { 
	Value: number;
	Tangent: MovieSceneTangentData;
	InterpMode: ERichCurveInterpMode;
	TangentMode: ERichCurveTangentMode;
	PaddingByte: number;
	clone() : MovieSceneDoubleValue;
	static C(Other: UObject | any): MovieSceneDoubleValue;
}

declare class DoubleChannelKeyProxy extends UObject { 
	Time: FrameNumber;
	Value: MovieSceneDoubleValue;
	static Load(ResourceName: string): DoubleChannelKeyProxy;
	static Find(Outer: UObject, ResourceName: string): DoubleChannelKeyProxy;
	static GetDefaultObject(): DoubleChannelKeyProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DoubleChannelKeyProxy;
	static C(Other: UObject | any): DoubleChannelKeyProxy;
}

declare class FloatChannelKeyProxy extends UObject { 
	Time: FrameNumber;
	Value: MovieSceneFloatValue;
	static Load(ResourceName: string): FloatChannelKeyProxy;
	static Find(Outer: UObject, ResourceName: string): FloatChannelKeyProxy;
	static GetDefaultObject(): FloatChannelKeyProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FloatChannelKeyProxy;
	static C(Other: UObject | any): FloatChannelKeyProxy;
}

declare class IntegerChannelKeyProxy extends UObject { 
	Time: FrameNumber;
	Value: number;
	static Load(ResourceName: string): IntegerChannelKeyProxy;
	static Find(Outer: UObject, ResourceName: string): IntegerChannelKeyProxy;
	static GetDefaultObject(): IntegerChannelKeyProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IntegerChannelKeyProxy;
	static C(Other: UObject | any): IntegerChannelKeyProxy;
}

declare class K2Node_GetSequenceBinding extends K2Node { 
	SourceSequence: SoftObjectPath;
	Binding: MovieSceneObjectBindingID;
	static Load(ResourceName: string): K2Node_GetSequenceBinding;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetSequenceBinding;
	static GetDefaultObject(): K2Node_GetSequenceBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetSequenceBinding;
	static C(Other: UObject | any): K2Node_GetSequenceBinding;
}

declare class MovieSceneEventBlueprintExtension extends BlueprintExtension { 
	EventSections: MovieSceneEventSectionBase[];
	static Load(ResourceName: string): MovieSceneEventBlueprintExtension;
	static Find(Outer: UObject, ResourceName: string): MovieSceneEventBlueprintExtension;
	static GetDefaultObject(): MovieSceneEventBlueprintExtension;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneEventBlueprintExtension;
	static C(Other: UObject | any): MovieSceneEventBlueprintExtension;
}

declare class MovieSceneToolsPropertyTrackSettings { 
	ComponentName: string;
	PropertyName: string;
	clone() : MovieSceneToolsPropertyTrackSettings;
	static C(Other: UObject | any): MovieSceneToolsPropertyTrackSettings;
}

declare type EMovieSceneToolsPropertyTrackType = 'FloatTrack' | 'DoubleTrack' | 'EMovieSceneToolsPropertyTrackType_MAX';
declare var EMovieSceneToolsPropertyTrackType : { FloatTrack:'FloatTrack',DoubleTrack:'DoubleTrack',EMovieSceneToolsPropertyTrackType_MAX:'EMovieSceneToolsPropertyTrackType_MAX', };
declare class MovieSceneToolsFbxSettings { 
	FbxPropertyName: string;
	PropertyPath: MovieSceneToolsPropertyTrackSettings;
	PropertyType: EMovieSceneToolsPropertyTrackType;
	clone() : MovieSceneToolsFbxSettings;
	static C(Other: UObject | any): MovieSceneToolsFbxSettings;
}

declare class MovieSceneToolsProjectSettings extends UObject { 
	DefaultStartTime: number;
	DefaultDuration: number;
	ShotDirectory: string;
	ShotPrefix: string;
	FirstShotNumber: number;
	ShotIncrement: number;
	ShotNumDigits: number;
	TakeNumDigits: number;
	FirstTakeNumber: number;
	TakeSeparator: string;
	SubSequenceSeparator: string;
	FbxSettings: MovieSceneToolsFbxSettings[];
	static Load(ResourceName: string): MovieSceneToolsProjectSettings;
	static Find(Outer: UObject, ResourceName: string): MovieSceneToolsProjectSettings;
	static GetDefaultObject(): MovieSceneToolsProjectSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneToolsProjectSettings;
	static C(Other: UObject | any): MovieSceneToolsProjectSettings;
}

declare type EThumbnailQuality = 'Draft' | 'Normal' | 'Best' | 'EThumbnailQuality_MAX';
declare var EThumbnailQuality : { Draft:'Draft',Normal:'Normal',Best:'Best',EThumbnailQuality_MAX:'EThumbnailQuality_MAX', };
declare class MovieSceneUserThumbnailSettings extends UObject { 
	bDrawThumbnails: boolean;
	bDrawSingleThumbnails: boolean;
	ThumbnailSize: IntPoint;
	Quality: EThumbnailQuality;
	static Load(ResourceName: string): MovieSceneUserThumbnailSettings;
	static Find(Outer: UObject, ResourceName: string): MovieSceneUserThumbnailSettings;
	static GetDefaultObject(): MovieSceneUserThumbnailSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneUserThumbnailSettings;
	static C(Other: UObject | any): MovieSceneUserThumbnailSettings;
}

declare class EditorWorldExtensionActorData { 
	Actor: Actor;
	bValidForPIE: boolean;
	clone() : EditorWorldExtensionActorData;
	static C(Other: UObject | any): EditorWorldExtensionActorData;
}

declare class EditorWorldExtension extends UObject { 
	ExtensionActors: EditorWorldExtensionActorData[];
	static Load(ResourceName: string): EditorWorldExtension;
	static Find(Outer: UObject, ResourceName: string): EditorWorldExtension;
	static GetDefaultObject(): EditorWorldExtension;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorWorldExtension;
	static C(Other: UObject | any): EditorWorldExtension;
}

declare class ViewportActionKeyInput { 
	ActionType: string;
	Event: EInputEvent;
	bIsInputCaptured: boolean;
	bIsAxis: boolean;
	clone() : ViewportActionKeyInput;
	static C(Other: UObject | any): ViewportActionKeyInput;
}

declare type EHitResultGizmoFilterMode = 'All' | 'NoGizmos' | 'GizmosOnly' | 'EHitResultGizmoFilterMode_MAX';
declare var EHitResultGizmoFilterMode : { All:'All',NoGizmos:'NoGizmos',GizmosOnly:'GizmosOnly',EHitResultGizmoFilterMode_MAX:'EHitResultGizmoFilterMode_MAX', };
declare type EViewportInteractionDraggingMode = 'Nothing' | 'TransformablesWithGizmo' | 'TransformablesAtLaserImpact' | 'AssistingDrag' | 'TransformablesFreely' | 'World' | 'Interactable' | 'Material' | 'EViewportInteractionDraggingMode_MAX';
declare var EViewportInteractionDraggingMode : { Nothing:'Nothing',TransformablesWithGizmo:'TransformablesWithGizmo',TransformablesAtLaserImpact:'TransformablesAtLaserImpact',AssistingDrag:'AssistingDrag',TransformablesFreely:'TransformablesFreely',World:'World',Interactable:'Interactable',Material:'Material',EViewportInteractionDraggingMode_MAX:'EViewportInteractionDraggingMode_MAX', };
declare class ViewportInteractor extends UObject { 
	KeyToActionMap: Map<Key, ViewportActionKeyInput>;
	WorldInteraction: ViewportWorldInteraction;
	OtherInteractor: ViewportInteractor;
	static Load(ResourceName: string): ViewportInteractor;
	static Find(Outer: UObject, ResourceName: string): ViewportInteractor;
	static GetDefaultObject(): ViewportInteractor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportInteractor;
	Tick(DeltaTime: number): void;
	Shutdown(): void;
	SetHitResultGizmoFilterMode(newFilter: EHitResultGizmoFilterMode): void;
	SetDraggingMode(NewDraggingMode: EViewportInteractionDraggingMode): void;
	SetCanCarry(bInCanCarry: boolean): void;
	IsHoveringOverGizmo(): boolean;
	HandleInputKey_BP(Action: ViewportActionKeyInput,Key: Key,Event: EInputEvent,bOutWasHandled?: boolean): {bOutWasHandled: boolean};
	HandleInputAxis_BP(Action: ViewportActionKeyInput,Key: Key,Delta: number,DeltaTime: number,bOutWasHandled?: boolean): {bOutWasHandled: boolean};
	GetWorldInteraction(): ViewportWorldInteraction;
	GetTransformAndForwardVector(OutHandTransform?: Transform,OutForwardVector?: Vector): {OutHandTransform: Transform, OutForwardVector: Vector, $: boolean};
	GetTransform(): Transform;
	GetRoomSpaceTransform(): Transform;
	GetOtherInteractor(): ViewportInteractor;
	GetLastTransform(): Transform;
	GetLastRoomSpaceTransform(): Transform;
	GetLaserPointer(LaserPointerStart?: Vector,LaserPointerEnd?: Vector,bEvenIfBlocked?: boolean,LaserLengthOverride?: number): {LaserPointerStart: Vector, LaserPointerEnd: Vector, $: boolean};
	GetHoverLocation(): Vector;
	GetHitResultGizmoFilterMode(): EHitResultGizmoFilterMode;
	GetDraggingMode(): EViewportInteractionDraggingMode;
	CanCarry(): boolean;
	static C(Other: UObject | any): ViewportInteractor;
}

declare class GizmoHandle { 
	clone() : GizmoHandle;
	static C(Other: UObject | any): GizmoHandle;
}

declare class ViewportDragOperation extends UObject { 
	static Load(ResourceName: string): ViewportDragOperation;
	static Find(Outer: UObject, ResourceName: string): ViewportDragOperation;
	static GetDefaultObject(): ViewportDragOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportDragOperation;
	static C(Other: UObject | any): ViewportDragOperation;
}

declare class ViewportDragOperationComponent extends ActorComponent { 
	DragOperation: ViewportDragOperation;
	DragOperationSubclass: UnrealEngineClass;
	static Load(ResourceName: string): ViewportDragOperationComponent;
	static Find(Outer: UObject, ResourceName: string): ViewportDragOperationComponent;
	static GetDefaultObject(): ViewportDragOperationComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportDragOperationComponent;
	static C(Other: UObject | any): ViewportDragOperationComponent;
}

declare class GizmoHandleGroup extends SceneComponent { 
	GizmoMaterial: MaterialInterface;
	TranslucentGizmoMaterial: MaterialInterface;
	Handles: GizmoHandle[];
	OwningTransformGizmoActor: BaseTransformGizmo;
	DragOperationComponent: ViewportDragOperationComponent;
	static Load(ResourceName: string): GizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): GizmoHandleGroup;
	static GetDefaultObject(): GizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoHandleGroup;
	static C(Other: UObject | any): GizmoHandleGroup;
}

declare class BaseTransformGizmo extends Actor { 
	SceneComponent: SceneComponent;
	AllHandleGroups: GizmoHandleGroup[];
	WorldInteraction: ViewportWorldInteraction;
	static GetDefaultObject(): BaseTransformGizmo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BaseTransformGizmo;
	static C(Other: UObject | any): BaseTransformGizmo;
}

declare class MouseCursorInteractor extends ViewportInteractor { 
	static Load(ResourceName: string): MouseCursorInteractor;
	static Find(Outer: UObject, ResourceName: string): MouseCursorInteractor;
	static GetDefaultObject(): MouseCursorInteractor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MouseCursorInteractor;
	static C(Other: UObject | any): MouseCursorInteractor;
}

declare class ViewportInteractionAssetContainer extends DataAsset { 
	GizmoHandleSelectedSound: SoundBase;
	GizmoHandleDropSound: SoundBase;
	SelectionChangeSound: SoundBase;
	SelectionDropSound: SoundBase;
	SelectionStartDragSound: SoundBase;
	GridSnapSound: SoundBase;
	ActorSnapSound: SoundBase;
	UndoSound: SoundBase;
	RedoSound: SoundBase;
	GridMesh: StaticMesh;
	TranslationHandleMesh: StaticMesh;
	UniformScaleHandleMesh: StaticMesh;
	ScaleHandleMesh: StaticMesh;
	PlaneTranslationHandleMesh: StaticMesh;
	RotationHandleMesh: StaticMesh;
	RotationHandleSelectedMesh: StaticMesh;
	StartRotationIndicatorMesh: StaticMesh;
	CurrentRotationIndicatorMesh: StaticMesh;
	FreeRotationHandleMesh: StaticMesh;
	GridMaterial: MaterialInterface;
	TransformGizmoMaterial: MaterialInterface;
	TranslucentTransformGizmoMaterial: MaterialInterface;
	static Load(ResourceName: string): ViewportInteractionAssetContainer;
	static Find(Outer: UObject, ResourceName: string): ViewportInteractionAssetContainer;
	static GetDefaultObject(): ViewportInteractionAssetContainer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportInteractionAssetContainer;
	static C(Other: UObject | any): ViewportInteractionAssetContainer;
}

declare class ViewportWorldInteraction extends EditorWorldExtension { 
	Interactors: ViewportInteractor[];
	ViewportTransformer: ViewportTransformer;
	TransformGizmoActor: BaseTransformGizmo;
	SnapGridActor: Actor;
	SnapGridMeshComponent: StaticMeshComponent;
	SnapGridMID: MaterialInstanceDynamic;
	DefaultMouseCursorInteractor: MouseCursorInteractor;
	ActorsToExcludeFromHitTest: Actor[];
	AssetContainer: ViewportInteractionAssetContainer;
	static Load(ResourceName: string): ViewportWorldInteraction;
	static Find(Outer: UObject, ResourceName: string): ViewportWorldInteraction;
	static GetDefaultObject(): ViewportWorldInteraction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportWorldInteraction;
	SetWorldToMetersScale(NewWorldToMetersScale: number,bCompensateRoomWorldScale: boolean): void;
	SetRoomTransformForNextFrame(NewRoomTransform: Transform): void;
	SetHeadTransform(NewHeadTransform: Transform): void;
	RemoveInteractor(Interactor: ViewportInteractor): void;
	GetWorldScaleFactor(): number;
	GetTransformGizmoActor(): BaseTransformGizmo;
	GetRoomTransform(): Transform;
	GetRoomSpaceHeadTransform(): Transform;
	GetInteractors(): ViewportInteractor[];
	GetHeadTransform(): Transform;
	AddInteractor(Interactor: ViewportInteractor): void;
	AddActorToExcludeFromHitTests(ActorToExcludeFromHitTests: Actor): void;
	static C(Other: UObject | any): ViewportWorldInteraction;
}

declare class ViewportTransformer extends UObject { 
	ViewportWorldInteraction: ViewportWorldInteraction;
	static Load(ResourceName: string): ViewportTransformer;
	static Find(Outer: UObject, ResourceName: string): ViewportTransformer;
	static GetDefaultObject(): ViewportTransformer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportTransformer;
	Shutdown(): void;
	ShouldCenterTransformGizmoPivot(): boolean;
	OnStopDragging(Interactor: ViewportInteractor): void;
	OnStartDragging(Interactor: ViewportInteractor): void;
	Init(InitViewportWorldInteraction: ViewportWorldInteraction): void;
	CanAlignToActors(): boolean;
	static C(Other: UObject | any): ViewportTransformer;
}

declare class ActorTransformer extends ViewportTransformer { 
	static Load(ResourceName: string): ActorTransformer;
	static Find(Outer: UObject, ResourceName: string): ActorTransformer;
	static GetDefaultObject(): ActorTransformer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorTransformer;
	static C(Other: UObject | any): ActorTransformer;
}

declare class ViewportInteractableInterface extends Interface { 
	static Load(ResourceName: string): ViewportInteractableInterface;
	static Find(Outer: UObject, ResourceName: string): ViewportInteractableInterface;
	static GetDefaultObject(): ViewportInteractableInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportInteractableInterface;
	static C(Other: UObject | any): ViewportInteractableInterface;
}

declare class TranslationDragOperation extends ViewportDragOperation { 
	static Load(ResourceName: string): TranslationDragOperation;
	static Find(Outer: UObject, ResourceName: string): TranslationDragOperation;
	static GetDefaultObject(): TranslationDragOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TranslationDragOperation;
	static C(Other: UObject | any): TranslationDragOperation;
}

declare class PlaneTranslationDragOperation extends ViewportDragOperation { 
	static Load(ResourceName: string): PlaneTranslationDragOperation;
	static Find(Outer: UObject, ResourceName: string): PlaneTranslationDragOperation;
	static GetDefaultObject(): PlaneTranslationDragOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlaneTranslationDragOperation;
	static C(Other: UObject | any): PlaneTranslationDragOperation;
}

declare class RotateOnAngleDragOperation extends ViewportDragOperation { 
	static Load(ResourceName: string): RotateOnAngleDragOperation;
	static Find(Outer: UObject, ResourceName: string): RotateOnAngleDragOperation;
	static GetDefaultObject(): RotateOnAngleDragOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RotateOnAngleDragOperation;
	static C(Other: UObject | any): RotateOnAngleDragOperation;
}

declare class ScaleDragOperation extends ViewportDragOperation { 
	static Load(ResourceName: string): ScaleDragOperation;
	static Find(Outer: UObject, ResourceName: string): ScaleDragOperation;
	static GetDefaultObject(): ScaleDragOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScaleDragOperation;
	static C(Other: UObject | any): ScaleDragOperation;
}

declare class UniformScaleDragOperation extends ViewportDragOperation { 
	static Load(ResourceName: string): UniformScaleDragOperation;
	static Find(Outer: UObject, ResourceName: string): UniformScaleDragOperation;
	static GetDefaultObject(): UniformScaleDragOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UniformScaleDragOperation;
	static C(Other: UObject | any): UniformScaleDragOperation;
}

declare class AxisGizmoHandleGroup extends GizmoHandleGroup { 
	static Load(ResourceName: string): AxisGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): AxisGizmoHandleGroup;
	static GetDefaultObject(): AxisGizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AxisGizmoHandleGroup;
	static C(Other: UObject | any): AxisGizmoHandleGroup;
}

declare class GizmoHandleMeshComponent extends StaticMeshComponent { 
	static Load(ResourceName: string): GizmoHandleMeshComponent;
	static Find(Outer: UObject, ResourceName: string): GizmoHandleMeshComponent;
	static GetDefaultObject(): GizmoHandleMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoHandleMeshComponent;
	static C(Other: UObject | any): GizmoHandleMeshComponent;
}

declare class UniformScaleGizmoHandleGroup extends GizmoHandleGroup { 
	static Load(ResourceName: string): UniformScaleGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): UniformScaleGizmoHandleGroup;
	static GetDefaultObject(): UniformScaleGizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UniformScaleGizmoHandleGroup;
	static C(Other: UObject | any): UniformScaleGizmoHandleGroup;
}

declare class PivotTranslationGizmoHandleGroup extends AxisGizmoHandleGroup { 
	static Load(ResourceName: string): PivotTranslationGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): PivotTranslationGizmoHandleGroup;
	static GetDefaultObject(): PivotTranslationGizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PivotTranslationGizmoHandleGroup;
	static C(Other: UObject | any): PivotTranslationGizmoHandleGroup;
}

declare class PivotScaleGizmoHandleGroup extends AxisGizmoHandleGroup { 
	static Load(ResourceName: string): PivotScaleGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): PivotScaleGizmoHandleGroup;
	static GetDefaultObject(): PivotScaleGizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PivotScaleGizmoHandleGroup;
	static C(Other: UObject | any): PivotScaleGizmoHandleGroup;
}

declare class PivotPlaneTranslationGizmoHandleGroup extends AxisGizmoHandleGroup { 
	static Load(ResourceName: string): PivotPlaneTranslationGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): PivotPlaneTranslationGizmoHandleGroup;
	static GetDefaultObject(): PivotPlaneTranslationGizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PivotPlaneTranslationGizmoHandleGroup;
	static C(Other: UObject | any): PivotPlaneTranslationGizmoHandleGroup;
}

declare class PivotRotationGizmoHandleGroup extends AxisGizmoHandleGroup { 
	RootFullRotationHandleComponent: SceneComponent;
	FullRotationHandleMeshComponent: GizmoHandleMeshComponent;
	StartRotationIndicatorMeshComponent: GizmoHandleMeshComponent;
	RootStartRotationIdicatorComponent: SceneComponent;
	DeltaRotationIndicatorMeshComponent: GizmoHandleMeshComponent;
	RootDeltaRotationIndicatorComponent: SceneComponent;
	static Load(ResourceName: string): PivotRotationGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): PivotRotationGizmoHandleGroup;
	static GetDefaultObject(): PivotRotationGizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PivotRotationGizmoHandleGroup;
	static C(Other: UObject | any): PivotRotationGizmoHandleGroup;
}

declare class StretchGizmoHandleGroup extends GizmoHandleGroup { 
	static Load(ResourceName: string): StretchGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): StretchGizmoHandleGroup;
	static GetDefaultObject(): StretchGizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StretchGizmoHandleGroup;
	static C(Other: UObject | any): StretchGizmoHandleGroup;
}

declare class PivotTransformGizmo extends BaseTransformGizmo { 
	UniformScaleGizmoHandleGroup: UniformScaleGizmoHandleGroup;
	TranslationGizmoHandleGroup: PivotTranslationGizmoHandleGroup;
	ScaleGizmoHandleGroup: PivotScaleGizmoHandleGroup;
	PlaneTranslationGizmoHandleGroup: PivotPlaneTranslationGizmoHandleGroup;
	RotationGizmoHandleGroup: PivotRotationGizmoHandleGroup;
	StretchGizmoHandleGroup: StretchGizmoHandleGroup;
	LastDraggingHandle: ActorComponent;
	static GetDefaultObject(): PivotTransformGizmo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PivotTransformGizmo;
	static C(Other: UObject | any): PivotTransformGizmo;
}

declare class VISettings extends UObject { 
	bScaleWorldFromFloor: boolean;
	bScaleWorldWithDynamicPivot: boolean;
	bAllowSimultaneousWorldScalingAndRotation: boolean;
	static Load(ResourceName: string): VISettings;
	static Find(Outer: UObject, ResourceName: string): VISettings;
	static GetDefaultObject(): VISettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VISettings;
	static C(Other: UObject | any): VISettings;
}

declare class StretchGizmoHandleDragOperation extends ViewportDragOperation { 
	static Load(ResourceName: string): StretchGizmoHandleDragOperation;
	static Find(Outer: UObject, ResourceName: string): StretchGizmoHandleDragOperation;
	static GetDefaultObject(): StretchGizmoHandleDragOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StretchGizmoHandleDragOperation;
	static C(Other: UObject | any): StretchGizmoHandleDragOperation;
}

declare class MotionTrailToolOptions extends UObject { 
	bShowTrails: boolean;
	TrailColor: LinearColor;
	bShowFullTrail: boolean;
	TrailThickness: number;
	FramesBefore: number;
	FramesAfter: number;
	EvalsPerFrame: number;
	bShowKeys: boolean;
	bShowFrameNumber: boolean;
	KeyColor: LinearColor;
	KeySize: number;
	bShowMarks: boolean;
	MarkColor: LinearColor;
	MarkSize: number;
	bLockMarksToFrames: boolean;
	SecondsPerMark: number;
	static Load(ResourceName: string): MotionTrailToolOptions;
	static Find(Outer: UObject, ResourceName: string): MotionTrailToolOptions;
	static GetDefaultObject(): MotionTrailToolOptions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MotionTrailToolOptions;
	static C(Other: UObject | any): MotionTrailToolOptions;
}

declare class MovieSceneCopyableBinding extends UObject { 
	SpawnableObjectTemplate: UObject;
	Tracks: MovieSceneTrack[];
	Binding: MovieSceneBinding;
	Spawnable: MovieSceneSpawnable;
	Possessable: MovieScenePossessable;
	BoundObjectNames: string[];
	FolderPath: string[];
	static Load(ResourceName: string): MovieSceneCopyableBinding;
	static Find(Outer: UObject, ResourceName: string): MovieSceneCopyableBinding;
	static GetDefaultObject(): MovieSceneCopyableBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneCopyableBinding;
	static C(Other: UObject | any): MovieSceneCopyableBinding;
}

declare class MovieSceneCopyableTrack extends UObject { 
	Track: MovieSceneTrack;
	bIsAMasterTrack: boolean;
	bIsACameraCutTrack: boolean;
	FolderPath: string[];
	static Load(ResourceName: string): MovieSceneCopyableTrack;
	static Find(Outer: UObject, ResourceName: string): MovieSceneCopyableTrack;
	static GetDefaultObject(): MovieSceneCopyableTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneCopyableTrack;
	static C(Other: UObject | any): MovieSceneCopyableTrack;
}

declare class Exporter extends UObject { 
	SupportedClass: UnrealEngineClass;
	ExportRootScope: UObject;
	FormatExtension: string[];
	FormatDescription: string[];
	PreferredFormatIndex: number;
	TextIndent: number;
	bText: boolean;
	bSelectedOnly: boolean;
	bForceFileOperations: boolean;
	ExportTask: AssetExportTask;
	static Load(ResourceName: string): Exporter;
	static Find(Outer: UObject, ResourceName: string): Exporter;
	static GetDefaultObject(): Exporter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Exporter;
	ScriptRunAssetExportTask(Task: AssetExportTask): boolean;
	static RunAssetExportTasks(ExportTasks: AssetExportTask[]): boolean;
	static RunAssetExportTask(Task: AssetExportTask): boolean;
	static C(Other: UObject | any): Exporter;
}

declare class AssetExportTask extends UObject { 
	UObject: UObject;
	Exporter: Exporter;
	Filename: string;
	bSelected: boolean;
	bReplaceIdentical: boolean;
	bPrompt: boolean;
	bAutomated: boolean;
	bUseFileArchive: boolean;
	bWriteEmptyFiles: boolean;
	IgnoreObjectList: UObject[];
	Options: UObject;
	Errors: string[];
	static Load(ResourceName: string): AssetExportTask;
	static Find(Outer: UObject, ResourceName: string): AssetExportTask;
	static GetDefaultObject(): AssetExportTask;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetExportTask;
	static C(Other: UObject | any): AssetExportTask;
}

declare class SequencerExportTask extends AssetExportTask { 
	SequencerContext: UObject;
	static Load(ResourceName: string): SequencerExportTask;
	static Find(Outer: UObject, ResourceName: string): SequencerExportTask;
	static GetDefaultObject(): SequencerExportTask;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequencerExportTask;
	static C(Other: UObject | any): SequencerExportTask;
}

declare class MovieSceneDoubleChannel extends MovieSceneChannel { 
	PreInfinityExtrap: ERichCurveExtrapolation;
	PostInfinityExtrap: ERichCurveExtrapolation;
	Times: FrameNumber[];
	Values: MovieSceneDoubleValue[];
	DefaultValue: number;
	bHasDefaultValue: boolean;
	KeyHandles: MovieSceneKeyHandleMap;
	TickResolution: FrameRate;
	bShowCurve: boolean;
	clone() : MovieSceneDoubleChannel;
	static C(Other: UObject | any): MovieSceneDoubleChannel;
}

declare class MovieScene3DTransformSectionConstraints extends UObject { 
	ConstraintsChannels: ConstraintAndActiveChannel[];
	static Load(ResourceName: string): MovieScene3DTransformSectionConstraints;
	static Find(Outer: UObject, ResourceName: string): MovieScene3DTransformSectionConstraints;
	static GetDefaultObject(): MovieScene3DTransformSectionConstraints;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScene3DTransformSectionConstraints;
	static C(Other: UObject | any): MovieScene3DTransformSectionConstraints;
}

declare type EShow3DTrajectory = 'EST_OnlyWhenSelected' | 'EST_Always' | 'EST_Never' | 'EST_MAX';
declare var EShow3DTrajectory : { EST_OnlyWhenSelected:'EST_OnlyWhenSelected',EST_Always:'EST_Always',EST_Never:'EST_Never',EST_MAX:'EST_MAX', };
declare class MovieScene3DTransformSection extends MovieSceneSection { 
	TransformMask: MovieSceneTransformMask;
	Translation: MovieSceneDoubleChannel;
	Rotation: MovieSceneDoubleChannel;
	Scale: MovieSceneDoubleChannel;
	ManualWeight: MovieSceneFloatChannel;
	OverrideRegistry: MovieSceneSectionChannelOverrideRegistry;
	Constraints: MovieScene3DTransformSectionConstraints;
	bUseQuaternionInterpolation: boolean;
	Show3DTrajectory: EShow3DTrajectory;
	static Load(ResourceName: string): MovieScene3DTransformSection;
	static Find(Outer: UObject, ResourceName: string): MovieScene3DTransformSection;
	static GetDefaultObject(): MovieScene3DTransformSection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScene3DTransformSection;
	static C(Other: UObject | any): MovieScene3DTransformSection;
}

declare class SequencerKeyActor extends Actor { 
	KeyMeshComponent: StaticMeshComponent;
	AssociatedActor: Actor;
	TrackSection: MovieScene3DTransformSection;
	KeyTime: number;
	static GetDefaultObject(): SequencerKeyActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequencerKeyActor;
	static C(Other: UObject | any): SequencerKeyActor;
}

declare class MovieSceneKeyStructType extends ScriptStruct { 
	SourceTimesProperty: any;
	SourceValuesProperty: any;
	DestTimeProperty: any;
	DestValueProperty: any;
	static Load(ResourceName: string): MovieSceneKeyStructType;
	static Find(Outer: UObject, ResourceName: string): MovieSceneKeyStructType;
	static GetDefaultObject(): MovieSceneKeyStructType;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneKeyStructType;
	static C(Other: UObject | any): MovieSceneKeyStructType;
}

declare class SequencerMeshTrail extends Actor { 
	static GetDefaultObject(): SequencerMeshTrail;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequencerMeshTrail;
	static C(Other: UObject | any): SequencerMeshTrail;
}

declare class SequencerSettingsContainer extends UObject { 
	static Load(ResourceName: string): SequencerSettingsContainer;
	static Find(Outer: UObject, ResourceName: string): SequencerSettingsContainer;
	static GetDefaultObject(): SequencerSettingsContainer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequencerSettingsContainer;
	static C(Other: UObject | any): SequencerSettingsContainer;
}

declare type EAutoChangeMode = 'AutoKey' | 'AutoTrack' | 'All' | 'None' | 'EAutoChangeMode_MAX';
declare var EAutoChangeMode : { AutoKey:'AutoKey',AutoTrack:'AutoTrack',All:'All',None:'None',EAutoChangeMode_MAX:'EAutoChangeMode_MAX', };
declare type EAllowEditsMode = 'AllEdits' | 'AllowSequencerEditsOnly' | 'AllowLevelEditsOnly' | 'EAllowEditsMode_MAX';
declare var EAllowEditsMode : { AllEdits:'AllEdits',AllowSequencerEditsOnly:'AllowSequencerEditsOnly',AllowLevelEditsOnly:'AllowLevelEditsOnly',EAllowEditsMode_MAX:'EAllowEditsMode_MAX', };
declare type EKeyGroupMode = 'KeyChanged' | 'KeyGroup' | 'KeyAll' | 'EKeyGroupMode_MAX';
declare var EKeyGroupMode : { KeyChanged:'KeyChanged',KeyGroup:'KeyGroup',KeyAll:'KeyAll',EKeyGroupMode_MAX:'EKeyGroupMode_MAX', };
declare type EMovieSceneKeyInterpolation = 'Auto' | 'User' | 'Break' | 'Linear' | 'Constant' | 'EMovieSceneKeyInterpolation_MAX';
declare var EMovieSceneKeyInterpolation : { Auto:'Auto',User:'User',Break:'Break',Linear:'Linear',Constant:'Constant',EMovieSceneKeyInterpolation_MAX:'EMovieSceneKeyInterpolation_MAX', };
declare type ESequencerSpawnPosition = 'SSP_Origin' | 'SSP_PlaceInFrontOfCamera' | 'SSP_MAX';
declare var ESequencerSpawnPosition : { SSP_Origin:'SSP_Origin',SSP_PlaceInFrontOfCamera:'SSP_PlaceInFrontOfCamera',SSP_MAX:'SSP_MAX', };
declare type ESequencerZoomPosition = 'SZP_CurrentTime' | 'SZP_MousePosition' | 'SZP_MAX';
declare var ESequencerZoomPosition : { SZP_CurrentTime:'SZP_CurrentTime',SZP_MousePosition:'SZP_MousePosition',SZP_MAX:'SZP_MAX', };
declare type ESequencerLoopMode = 'SLM_NoLoop' | 'SLM_Loop' | 'SLM_LoopSelectionRange' | 'SLM_MAX';
declare var ESequencerLoopMode : { SLM_NoLoop:'SLM_NoLoop',SLM_Loop:'SLM_Loop',SLM_LoopSelectionRange:'SLM_LoopSelectionRange',SLM_MAX:'SLM_MAX', };
declare type EFrameNumberDisplayFormats = 'NonDropFrameTimecode' | 'DropFrameTimecode' | 'Seconds' | 'Frames' | 'MAX_Count' | 'EFrameNumberDisplayFormats_MAX';
declare var EFrameNumberDisplayFormats : { NonDropFrameTimecode:'NonDropFrameTimecode',DropFrameTimecode:'DropFrameTimecode',Seconds:'Seconds',Frames:'Frames',MAX_Count:'MAX_Count',EFrameNumberDisplayFormats_MAX:'EFrameNumberDisplayFormats_MAX', };
declare class SequencerSettings extends UObject { 
	AutoChangeMode: EAutoChangeMode;
	AllowEditsMode: EAllowEditsMode;
	KeyGroupMode: EKeyGroupMode;
	KeyInterpolation: EMovieSceneKeyInterpolation;
	bAutoSetTrackDefaults: boolean;
	SpawnPosition: ESequencerSpawnPosition;
	bCreateSpawnableCameras: boolean;
	bShowRangeSlider: boolean;
	bIsSnapEnabled: boolean;
	bSnapKeyTimesToInterval: boolean;
	bSnapKeyTimesToKeys: boolean;
	bSnapSectionTimesToInterval: boolean;
	bSnapSectionTimesToSections: boolean;
	bSnapKeysAndSectionsToPlayRange: boolean;
	bSnapPlayTimeToKeys: boolean;
	bSnapPlayTimeToSections: boolean;
	bSnapPlayTimeToMarkers: boolean;
	bSnapPlayTimeToInterval: boolean;
	bSnapPlayTimeToPressedKey: boolean;
	bSnapPlayTimeToDraggedKey: boolean;
	bSnapCurveValueToInterval: boolean;
	bShowSelectedNodesOnly: boolean;
	bRewindOnRecord: boolean;
	bLeftMouseDragDoesMarquee: boolean;
	ZoomPosition: ESequencerZoomPosition;
	bAutoScrollEnabled: boolean;
	bLinkCurveEditorTimeRange: boolean;
	bSynchronizeCurveEditorSelection: boolean;
	bIsolateCurveEditorToSelection: boolean;
	LoopMode: ESequencerLoopMode;
	bKeepCursorInPlayRangeWhileScrubbing: boolean;
	bKeepPlayRangeInSectionBounds: boolean;
	ZeroPadFrames: number;
	JumpFrameIncrement: FrameNumber;
	bShowLayerBars: boolean;
	bShowKeyBars: boolean;
	bInfiniteKeyAreas: boolean;
	bShowChannelColors: boolean;
	bShowStatusBar: boolean;
	bShowTickLines: boolean;
	bShowSequencerToolbar: boolean;
	KeyAreaCurveExtents: string;
	KeyAreaHeightWithCurves: number;
	ReduceKeysTolerance: number;
	bDeleteKeysWhenTrimming: boolean;
	bDisableSectionsAfterBaking: boolean;
	bCleanPlaybackMode: boolean;
	bActivateRealtimeViewports: boolean;
	bEvaluateSubSequencesInIsolation: boolean;
	bRerunConstructionScripts: boolean;
	bShowDebugVisualization: boolean;
	bVisualizePreAndPostRoll: boolean;
	bCompileDirectorOnEvaluate: boolean;
	TrajectoryPathCap: number;
	FrameNumberDisplayFormat: EFrameNumberDisplayFormats;
	MovieRendererName: string;
	bAutoExpandNodesOnSelection: boolean;
	TreeViewWidth: number;
	static Load(ResourceName: string): SequencerSettings;
	static Find(Outer: UObject, ResourceName: string): SequencerSettings;
	static GetDefaultObject(): SequencerSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequencerSettings;
	static C(Other: UObject | any): SequencerSettings;
}

declare class SequencerToolMenuContext extends UObject { 
	static Load(ResourceName: string): SequencerToolMenuContext;
	static Find(Outer: UObject, ResourceName: string): SequencerToolMenuContext;
	static GetDefaultObject(): SequencerToolMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequencerToolMenuContext;
	static C(Other: UObject | any): SequencerToolMenuContext;
}

declare class SequencerTrackFilterExtension extends UObject { 
	static Load(ResourceName: string): SequencerTrackFilterExtension;
	static Find(Outer: UObject, ResourceName: string): SequencerTrackFilterExtension;
	static GetDefaultObject(): SequencerTrackFilterExtension;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequencerTrackFilterExtension;
	static C(Other: UObject | any): SequencerTrackFilterExtension;
}

declare class PixelInspectorView extends UObject { 
	FinalColor: LinearColor;
	SceneColor: LinearColor;
	PreExposure: number;
	Luminance: number;
	HdrColor: LinearColor;
	Normal: Vector;
	PerObjectGBufferData: number;
	Metallic: number;
	Specular: number;
	Roughness: number;
	MaterialShadingModel: EMaterialShadingModel;
	SelectiveOutputMask: number;
	BaseColor: LinearColor;
	IndirectIrradiance: number;
	AmbientOcclusion: number;
	SubsurfaceColor: LinearColor;
	SubsurfaceProfile: Vector;
	Opacity: number;
	ClearCoat: number;
	ClearCoatRoughness: number;
	WorldNormal: Vector;
	BackLit: number;
	Cloth: number;
	EyeTangent: Vector;
	IrisMask: number;
	IrisDistance: number;
	static Load(ResourceName: string): PixelInspectorView;
	static Find(Outer: UObject, ResourceName: string): PixelInspectorView;
	static GetDefaultObject(): PixelInspectorView;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PixelInspectorView;
	static C(Other: UObject | any): PixelInspectorView;
}

declare class SubobjectDataHandle { 
	clone() : SubobjectDataHandle;
	static C(Other: UObject | any): SubobjectDataHandle;
	GetData(OutData?: SubobjectData): {OutData: SubobjectData};
	IsHandleValid(): boolean;
	static GetData(DataHandle: SubobjectDataHandle,OutData?: SubobjectData): {OutData: SubobjectData};
	static IsHandleValid(DataHandle: SubobjectDataHandle): boolean;
}

declare class SubobjectData { 
	WeakObjectPtr: UObject;
	Handle: SubobjectDataHandle;
	ParentObjectHandle: SubobjectDataHandle;
	ChildrenHandles: SubobjectDataHandle[];
	clone() : SubobjectData;
	static C(Other: UObject | any): SubobjectData;
	CanCopy(): boolean;
	CanDelete(): boolean;
	CanDuplicate(): boolean;
	CanEdit(): boolean;
	CanRename(): boolean;
	CanReparent(): boolean;
	GetHandle(OutHandle?: SubobjectDataHandle): {OutHandle: SubobjectDataHandle};
	GetObject(bEvenIfPendingKill: boolean): UObject;
	GetObjectForBlueprint(Blueprint: Blueprint): UObject;
	GetVariableName(): string;
	IsActor(): boolean;
	IsAttachedTo(InHandle: SubobjectDataHandle): boolean;
	IsChildActor(): boolean;
	IsComponent(): boolean;
	IsDefaultSceneRoot(): boolean;
	IsInheritedComponent(): boolean;
	IsInstancedActor(): boolean;
	IsInstancedComponent(): boolean;
	IsNativeComponent(): boolean;
	IsRootActor(): boolean;
	IsRootComponent(): boolean;
	IsSceneComponent(): boolean;
	IsValid(): boolean;
	static CanCopy(Data: SubobjectData): boolean;
	static CanDelete(Data: SubobjectData): boolean;
	static CanDuplicate(Data: SubobjectData): boolean;
	static CanEdit(Data: SubobjectData): boolean;
	static CanRename(Data: SubobjectData): boolean;
	static CanReparent(Data: SubobjectData): boolean;
	static GetHandle(Data: SubobjectData,OutHandle?: SubobjectDataHandle): {OutHandle: SubobjectDataHandle};
	static GetObject(Data: SubobjectData,bEvenIfPendingKill: boolean): UObject;
	static GetObjectForBlueprint(Data: SubobjectData,Blueprint: Blueprint): UObject;
	static GetVariableName(Data: SubobjectData): string;
	static IsActor(Data: SubobjectData): boolean;
	static IsAttachedTo(Data: SubobjectData,InHandle: SubobjectDataHandle): boolean;
	static IsChildActor(Data: SubobjectData): boolean;
	static IsComponent(Data: SubobjectData): boolean;
	static IsDefaultSceneRoot(Data: SubobjectData): boolean;
	static IsInheritedComponent(Data: SubobjectData): boolean;
	static IsInstancedActor(Data: SubobjectData): boolean;
	static IsInstancedComponent(Data: SubobjectData): boolean;
	static IsNativeComponent(Data: SubobjectData): boolean;
	static IsRootActor(Data: SubobjectData): boolean;
	static IsRootComponent(Data: SubobjectData): boolean;
	static IsSceneComponent(Data: SubobjectData): boolean;
	static IsValid(Data: SubobjectData): boolean;
}

declare class SubobjectDataBlueprintFunctionLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): SubobjectDataBlueprintFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): SubobjectDataBlueprintFunctionLibrary;
	static GetDefaultObject(): SubobjectDataBlueprintFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubobjectDataBlueprintFunctionLibrary;
	static IsValid(Data: SubobjectData): boolean;
	static IsSceneComponent(Data: SubobjectData): boolean;
	static IsRootComponent(Data: SubobjectData): boolean;
	static IsRootActor(Data: SubobjectData): boolean;
	static IsNativeComponent(Data: SubobjectData): boolean;
	static IsInstancedComponent(Data: SubobjectData): boolean;
	static IsInstancedActor(Data: SubobjectData): boolean;
	static IsInheritedComponent(Data: SubobjectData): boolean;
	static IsHandleValid(DataHandle: SubobjectDataHandle): boolean;
	static IsDefaultSceneRoot(Data: SubobjectData): boolean;
	static IsComponent(Data: SubobjectData): boolean;
	static IsChildActor(Data: SubobjectData): boolean;
	static IsAttachedTo(Data: SubobjectData,InHandle: SubobjectDataHandle): boolean;
	static IsActor(Data: SubobjectData): boolean;
	static GetVariableName(Data: SubobjectData): string;
	static GetObjectForBlueprint(Data: SubobjectData,Blueprint: Blueprint): UObject;
	static GetObject(Data: SubobjectData,bEvenIfPendingKill: boolean): UObject;
	static GetHandle(Data: SubobjectData,OutHandle?: SubobjectDataHandle): {OutHandle: SubobjectDataHandle};
	GetDisplayName(Data: SubobjectData): string;
	static GetData(DataHandle: SubobjectDataHandle,OutData?: SubobjectData): {OutData: SubobjectData};
	GetBlueprint(Data: SubobjectData): Blueprint;
	static CanReparent(Data: SubobjectData): boolean;
	static CanRename(Data: SubobjectData): boolean;
	static CanEdit(Data: SubobjectData): boolean;
	static CanDuplicate(Data: SubobjectData): boolean;
	static CanDelete(Data: SubobjectData): boolean;
	static CanCopy(Data: SubobjectData): boolean;
	static C(Other: UObject | any): SubobjectDataBlueprintFunctionLibrary;
}

declare class ReparentSubobjectParams { 
	NewParentHandle: SubobjectDataHandle;
	BlueprintContext: Blueprint;
	ActorPreviewContext: Actor;
	clone() : ReparentSubobjectParams;
	static C(Other: UObject | any): ReparentSubobjectParams;
}

declare class AddNewSubobjectParams { 
	ParentHandle: SubobjectDataHandle;
	NewClass: UnrealEngineClass;
	BlueprintContext: Blueprint;
	bSkipMarkBlueprintModified: boolean;
	bConformTransformToParent: boolean;
	clone() : AddNewSubobjectParams;
	static C(Other: UObject | any): AddNewSubobjectParams;
}

declare class SubobjectDataSubsystem extends EngineSubsystem { 
	static Load(ResourceName: string): SubobjectDataSubsystem;
	static Find(Outer: UObject, ResourceName: string): SubobjectDataSubsystem;
	static GetDefaultObject(): SubobjectDataSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubobjectDataSubsystem;
	ReparentSubobjects(Params: ReparentSubobjectParams,HandlesToMove: SubobjectDataHandle[]): boolean;
	ReparentSubobject(Params: ReparentSubobjectParams,ToReparentHandle: SubobjectDataHandle): boolean;
	static RenameSubobjectMemberVariable(BPContext: Blueprint,InHandle: SubobjectDataHandle,NewName: string): void;
	RenameSubobject(Handle: SubobjectDataHandle,InNewName: string): boolean;
	MakeNewSceneRoot(Context: SubobjectDataHandle,NewSceneRoot: SubobjectDataHandle,BPContext: Blueprint): boolean;
	K2_GatherSubobjectDataForInstance(Context: Actor,OutArray?: SubobjectDataHandle[]): {OutArray: SubobjectDataHandle[]};
	K2_GatherSubobjectDataForBlueprint(Context: Blueprint,OutArray?: SubobjectDataHandle[]): {OutArray: SubobjectDataHandle[]};
	K2_FindSubobjectDataFromHandle(Handle: SubobjectDataHandle,OutData?: SubobjectData): {OutData: SubobjectData, $: boolean};
	K2_DeleteSubobjectsFromInstance(ContextHandle: SubobjectDataHandle,SubobjectsToDelete: SubobjectDataHandle[]): number;
	K2_DeleteSubobjectFromInstance(ContextHandle: SubobjectDataHandle,SubobjectToDelete: SubobjectDataHandle): number;
	IsValidRename(Handle: SubobjectDataHandle,InNewText: string,OutErrorMessage?: string): {OutErrorMessage: string, $: boolean};
	FindHandleForObject(Context: SubobjectDataHandle,ObjectToFind: UObject,BPContext: Blueprint): SubobjectDataHandle;
	DetachSubobject(OwnerHandle: SubobjectDataHandle,ChildToRemove: SubobjectDataHandle): boolean;
	DeleteSubobjects(ContextHandle: SubobjectDataHandle,SubobjectsToDelete: SubobjectDataHandle[],BPContext: Blueprint): number;
	DeleteSubobject(ContextHandle: SubobjectDataHandle,SubobjectToDelete: SubobjectDataHandle,BPContext: Blueprint): number;
	static CreateNewCPPComponent(ComponentClass: UnrealEngineClass,NewClassPath: string,NewClassName: string): UnrealEngineClass;
	static CreateNewBPComponent(ComponentClass: UnrealEngineClass,NewClassPath: string,NewClassName: string): UnrealEngineClass;
	CopySubobjects(Handles: SubobjectDataHandle[],BPContext: Blueprint): void;
	ChangeSubobjectClass(Handle: SubobjectDataHandle,NewClass: UnrealEngineClass): boolean;
	CanPasteSubobjects(RootHandle: SubobjectDataHandle,BPContext: Blueprint): boolean;
	CanCopySubobjects(Handles: SubobjectDataHandle[]): boolean;
	AttachSubobject(OwnerHandle: SubobjectDataHandle,ChildToAddHandle: SubobjectDataHandle): boolean;
	AddNewSubobject(Params: AddNewSubobjectParams,FailReason?: string): {FailReason: string, $: SubobjectDataHandle};
	static C(Other: UObject | any): SubobjectDataSubsystem;
}

declare class SubobjectEditorMenuContext extends UObject { 
	static Load(ResourceName: string): SubobjectEditorMenuContext;
	static Find(Outer: UObject, ResourceName: string): SubobjectEditorMenuContext;
	static GetDefaultObject(): SubobjectEditorMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubobjectEditorMenuContext;
	GetSelectedObjects(): UObject[];
	static C(Other: UObject | any): SubobjectEditorMenuContext;
}

declare class VirtualizationFilterSettings extends UObject { 
	ExcludePackagePaths: string[];
	IncludePackagePaths: string[];
	static Load(ResourceName: string): VirtualizationFilterSettings;
	static Find(Outer: UObject, ResourceName: string): VirtualizationFilterSettings;
	static GetDefaultObject(): VirtualizationFilterSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VirtualizationFilterSettings;
	static C(Other: UObject | any): VirtualizationFilterSettings;
}

declare class PrecachePayloadsCommandlet extends Commandlet { 
	static Load(ResourceName: string): PrecachePayloadsCommandlet;
	static Find(Outer: UObject, ResourceName: string): PrecachePayloadsCommandlet;
	static GetDefaultObject(): PrecachePayloadsCommandlet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PrecachePayloadsCommandlet;
	static C(Other: UObject | any): PrecachePayloadsCommandlet;
}

declare class LevelEditorMenuContext extends UObject { 
	static Load(ResourceName: string): LevelEditorMenuContext;
	static Find(Outer: UObject, ResourceName: string): LevelEditorMenuContext;
	static GetDefaultObject(): LevelEditorMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelEditorMenuContext;
	static C(Other: UObject | any): LevelEditorMenuContext;
}

declare type ELevelEditorMenuContext = 'Viewport' | 'SceneOutliner' | 'MainMenu' | 'ELevelEditorMenuContext_MAX';
declare var ELevelEditorMenuContext : { Viewport:'Viewport',SceneOutliner:'SceneOutliner',MainMenu:'MainMenu',ELevelEditorMenuContext_MAX:'ELevelEditorMenuContext_MAX', };
declare class LevelEditorContextMenuContext extends UObject { 
	ContextType: ELevelEditorMenuContext;
	CurrentSelection: TypedElementSelectionSet;
	CursorWorldLocation: Vector;
	SelectedComponents: ActorComponent[];
	HitProxyActor: Actor;
	static Load(ResourceName: string): LevelEditorContextMenuContext;
	static Find(Outer: UObject, ResourceName: string): LevelEditorContextMenuContext;
	static GetDefaultObject(): LevelEditorContextMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelEditorContextMenuContext;
	GetScriptHitProxyElement(): ScriptTypedElementHandle;
	static C(Other: UObject | any): LevelEditorContextMenuContext;
}

declare class LevelViewportToolBarContext extends UObject { 
	static Load(ResourceName: string): LevelViewportToolBarContext;
	static Find(Outer: UObject, ResourceName: string): LevelViewportToolBarContext;
	static GetDefaultObject(): LevelViewportToolBarContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelViewportToolBarContext;
	static C(Other: UObject | any): LevelViewportToolBarContext;
}

declare class QuickActionMenuContext extends UObject { 
	CurrentSelection: TypedElementSelectionSet;
	static Load(ResourceName: string): QuickActionMenuContext;
	static Find(Outer: UObject, ResourceName: string): QuickActionMenuContext;
	static GetDefaultObject(): QuickActionMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): QuickActionMenuContext;
	static C(Other: UObject | any): QuickActionMenuContext;
}

declare class LevelEditorSubsystem extends EditorSubsystem { 
	static Load(ResourceName: string): LevelEditorSubsystem;
	static Find(Outer: UObject, ResourceName: string): LevelEditorSubsystem;
	static GetDefaultObject(): LevelEditorSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelEditorSubsystem;
	SetCurrentLevelByName(LevelName: string): boolean;
	SetAllowsCinematicControl(bAllow: boolean,ViewportConfigKey: string): void;
	SaveCurrentLevel(): boolean;
	SaveAllDirtyLevels(): boolean;
	PilotLevelActor(ActorToPilot: Actor,ViewportConfigKey: string): void;
	NewLevelFromTemplate(AssetPath: string,TemplateAssetPath: string): boolean;
	NewLevel(AssetPath: string): boolean;
	LoadLevel(AssetPath: string): boolean;
	IsInPlayInEditor(): boolean;
	GetViewportConfigKeys(): string[];
	GetSelectionSet(): TypedElementSelectionSet;
	GetPilotLevelActor(ViewportConfigKey: string): Actor;
	GetCurrentLevel(): Level;
	GetAllowsCinematicControl(ViewportConfigKey: string): boolean;
	GetActiveViewportConfigKey(): string;
	EjectPilotLevelActor(ViewportConfigKey: string): void;
	EditorSetGameView(bGameView: boolean,ViewportConfigKey: string): void;
	EditorRequestEndPlay(): void;
	EditorPlaySimulate(): void;
	EditorInvalidateViewports(): void;
	EditorGetGameView(ViewportConfigKey: string): boolean;
	BuildLightMaps(Quality: ELightingBuildQuality,bWithReflectionCaptures: boolean): boolean;
	static C(Other: UObject | any): LevelEditorSubsystem;
}

declare class LightEditorSubsystem extends EditorSubsystem { 
	static Load(ResourceName: string): LightEditorSubsystem;
	static Find(Outer: UObject, ResourceName: string): LightEditorSubsystem;
	static GetDefaultObject(): LightEditorSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightEditorSubsystem;
	static C(Other: UObject | any): LightEditorSubsystem;
}

declare class LevelEditorUISubsystem extends AssetEditorUISubsystem { 
	static Load(ResourceName: string): LevelEditorUISubsystem;
	static Find(Outer: UObject, ResourceName: string): LevelEditorUISubsystem;
	static GetDefaultObject(): LevelEditorUISubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelEditorUISubsystem;
	static C(Other: UObject | any): LevelEditorUISubsystem;
}

declare class UndoHistorySettings extends UObject { 
	bShowTransactionDetails: boolean;
	static Load(ResourceName: string): UndoHistorySettings;
	static Find(Outer: UObject, ResourceName: string): UndoHistorySettings;
	static GetDefaultObject(): UndoHistorySettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UndoHistorySettings;
	static C(Other: UObject | any): UndoHistorySettings;
}

declare class InterchangeResult extends UObject { 
	SourceAssetName: string;
	DestinationAssetName: string;
	AssetType: UnrealEngineClass;
	InterchangeKey: string;
	static Load(ResourceName: string): InterchangeResult;
	static Find(Outer: UObject, ResourceName: string): InterchangeResult;
	static GetDefaultObject(): InterchangeResult;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeResult;
	static C(Other: UObject | any): InterchangeResult;
}

declare class InterchangeResultsContainer extends UObject { 
	Results: InterchangeResult[];
	static Load(ResourceName: string): InterchangeResultsContainer;
	static Find(Outer: UObject, ResourceName: string): InterchangeResultsContainer;
	static GetDefaultObject(): InterchangeResultsContainer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeResultsContainer;
	static C(Other: UObject | any): InterchangeResultsContainer;
}

declare class InterchangeFactoryBase extends UObject { 
	Results: InterchangeResultsContainer;
	static Load(ResourceName: string): InterchangeFactoryBase;
	static Find(Outer: UObject, ResourceName: string): InterchangeFactoryBase;
	static GetDefaultObject(): InterchangeFactoryBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeFactoryBase;
	GetFactoryClass(): UnrealEngineClass;
	static C(Other: UObject | any): InterchangeFactoryBase;
}

declare class InterchangeSourceData extends UObject { 
	Filename: string;
	static Load(ResourceName: string): InterchangeSourceData;
	static Find(Outer: UObject, ResourceName: string): InterchangeSourceData;
	static GetDefaultObject(): InterchangeSourceData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeSourceData;
	SetFilename(InFilename: string): boolean;
	GetFilename(): string;
	static C(Other: UObject | any): InterchangeSourceData;
}

declare class InterchangeWriterBase extends UObject { 
	static Load(ResourceName: string): InterchangeWriterBase;
	static Find(Outer: UObject, ResourceName: string): InterchangeWriterBase;
	static GetDefaultObject(): InterchangeWriterBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeWriterBase;
	static C(Other: UObject | any): InterchangeWriterBase;
}

declare class InterchangePipelinePropertyStatePerContext { 
	bVisible: boolean;
	clone() : InterchangePipelinePropertyStatePerContext;
	static C(Other: UObject | any): InterchangePipelinePropertyStatePerContext;
}

declare class InterchangePipelinePropertyStates { 
	bLocked: boolean;
	ImportStates: InterchangePipelinePropertyStatePerContext;
	ReimportStates: InterchangePipelinePropertyStatePerContext;
	clone() : InterchangePipelinePropertyStates;
	static C(Other: UObject | any): InterchangePipelinePropertyStates;
}

declare type EInterchangeNodeContainerType = 'None' | 'TranslatedScene' | 'TranslatedAsset' | 'FactoryData' | 'EInterchangeNodeContainerType_MAX';
declare var EInterchangeNodeContainerType : { None:'None',TranslatedScene:'TranslatedScene',TranslatedAsset:'TranslatedAsset',FactoryData:'FactoryData',EInterchangeNodeContainerType_MAX:'EInterchangeNodeContainerType_MAX', };
declare class InterchangeBaseNode extends UObject { 
	static Load(ResourceName: string): InterchangeBaseNode;
	static Find(Outer: UObject, ResourceName: string): InterchangeBaseNode;
	static GetDefaultObject(): InterchangeBaseNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeBaseNode;
	SetParentUid(ParentUid: string): boolean;
	SetEnabled(bIsEnabled: boolean): boolean;
	SetDisplayLabel(DisplayName: string): boolean;
	SetAssetName(AssetName: string): boolean;
	RemoveTargetNodeUid(AssetUid: string): boolean;
	RemoveAttribute(NodeAttributeKey: string): boolean;
	IsEnabled(): boolean;
	InitializeNode(UniqueId: string,DisplayLabel: string,NodeContainerType: EInterchangeNodeContainerType): void;
	GetVector2Attribute(NodeAttributeKey: string,OutValue?: Vector2f): {OutValue: Vector2f, $: boolean};
	GetUniqueID(): string;
	GetTargetNodeUids(OutTargetAssets?: string[]): {OutTargetAssets: string[]};
	GetTargetNodeCount(): number;
	GetStringAttribute(NodeAttributeKey: string,OutValue?: string): {OutValue: string, $: boolean};
	GetParentUid(): string;
	GetNodeContainerType(): EInterchangeNodeContainerType;
	GetLinearColorAttribute(NodeAttributeKey: string,OutValue?: LinearColor): {OutValue: LinearColor, $: boolean};
	GetInt32Attribute(NodeAttributeKey: string,OutValue?: number): {OutValue: number, $: boolean};
	GetGuidAttribute(NodeAttributeKey: string,OutValue?: Guid): {OutValue: Guid, $: boolean};
	GetFloatAttribute(NodeAttributeKey: string,OutValue?: number): {OutValue: number, $: boolean};
	GetDoubleAttribute(NodeAttributeKey: string,OutValue?: number): {OutValue: number, $: boolean};
	GetDisplayLabel(): string;
	GetBooleanAttribute(NodeAttributeKey: string,OutValue?: boolean): {OutValue: boolean, $: boolean};
	GetAssetName(): string;
	AddVector2Attribute(NodeAttributeKey: string,Value: Vector2f): boolean;
	AddTargetNodeUid(AssetUid: string): boolean;
	AddStringAttribute(NodeAttributeKey: string,Value: string): boolean;
	AddLinearColorAttribute(NodeAttributeKey: string,Value: LinearColor): boolean;
	AddInt32Attribute(NodeAttributeKey: string,Value: number): boolean;
	AddGuidAttribute(NodeAttributeKey: string,Value: Guid): boolean;
	AddFloatAttribute(NodeAttributeKey: string,Value: number): boolean;
	AddDoubleAttribute(NodeAttributeKey: string,Value: number): boolean;
	AddBooleanAttribute(NodeAttributeKey: string,Value: boolean): boolean;
	static C(Other: UObject | any): InterchangeBaseNode;
}

declare type EReimportStrategyFlags = 'ApplyNoProperties' | 'ApplyPipelineProperties' | 'ApplyEditorChangedProperties' | 'EReimportStrategyFlags_MAX';
declare var EReimportStrategyFlags : { ApplyNoProperties:'ApplyNoProperties',ApplyPipelineProperties:'ApplyPipelineProperties',ApplyEditorChangedProperties:'ApplyEditorChangedProperties',EReimportStrategyFlags_MAX:'EReimportStrategyFlags_MAX', };
declare class InterchangeFactoryBaseNode extends InterchangeBaseNode { 
	static Load(ResourceName: string): InterchangeFactoryBaseNode;
	static Find(Outer: UObject, ResourceName: string): InterchangeFactoryBaseNode;
	static GetDefaultObject(): InterchangeFactoryBaseNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeFactoryBaseNode;
	SetReimportStrategyFlags(ReimportStrategyFlags: EReimportStrategyFlags): boolean;
	SetCustomSubPath(AttributeValue: string): boolean;
	SetCustomReferenceObject(AttributeValue: SoftObjectPath): boolean;
	RemoveFactoryDependencyUid(DependencyUid: string): boolean;
	GetReimportStrategyFlags(): EReimportStrategyFlags;
	GetFactoryDependency(Index: number,OutDependency?: string): {OutDependency: string};
	GetFactoryDependenciesCount(): number;
	GetFactoryDependencies(OutDependencies?: string[]): {OutDependencies: string[]};
	GetCustomSubPath(AttributeValue?: string): {AttributeValue: string, $: boolean};
	GetCustomReferenceObject(AttributeValue?: SoftObjectPath): {AttributeValue: SoftObjectPath, $: boolean};
	AddFactoryDependencyUid(DependencyUid: string): boolean;
	static C(Other: UObject | any): InterchangeFactoryBaseNode;
}

declare class InterchangeBaseNodeContainer extends UObject { 
	Nodes: Map<string, InterchangeBaseNode>;
	static Load(ResourceName: string): InterchangeBaseNodeContainer;
	static Find(Outer: UObject, ResourceName: string): InterchangeBaseNodeContainer;
	static GetDefaultObject(): InterchangeBaseNodeContainer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeBaseNodeContainer;
	SetNodeParentUid(NodeUniqueID: string,NewParentNodeUid: string): boolean;
	SaveToFile(Filename: string): void;
	ResetChildrenCache(): void;
	LoadFromFile(Filename: string): void;
	IsNodeUidValid(NodeUniqueID: string): boolean;
	GetRoots(RootNodes?: string[]): {RootNodes: string[]};
	GetNodes(ClassNode: UnrealEngineClass,OutNodes?: string[]): {OutNodes: string[]};
	GetNodeChildrenUids(NodeUniqueID: string): string[];
	GetNodeChildrenCount(NodeUniqueID: string): number;
	GetNodeChildren(NodeUniqueID: string,ChildIndex: number): InterchangeBaseNode;
	GetNode(NodeUniqueID: string): InterchangeBaseNode;
	GetFactoryNode(NodeUniqueID: string): InterchangeFactoryBaseNode;
	ComputeChildrenCache(): void;
	AddNode(UNode: InterchangeBaseNode): string;
	static C(Other: UObject | any): InterchangeBaseNodeContainer;
}

declare type EInterchangePipelineTask = 'PreFactoryImport' | 'PostFactoryImport' | 'Export' | 'EInterchangePipelineTask_MAX';
declare var EInterchangePipelineTask : { PreFactoryImport:'PreFactoryImport',PostFactoryImport:'PostFactoryImport',Export:'Export',EInterchangePipelineTask_MAX:'EInterchangePipelineTask_MAX', };
declare class InterchangePipelineBase extends UObject { 
	Results: InterchangeResultsContainer;
	PropertiesStates: Map<string, InterchangePipelinePropertyStates>;
	static Load(ResourceName: string): InterchangePipelineBase;
	static Find(Outer: UObject, ResourceName: string): InterchangePipelineBase;
	static GetDefaultObject(): InterchangePipelineBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangePipelineBase;
	ScriptedSetReimportSourceIndex(ReimportObjectClass: UnrealEngineClass,SourceFileIndex: number): void;
	ScriptedExecutePreImportPipeline(BaseNodeContainer: InterchangeBaseNodeContainer,SourceDatas: InterchangeSourceData[]): void;
	ScriptedExecutePostImportPipeline(BaseNodeContainer: InterchangeBaseNodeContainer,FactoryNodeKey: string,CreatedAsset: UObject,bIsAReimport: boolean): void;
	ScriptedExecuteExportPipeline(BaseNodeContainer: InterchangeBaseNodeContainer): void;
	ScriptedCanExecuteOnAnyThread(PipelineTask: EInterchangePipelineTask): boolean;
	FindOrAddPropertyStates(PropertyPath: string): InterchangePipelinePropertyStates;
	DoesPropertyStatesExist(PropertyPath: string): boolean;
	static C(Other: UObject | any): InterchangePipelineBase;
}

declare class InterchangeResultSuccess extends InterchangeResult { 
	static Load(ResourceName: string): InterchangeResultSuccess;
	static Find(Outer: UObject, ResourceName: string): InterchangeResultSuccess;
	static GetDefaultObject(): InterchangeResultSuccess;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeResultSuccess;
	static C(Other: UObject | any): InterchangeResultSuccess;
}

declare class InterchangeResultWarning extends InterchangeResult { 
	static Load(ResourceName: string): InterchangeResultWarning;
	static Find(Outer: UObject, ResourceName: string): InterchangeResultWarning;
	static GetDefaultObject(): InterchangeResultWarning;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeResultWarning;
	static C(Other: UObject | any): InterchangeResultWarning;
}

declare class InterchangeResultError extends InterchangeResult { 
	static Load(ResourceName: string): InterchangeResultError;
	static Find(Outer: UObject, ResourceName: string): InterchangeResultError;
	static GetDefaultObject(): InterchangeResultError;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeResultError;
	static C(Other: UObject | any): InterchangeResultError;
}

declare class InterchangeResultWarning_Generic extends InterchangeResultWarning { 
	Text: string;
	static Load(ResourceName: string): InterchangeResultWarning_Generic;
	static Find(Outer: UObject, ResourceName: string): InterchangeResultWarning_Generic;
	static GetDefaultObject(): InterchangeResultWarning_Generic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeResultWarning_Generic;
	static C(Other: UObject | any): InterchangeResultWarning_Generic;
}

declare class InterchangeResultError_Generic extends InterchangeResultError { 
	Text: string;
	static Load(ResourceName: string): InterchangeResultError_Generic;
	static Find(Outer: UObject, ResourceName: string): InterchangeResultError_Generic;
	static GetDefaultObject(): InterchangeResultError_Generic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeResultError_Generic;
	static C(Other: UObject | any): InterchangeResultError_Generic;
}

declare class InterchangeResultError_ReimportFail extends InterchangeResultError { 
	static Load(ResourceName: string): InterchangeResultError_ReimportFail;
	static Find(Outer: UObject, ResourceName: string): InterchangeResultError_ReimportFail;
	static GetDefaultObject(): InterchangeResultError_ReimportFail;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeResultError_ReimportFail;
	static C(Other: UObject | any): InterchangeResultError_ReimportFail;
}

declare class InterchangeTranslatorBase extends UObject { 
	Results: InterchangeResultsContainer;
	SourceData: InterchangeSourceData;
	static Load(ResourceName: string): InterchangeTranslatorBase;
	static Find(Outer: UObject, ResourceName: string): InterchangeTranslatorBase;
	static GetDefaultObject(): InterchangeTranslatorBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeTranslatorBase;
	static C(Other: UObject | any): InterchangeTranslatorBase;
}

declare class InterchangeAnimationAPI extends UObject { 
	static Load(ResourceName: string): InterchangeAnimationAPI;
	static Find(Outer: UObject, ResourceName: string): InterchangeAnimationAPI;
	static GetDefaultObject(): InterchangeAnimationAPI;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeAnimationAPI;
	static SetCustomNodeTransformPayloadKey(InterchangeBaseNode: InterchangeBaseNode,AttributeValue: string): boolean;
	static SetCustomNodeTransformAnimationStartTime(InterchangeBaseNode: InterchangeBaseNode,AttributeValue: number): boolean;
	static SetCustomNodeTransformAnimationKeyCount(InterchangeBaseNode: InterchangeBaseNode,AttributeValue: number): boolean;
	static SetCustomNodeTransformAnimationEndTime(InterchangeBaseNode: InterchangeBaseNode,AttributeValue: number): boolean;
	static SetCustomIsNodeTransformAnimated(InterchangeBaseNode: InterchangeBaseNode,AttributeValue: boolean): boolean;
	static GetCustomNodeTransformPayloadKey(InterchangeBaseNode: InterchangeBaseNode,AttributeValue?: string): {AttributeValue: string, $: boolean};
	static GetCustomNodeTransformAnimationStartTime(InterchangeBaseNode: InterchangeBaseNode,AttributeValue?: number): {AttributeValue: number, $: boolean};
	static GetCustomNodeTransformAnimationKeyCount(InterchangeBaseNode: InterchangeBaseNode,AttributeValue?: number): {AttributeValue: number, $: boolean};
	static GetCustomNodeTransformAnimationEndTime(InterchangeBaseNode: InterchangeBaseNode,AttributeValue?: number): {AttributeValue: number, $: boolean};
	static GetCustomIsNodeTransformAnimated(InterchangeBaseNode: InterchangeBaseNode,AttributeValue?: boolean): {AttributeValue: boolean, $: boolean};
	static C(Other: UObject | any): InterchangeAnimationAPI;
}

declare class InterchangeSourceNode extends InterchangeBaseNode { 
	static Load(ResourceName: string): InterchangeSourceNode;
	static Find(Outer: UObject, ResourceName: string): InterchangeSourceNode;
	static GetDefaultObject(): InterchangeSourceNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeSourceNode;
	SetCustomSourceTimelineStart(AttributeValue: number): boolean;
	SetCustomSourceTimelineEnd(AttributeValue: number): boolean;
	SetCustomSourceFrameRateNumerator(AttributeValue: number): boolean;
	SetCustomSourceFrameRateDenominator(AttributeValue: number): boolean;
	SetCustomImportUnusedMaterial(AttributeValue: boolean): boolean;
	SetCustomAnimatedTimeStart(AttributeValue: number): boolean;
	SetCustomAnimatedTimeEnd(AttributeValue: number): boolean;
	InitializeSourceNode(UniqueId: string,DisplayLabel: string): void;
	GetCustomSourceTimelineStart(AttributeValue?: number): {AttributeValue: number, $: boolean};
	GetCustomSourceTimelineEnd(AttributeValue?: number): {AttributeValue: number, $: boolean};
	GetCustomSourceFrameRateNumerator(AttributeValue?: number): {AttributeValue: number, $: boolean};
	GetCustomSourceFrameRateDenominator(AttributeValue?: number): {AttributeValue: number, $: boolean};
	GetCustomImportUnusedMaterial(AttributeValue?: boolean): {AttributeValue: boolean, $: boolean};
	GetCustomAnimatedTimeStart(AttributeValue?: number): {AttributeValue: number, $: boolean};
	GetCustomAnimatedTimeEnd(AttributeValue?: number): {AttributeValue: number, $: boolean};
	static C(Other: UObject | any): InterchangeSourceNode;
}

declare class InterchangeUserDefinedAttributeInfo { 
	Name: string;
	clone() : InterchangeUserDefinedAttributeInfo;
	static C(Other: UObject | any): InterchangeUserDefinedAttributeInfo;
}

declare class InterchangeUserDefinedAttributesAPI extends UObject { 
	static Load(ResourceName: string): InterchangeUserDefinedAttributesAPI;
	static Find(Outer: UObject, ResourceName: string): InterchangeUserDefinedAttributesAPI;
	static GetDefaultObject(): InterchangeUserDefinedAttributesAPI;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeUserDefinedAttributesAPI;
	static RemoveUserDefinedAttribute(InterchangeNode: InterchangeBaseNode,UserDefinedAttributeName: string): boolean;
	static GetUserDefinedAttributeInfos(InterchangeNode: InterchangeBaseNode,UserDefinedAttributeInfos?: InterchangeUserDefinedAttributeInfo[]): {UserDefinedAttributeInfos: InterchangeUserDefinedAttributeInfo[]};
	static GetUserDefinedAttribute_Int32(InterchangeNode: InterchangeBaseNode,UserDefinedAttributeName: string,OutValue?: number,OutPayloadKey?: string): {OutValue: number, OutPayloadKey: string, $: boolean};
	static GetUserDefinedAttribute_FString(InterchangeNode: InterchangeBaseNode,UserDefinedAttributeName: string,OutValue?: string,OutPayloadKey?: string): {OutValue: string, OutPayloadKey: string, $: boolean};
	static GetUserDefinedAttribute_Float(InterchangeNode: InterchangeBaseNode,UserDefinedAttributeName: string,OutValue?: number,OutPayloadKey?: string): {OutValue: number, OutPayloadKey: string, $: boolean};
	static GetUserDefinedAttribute_Double(InterchangeNode: InterchangeBaseNode,UserDefinedAttributeName: string,OutValue?: number,OutPayloadKey?: string): {OutValue: number, OutPayloadKey: string, $: boolean};
	static GetUserDefinedAttribute_Boolean(InterchangeNode: InterchangeBaseNode,UserDefinedAttributeName: string,OutValue?: boolean,OutPayloadKey?: string): {OutValue: boolean, OutPayloadKey: string, $: boolean};
	static DuplicateAllUserDefinedAttribute(InterchangeSourceNode: InterchangeBaseNode,InterchangeDestinationNode: InterchangeBaseNode,bAddSourceNodeName: boolean): void;
	static CreateUserDefinedAttribute_Int32(InterchangeNode: InterchangeBaseNode,UserDefinedAttributeName: string,Value: number,PayloadKey: string): boolean;
	static CreateUserDefinedAttribute_FString(InterchangeNode: InterchangeBaseNode,UserDefinedAttributeName: string,Value: string,PayloadKey: string): boolean;
	static CreateUserDefinedAttribute_Float(InterchangeNode: InterchangeBaseNode,UserDefinedAttributeName: string,Value: number,PayloadKey: string): boolean;
	static CreateUserDefinedAttribute_Double(InterchangeNode: InterchangeBaseNode,UserDefinedAttributeName: string,Value: number,PayloadKey: string): boolean;
	static CreateUserDefinedAttribute_Boolean(InterchangeNode: InterchangeBaseNode,UserDefinedAttributeName: string,Value: boolean,PayloadKey: string): boolean;
	static C(Other: UObject | any): InterchangeUserDefinedAttributesAPI;
}

declare class ClothConfigBase extends UObject { 
	static Load(ResourceName: string): ClothConfigBase;
	static Find(Outer: UObject, ResourceName: string): ClothConfigBase;
	static GetDefaultObject(): ClothConfigBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothConfigBase;
	static C(Other: UObject | any): ClothConfigBase;
}

declare class ClothSharedSimConfigBase extends UObject { 
	static Load(ResourceName: string): ClothSharedSimConfigBase;
	static Find(Outer: UObject, ResourceName: string): ClothSharedSimConfigBase;
	static GetDefaultObject(): ClothSharedSimConfigBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothSharedSimConfigBase;
	static C(Other: UObject | any): ClothSharedSimConfigBase;
}

declare class ClothVertBoneData { 
	NumInfluences: number;
	BoneIndices: number;
	BoneWeights: number;
	clone() : ClothVertBoneData;
	static C(Other: UObject | any): ClothVertBoneData;
}

declare class ClothPhysicalMeshDataBase_Legacy extends UObject { 
	Vertices: Vector3f[];
	Normals: Vector3f[];
	VertexColors: Color[];
	Indices: number[];
	InverseMasses: number[];
	BoneData: ClothVertBoneData[];
	NumFixedVerts: number;
	MaxBoneWeights: number;
	SelfCollisionIndices: number[];
	static Load(ResourceName: string): ClothPhysicalMeshDataBase_Legacy;
	static Find(Outer: UObject, ResourceName: string): ClothPhysicalMeshDataBase_Legacy;
	static GetDefaultObject(): ClothPhysicalMeshDataBase_Legacy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothPhysicalMeshDataBase_Legacy;
	static C(Other: UObject | any): ClothPhysicalMeshDataBase_Legacy;
}

declare class ClothConfigCommon extends ClothConfigBase { 
	static Load(ResourceName: string): ClothConfigCommon;
	static Find(Outer: UObject, ResourceName: string): ClothConfigCommon;
	static GetDefaultObject(): ClothConfigCommon;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothConfigCommon;
	static C(Other: UObject | any): ClothConfigCommon;
}

declare class ClothSharedConfigCommon extends ClothConfigCommon { 
	static Load(ResourceName: string): ClothSharedConfigCommon;
	static Find(Outer: UObject, ResourceName: string): ClothSharedConfigCommon;
	static GetDefaultObject(): ClothSharedConfigCommon;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothSharedConfigCommon;
	static C(Other: UObject | any): ClothSharedConfigCommon;
}

declare class ClothingAssetCustomData extends UObject { 
	static Load(ResourceName: string): ClothingAssetCustomData;
	static Find(Outer: UObject, ResourceName: string): ClothingAssetCustomData;
	static GetDefaultObject(): ClothingAssetCustomData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothingAssetCustomData;
	static C(Other: UObject | any): ClothingAssetCustomData;
}

declare class PointWeightMap { 
	Values: number[];
	Name: string;
	CurrentTarget: number;
	bEnabled: boolean;
	clone() : PointWeightMap;
	static C(Other: UObject | any): PointWeightMap;
}

declare class ClothTetherData { 
	clone() : ClothTetherData;
	static C(Other: UObject | any): ClothTetherData;
}

declare class ClothPhysicalMeshData { 
	Vertices: Vector3f[];
	Normals: Vector3f[];
	VertexColors: Color[];
	Indices: number[];
	WeightMaps: Map<number, PointWeightMap>;
	InverseMasses: number[];
	BoneData: ClothVertBoneData[];
	SelfCollisionIndices: number[];
	EuclideanTethers: ClothTetherData;
	GeodesicTethers: ClothTetherData;
	MaxBoneWeights: number;
	NumFixedVerts: number;
	MaxDistances: number[];
	BackstopDistances: number[];
	BackstopRadiuses: number[];
	AnimDriveMultipliers: number[];
	clone() : ClothPhysicalMeshData;
	static C(Other: UObject | any): ClothPhysicalMeshData;
}

declare class ClothCollisionPrim_Sphere { 
	BoneIndex: number;
	Radius: number;
	LocalPosition: Vector;
	clone() : ClothCollisionPrim_Sphere;
	static C(Other: UObject | any): ClothCollisionPrim_Sphere;
}

declare class ClothCollisionPrim_SphereConnection { 
	SphereIndices: number;
	clone() : ClothCollisionPrim_SphereConnection;
	static C(Other: UObject | any): ClothCollisionPrim_SphereConnection;
}

declare class ClothCollisionPrim_ConvexFace { 
	Plane: Plane;
	Indices: number[];
	clone() : ClothCollisionPrim_ConvexFace;
	static C(Other: UObject | any): ClothCollisionPrim_ConvexFace;
}

declare class ClothCollisionPrim_Convex { 
	planes: Plane[];
	Faces: ClothCollisionPrim_ConvexFace[];
	SurfacePoints: Vector[];
	BoneIndex: number;
	clone() : ClothCollisionPrim_Convex;
	static C(Other: UObject | any): ClothCollisionPrim_Convex;
}

declare class ClothCollisionPrim_Box { 
	LocalPosition: Vector;
	LocalRotation: Quat;
	HalfExtents: Vector;
	BoneIndex: number;
	clone() : ClothCollisionPrim_Box;
	static C(Other: UObject | any): ClothCollisionPrim_Box;
}

declare class ClothCollisionData { 
	Spheres: ClothCollisionPrim_Sphere[];
	SphereConnections: ClothCollisionPrim_SphereConnection[];
	Convexes: ClothCollisionPrim_Convex[];
	Boxes: ClothCollisionPrim_Box[];
	clone() : ClothCollisionData;
	static C(Other: UObject | any): ClothCollisionData;
}

declare class ClothLODDataCommon_Legacy extends UObject { 
	PhysicalMeshData: ClothPhysicalMeshDataBase_Legacy;
	ClothPhysicalMeshData: ClothPhysicalMeshData;
	CollisionData: ClothCollisionData;
	ParameterMasks: PointWeightMap[];
	static Load(ResourceName: string): ClothLODDataCommon_Legacy;
	static Find(Outer: UObject, ResourceName: string): ClothLODDataCommon_Legacy;
	static GetDefaultObject(): ClothLODDataCommon_Legacy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothLODDataCommon_Legacy;
	static C(Other: UObject | any): ClothLODDataCommon_Legacy;
}

declare type EWeightMapTargetCommon = 'None' | 'MaxDistance' | 'BackstopDistance' | 'BackstopRadius' | 'AnimDriveStiffness' | 'AnimDriveDamping_DEPRECATED' | 'EWeightMapTargetCommon_MAX';
declare var EWeightMapTargetCommon : { None:'None',MaxDistance:'MaxDistance',BackstopDistance:'BackstopDistance',BackstopRadius:'BackstopRadius',AnimDriveStiffness:'AnimDriveStiffness',AnimDriveDamping_DEPRECATED:'AnimDriveDamping_DEPRECATED',EWeightMapTargetCommon_MAX:'EWeightMapTargetCommon_MAX', };
declare class ClothParameterMask_Legacy { 
	MaskName: string;
	CurrentTarget: EWeightMapTargetCommon;
	MaxValue: number;
	MinValue: number;
	Values: number[];
	bEnabled: boolean;
	clone() : ClothParameterMask_Legacy;
	static C(Other: UObject | any): ClothParameterMask_Legacy;
}

declare class ClothLODDataCommon { 
	PhysicalMeshData: ClothPhysicalMeshData;
	CollisionData: ClothCollisionData;
	bUseMultipleInfluences: boolean;
	SkinningKernelRadius: number;
	bSmoothTransition: boolean;
	ParameterMasks: ClothParameterMask_Legacy[];
	PointWeightMaps: PointWeightMap[];
	clone() : ClothLODDataCommon;
	static C(Other: UObject | any): ClothLODDataCommon;
}

declare type EClothingWindMethod_Legacy = 'Legacy' | 'Accurate' | 'EClothingWindMethod_MAX';
declare var EClothingWindMethod_Legacy : { Legacy:'Legacy',Accurate:'Accurate',EClothingWindMethod_MAX:'EClothingWindMethod_MAX', };
declare class ClothConstraintSetup_Legacy { 
	Stiffness: number;
	StiffnessMultiplier: number;
	StretchLimit: number;
	CompressionLimit: number;
	clone() : ClothConstraintSetup_Legacy;
	static C(Other: UObject | any): ClothConstraintSetup_Legacy;
}

declare class ClothConfig_Legacy { 
	WindMethod: EClothingWindMethod_Legacy;
	VerticalConstraintConfig: ClothConstraintSetup_Legacy;
	HorizontalConstraintConfig: ClothConstraintSetup_Legacy;
	BendConstraintConfig: ClothConstraintSetup_Legacy;
	ShearConstraintConfig: ClothConstraintSetup_Legacy;
	SelfCollisionRadius: number;
	SelfCollisionStiffness: number;
	SelfCollisionCullScale: number;
	Damping: Vector;
	Friction: number;
	WindDragCoefficient: number;
	WindLiftCoefficient: number;
	LinearDrag: Vector;
	AngularDrag: Vector;
	LinearInertiaScale: Vector;
	AngularInertiaScale: Vector;
	CentrifugalInertiaScale: Vector;
	SolverFrequency: number;
	StiffnessFrequency: number;
	GravityScale: number;
	GravityOverride: Vector;
	bUseGravityOverride: boolean;
	TetherStiffness: number;
	TetherLimit: number;
	CollisionThickness: number;
	AnimDriveSpringStiffness: number;
	AnimDriveDamperStiffness: number;
	clone() : ClothConfig_Legacy;
	static C(Other: UObject | any): ClothConfig_Legacy;
}

declare class ClothingAssetCommon extends ClothingAssetBase { 
	PhysicsAsset: PhysicsAsset;
	ClothConfigs: Map<string, ClothConfigBase>;
	ClothSharedSimConfig: ClothConfigBase;
	ClothSimConfig: ClothConfigBase;
	ChaosClothSimConfig: ClothConfigBase;
	ClothLODData: ClothLODDataCommon_Legacy[];
	LODData: ClothLODDataCommon[];
	LodMap: number[];
	UsedBoneNames: string[];
	UsedBoneIndices: number[];
	ReferenceBoneIndex: number;
	CustomData: ClothingAssetCustomData;
	ClothConfig: ClothConfig_Legacy;
	static Load(ResourceName: string): ClothingAssetCommon;
	static Find(Outer: UObject, ResourceName: string): ClothingAssetCommon;
	static GetDefaultObject(): ClothingAssetCommon;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothingAssetCommon;
	static C(Other: UObject | any): ClothingAssetCommon;
}

declare class InterchangeAssetImportData extends AssetImportData { 
	NodeContainer: InterchangeBaseNodeContainer;
	NodeUniqueID: string;
	Pipelines: UObject[];
	static Load(ResourceName: string): InterchangeAssetImportData;
	static Find(Outer: UObject, ResourceName: string): InterchangeAssetImportData;
	static GetDefaultObject(): InterchangeAssetImportData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeAssetImportData;
	ScriptGetFirstFilename(): string;
	ScriptExtractFilenames(): string[];
	ScriptExtractDisplayLabels(): string[];
	static C(Other: UObject | any): InterchangeAssetImportData;
}

declare class InterchangeBlueprintPipelineBase extends Blueprint { 
	static Load(ResourceName: string): InterchangeBlueprintPipelineBase;
	static Find(Outer: UObject, ResourceName: string): InterchangeBlueprintPipelineBase;
	static GetDefaultObject(): InterchangeBlueprintPipelineBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeBlueprintPipelineBase;
	static C(Other: UObject | any): InterchangeBlueprintPipelineBase;
}

declare type EInterchangeTranslatorType = 'Invalid' | 'Assets' | 'Actors' | 'Scenes' | 'EInterchangeTranslatorType_MAX';
declare var EInterchangeTranslatorType : { Invalid:'Invalid',Assets:'Assets',Actors:'Actors',Scenes:'Scenes',EInterchangeTranslatorType_MAX:'EInterchangeTranslatorType_MAX', };
declare class InterchangeFilePickerParameters { 
	bAllowMultipleFiles: boolean;
	Title: string;
	DefaultPath: string;
	clone() : InterchangeFilePickerParameters;
	static C(Other: UObject | any): InterchangeFilePickerParameters;
}

declare type EInterchangeTranslatorAssetType = 'None' | 'Textures' | 'Materials' | 'Meshes' | 'Animations' | 'EInterchangeTranslatorAssetType_MAX';
declare var EInterchangeTranslatorAssetType : { None:'None',Textures:'Textures',Materials:'Materials',Meshes:'Meshes',Animations:'Animations',EInterchangeTranslatorAssetType_MAX:'EInterchangeTranslatorAssetType_MAX', };
declare class InterchangeFilePickerBase extends UObject { 
	static Load(ResourceName: string): InterchangeFilePickerBase;
	static Find(Outer: UObject, ResourceName: string): InterchangeFilePickerBase;
	static GetDefaultObject(): InterchangeFilePickerBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeFilePickerBase;
	ScriptedFilePickerForTranslatorType(TranslatorType: EInterchangeTranslatorType,Parameters?: InterchangeFilePickerParameters,OutFilenames?: string[]): {Parameters: InterchangeFilePickerParameters, OutFilenames: string[], $: boolean};
	ScriptedFilePickerForTranslatorAssetType(TranslatorAssetType: EInterchangeTranslatorAssetType,Parameters?: InterchangeFilePickerParameters,OutFilenames?: string[]): {Parameters: InterchangeFilePickerParameters, OutFilenames: string[], $: boolean};
	static C(Other: UObject | any): InterchangeFilePickerBase;
}

declare type EInterchangePipelineConfigurationDialogResult = 'Cancel' | 'Import' | 'ImportAll' | 'EInterchangePipelineConfigurationDialogResult_MAX';
declare var EInterchangePipelineConfigurationDialogResult : { Cancel:'Cancel',Import:'Import',ImportAll:'ImportAll',EInterchangePipelineConfigurationDialogResult_MAX:'EInterchangePipelineConfigurationDialogResult_MAX', };
declare class InterchangePipelineConfigurationBase extends UObject { 
	static Load(ResourceName: string): InterchangePipelineConfigurationBase;
	static Find(Outer: UObject, ResourceName: string): InterchangePipelineConfigurationBase;
	static GetDefaultObject(): InterchangePipelineConfigurationBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangePipelineConfigurationBase;
	ScriptedShowScenePipelineConfigurationDialog(SourceData: InterchangeSourceData): EInterchangePipelineConfigurationDialogResult;
	ScriptedShowReimportPipelineConfigurationDialog(PipelineStack?: InterchangePipelineBase[],SourceData?: InterchangeSourceData): {PipelineStack: InterchangePipelineBase[], $: EInterchangePipelineConfigurationDialogResult};
	ScriptedShowPipelineConfigurationDialog(SourceData: InterchangeSourceData): EInterchangePipelineConfigurationDialogResult;
	static C(Other: UObject | any): InterchangePipelineConfigurationBase;
}

declare class InterchangePipelineStack { 
	Pipelines: SoftObjectPath[];
	clone() : InterchangePipelineStack;
	static C(Other: UObject | any): InterchangePipelineStack;
}

declare class InterchangeImportSettings { 
	PipelineStacks: Map<string, InterchangePipelineStack>;
	DefaultPipelineStack: string;
	PipelineConfigurationDialogClass: Class;
	bShowPipelineStacksConfigurationDialog: boolean;
	clone() : InterchangeImportSettings;
	static C(Other: UObject | any): InterchangeImportSettings;
}

declare class InterchangeContentImportSettings extends InterchangeImportSettings { 
	DefaultPipelineStackOverride: Map<EInterchangeTranslatorAssetType, string>;
	ShowPipelineStacksConfigurationDialogOverride: Map<EInterchangeTranslatorAssetType, boolean>;
	clone() : InterchangeContentImportSettings;
	static C(Other: UObject | any): InterchangeContentImportSettings;
}

declare class InterchangeProjectSettings extends DeveloperSettings { 
	ContentImportSettings: InterchangeContentImportSettings;
	SceneImportSettings: InterchangeImportSettings;
	FilePickerClass: Class;
	bStaticMeshUseSmoothEdgesIfSmoothingInformationIsMissing: boolean;
	GenericPipelineClass: Class;
	static Load(ResourceName: string): InterchangeProjectSettings;
	static Find(Outer: UObject, ResourceName: string): InterchangeProjectSettings;
	static GetDefaultObject(): InterchangeProjectSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeProjectSettings;
	static C(Other: UObject | any): InterchangeProjectSettings;
}

declare class InterchangePythonPipelineBase extends InterchangePipelineBase { 
	static Load(ResourceName: string): InterchangePythonPipelineBase;
	static Find(Outer: UObject, ResourceName: string): InterchangePythonPipelineBase;
	static GetDefaultObject(): InterchangePythonPipelineBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangePythonPipelineBase;
	static C(Other: UObject | any): InterchangePythonPipelineBase;
}

declare class InterchangePythonPipelineAsset extends UObject { 
	PythonClass: Class;
	GeneratedPipeline: InterchangePythonPipelineBase;
	JsonDefaultProperties: string;
	static Load(ResourceName: string): InterchangePythonPipelineAsset;
	static Find(Outer: UObject, ResourceName: string): InterchangePythonPipelineAsset;
	static GetDefaultObject(): InterchangePythonPipelineAsset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangePythonPipelineAsset;
	static C(Other: UObject | any): InterchangePythonPipelineAsset;
}

declare class ImportAssetParameters { 
	ReimportAsset: UObject;
	ReimportSourceIndex: number;
	bIsAutomated: boolean;
	OverridePipelines: InterchangePipelineBase[];
	OnAssetDone: UnrealEngineDelegate<(UObject: UObject) => void>;
	OnAssetsImportDone: UnrealEngineDelegate<(Objects: UObject[]) => void>;
	OnSceneObjectDone: UnrealEngineDelegate<(UObject: UObject) => void>;
	OnSceneImportDone: UnrealEngineDelegate<(Objects: UObject[]) => void>;
	clone() : ImportAssetParameters;
	static C(Other: UObject | any): ImportAssetParameters;
}

declare class InterchangeManager extends UObject { 
	RegisteredTranslatorsClass: Set<UnrealEngineClass>;
	RegisteredFactoryClasses: Map<UnrealEngineClass, UnrealEngineClass>;
	RegisteredWriters: Map<UnrealEngineClass, InterchangeWriterBase>;
	static Load(ResourceName: string): InterchangeManager;
	static Find(Outer: UObject, ResourceName: string): InterchangeManager;
	static GetDefaultObject(): InterchangeManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeManager;
	ImportScene(ContentPath: string,SourceData: InterchangeSourceData,ImportAssetParameters: ImportAssetParameters): boolean;
	ImportAsset(ContentPath: string,SourceData: InterchangeSourceData,ImportAssetParameters: ImportAssetParameters): boolean;
	GetRegisteredFactoryClass(ClassToMake: UnrealEngineClass): UnrealEngineClass;
	static GetInterchangeManagerScripted(): InterchangeManager;
	ExportScene(World: UObject,bIsAutomated: boolean): boolean;
	ExportAsset(Asset: UObject,bIsAutomated: boolean): boolean;
	static CreateSourceData(InFilename: string): InterchangeSourceData;
	static C(Other: UObject | any): InterchangeManager;
}

declare class InterchangeMeshUtilities extends UObject { 
	static Load(ResourceName: string): InterchangeMeshUtilities;
	static Find(Outer: UObject, ResourceName: string): InterchangeMeshUtilities;
	static GetDefaultObject(): InterchangeMeshUtilities;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeMeshUtilities;
	static C(Other: UObject | any): InterchangeMeshUtilities;
}

declare class PropertyEntry { 
	Property: EMaterialProperty;
	bUseCustomSize: boolean;
	CustomSize: IntPoint;
	bUseConstantValue: boolean;
	ConstantValue: number;
	clone() : PropertyEntry;
	static C(Other: UObject | any): PropertyEntry;
}

declare class MaterialOptions extends UObject { 
	Properties: PropertyEntry[];
	TextureSize: IntPoint;
	LODIndices: number[];
	bUseMeshData: boolean;
	bUseSpecificUVIndex: boolean;
	TextureCoordinateIndex: number;
	static Load(ResourceName: string): MaterialOptions;
	static Find(Outer: UObject, ResourceName: string): MaterialOptions;
	static GetDefaultObject(): MaterialOptions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialOptions;
	static C(Other: UObject | any): MaterialOptions;
}

declare class AssetBakeOptions extends UObject { 
	static Load(ResourceName: string): AssetBakeOptions;
	static Find(Outer: UObject, ResourceName: string): AssetBakeOptions;
	static GetDefaultObject(): AssetBakeOptions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetBakeOptions;
	static C(Other: UObject | any): AssetBakeOptions;
}

declare type EMaterialBakeMethod = 'IndividualMaterial' | 'AtlasMaterial' | 'BinnedMaterial' | 'EMaterialBakeMethod_MAX';
declare var EMaterialBakeMethod : { IndividualMaterial:'IndividualMaterial',AtlasMaterial:'AtlasMaterial',BinnedMaterial:'BinnedMaterial',EMaterialBakeMethod_MAX:'EMaterialBakeMethod_MAX', };
declare class MaterialMergeOptions extends UObject { 
	Method: EMaterialBakeMethod;
	BlendMode: EBlendMode;
	static Load(ResourceName: string): MaterialMergeOptions;
	static Find(Outer: UObject, ResourceName: string): MaterialMergeOptions;
	static GetDefaultObject(): MaterialMergeOptions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialMergeOptions;
	static C(Other: UObject | any): MaterialMergeOptions;
}

declare class PreviewSceneProfile { 
	ProfileName: string;
	bSharedProfile: boolean;
	bUseSkyLighting: boolean;
	DirectionalLightIntensity: number;
	DirectionalLightColor: LinearColor;
	SkyLightIntensity: number;
	bRotateLightingRig: boolean;
	bShowEnvironment: boolean;
	bShowFloor: boolean;
	EnvironmentColor: LinearColor;
	EnvironmentIntensity: number;
	EnvironmentCubeMap: TextureCube;
	EnvironmentCubeMapPath: string;
	bPostProcessingEnabled: boolean;
	PostProcessingSettings: PostProcessSettings;
	LightingRigRotation: number;
	RotationSpeed: number;
	DirectionalLightRotation: Rotator;
	clone() : PreviewSceneProfile;
	static C(Other: UObject | any): PreviewSceneProfile;
}

declare class LocalProfiles extends UObject { 
	Profiles: PreviewSceneProfile[];
	static Load(ResourceName: string): LocalProfiles;
	static Find(Outer: UObject, ResourceName: string): LocalProfiles;
	static GetDefaultObject(): LocalProfiles;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalProfiles;
	static C(Other: UObject | any): LocalProfiles;
}

declare class SharedProfiles extends UObject { 
	Profiles: PreviewSceneProfile[];
	static Load(ResourceName: string): SharedProfiles;
	static Find(Outer: UObject, ResourceName: string): SharedProfiles;
	static GetDefaultObject(): SharedProfiles;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SharedProfiles;
	static C(Other: UObject | any): SharedProfiles;
}

declare class AssetViewerSettings extends UObject { 
	Profiles: PreviewSceneProfile[];
	bFakeConfigValue_HACK: boolean;
	static Load(ResourceName: string): AssetViewerSettings;
	static Find(Outer: UObject, ResourceName: string): AssetViewerSettings;
	static GetDefaultObject(): AssetViewerSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetViewerSettings;
	static C(Other: UObject | any): AssetViewerSettings;
}

declare class MaterialInstanceConstant extends MaterialInstance { 
	ParameterStateId: Guid;
	PhysMaterialMask: PhysicalMaterialMask;
	static Load(ResourceName: string): MaterialInstanceConstant;
	static Find(Outer: UObject, ResourceName: string): MaterialInstanceConstant;
	static GetDefaultObject(): MaterialInstanceConstant;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialInstanceConstant;
	SetNaniteOverrideMaterial(bInEnableOverride: boolean,InOverrideMaterial: MaterialInterface): void;
	K2_GetVectorParameterValue(ParameterName: string): LinearColor;
	K2_GetTextureParameterValue(ParameterName: string): Texture;
	K2_GetScalarParameterValue(ParameterName: string): number;
	static C(Other: UObject | any): MaterialInstanceConstant;
	ClearAllMaterialInstanceParameters(): void;
	GetMaterialInstanceRuntimeVirtualTextureParameterValue(ParameterName: string,Association: EMaterialParameterAssociation): RuntimeVirtualTexture;
	GetMaterialInstanceScalarParameterValue(ParameterName: string,Association: EMaterialParameterAssociation): number;
	GetMaterialInstanceStaticSwitchParameterValue(ParameterName: string,Association: EMaterialParameterAssociation): boolean;
	GetMaterialInstanceTextureParameterValue(ParameterName: string,Association: EMaterialParameterAssociation): Texture;
	GetMaterialInstanceVectorParameterValue(ParameterName: string,Association: EMaterialParameterAssociation): LinearColor;
	SetMaterialInstanceParent(NewParent: MaterialInterface): void;
	SetMaterialInstanceRuntimeVirtualTextureParameterValue(ParameterName: string,Value: RuntimeVirtualTexture,Association: EMaterialParameterAssociation): boolean;
	SetMaterialInstanceScalarParameterValue(ParameterName: string,Value: number,Association: EMaterialParameterAssociation): boolean;
	SetMaterialInstanceStaticSwitchParameterValue(ParameterName: string,Value: boolean,Association: EMaterialParameterAssociation): boolean;
	SetMaterialInstanceTextureParameterValue(ParameterName: string,Value: Texture,Association: EMaterialParameterAssociation): boolean;
	SetMaterialInstanceVectorParameterValue(ParameterName: string,Value: LinearColor,Association: EMaterialParameterAssociation): boolean;
	UpdateMaterialInstance(): void;
	static ClearAllMaterialInstanceParameters(Instance: MaterialInstanceConstant): void;
	static GetMaterialInstanceRuntimeVirtualTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): RuntimeVirtualTexture;
	static GetMaterialInstanceScalarParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): number;
	static GetMaterialInstanceStaticSwitchParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): boolean;
	static GetMaterialInstanceTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): Texture;
	static GetMaterialInstanceVectorParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): LinearColor;
	static SetMaterialInstanceParent(Instance: MaterialInstanceConstant,NewParent: MaterialInterface): void;
	static SetMaterialInstanceRuntimeVirtualTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: RuntimeVirtualTexture,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceScalarParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: number,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceStaticSwitchParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: boolean,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: Texture,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceVectorParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: LinearColor,Association: EMaterialParameterAssociation): boolean;
	static UpdateMaterialInstance(Instance: MaterialInstanceConstant): void;
}

declare class MaterialEditingLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): MaterialEditingLibrary;
	static Find(Outer: UObject, ResourceName: string): MaterialEditingLibrary;
	static GetDefaultObject(): MaterialEditingLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialEditingLibrary;
	static UpdateMaterialInstance(Instance: MaterialInstanceConstant): void;
	static UpdateMaterialFunction(MaterialFunction: MaterialFunctionInterface,PreviewMaterial: Material): void;
	static SetMaterialUsage(Material: Material,Usage: EMaterialUsage,bNeedsRecompile?: boolean): {bNeedsRecompile: boolean, $: boolean};
	static SetMaterialInstanceVectorParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: LinearColor,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: Texture,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceStaticSwitchParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: boolean,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceScalarParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: number,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceRuntimeVirtualTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: RuntimeVirtualTexture,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceParent(Instance: MaterialInstanceConstant,NewParent: MaterialInterface): void;
	static RecompileMaterial(Material: Material): void;
	static LayoutMaterialFunctionExpressions(MaterialFunction: MaterialFunction): void;
	static LayoutMaterialExpressions(Material: Material): void;
	static HasMaterialUsage(Material: Material,Usage: EMaterialUsage): boolean;
	static GetVectorParameterSource(Material: MaterialInterface,ParameterName: string,ParameterSource?: SoftObjectPath): {ParameterSource: SoftObjectPath, $: boolean};
	static GetVectorParameterNames(Material: MaterialInterface,ParameterNames?: string[]): {ParameterNames: string[]};
	static GetUsedTextures(Material: Material): Texture[];
	static GetTextureParameterSource(Material: MaterialInterface,ParameterName: string,ParameterSource?: SoftObjectPath): {ParameterSource: SoftObjectPath, $: boolean};
	static GetTextureParameterNames(Material: MaterialInterface,ParameterNames?: string[]): {ParameterNames: string[]};
	static GetStatistics(Material: MaterialInterface): MaterialStatistics;
	static GetStaticSwitchParameterSource(Material: MaterialInterface,ParameterName: string,ParameterSource?: SoftObjectPath): {ParameterSource: SoftObjectPath, $: boolean};
	static GetStaticSwitchParameterNames(Material: MaterialInterface,ParameterNames?: string[]): {ParameterNames: string[]};
	static GetScalarParameterSource(Material: MaterialInterface,ParameterName: string,ParameterSource?: SoftObjectPath): {ParameterSource: SoftObjectPath, $: boolean};
	static GetScalarParameterNames(Material: MaterialInterface,ParameterNames?: string[]): {ParameterNames: string[]};
	static GetNumMaterialExpressionsInFunction(MaterialFunction: MaterialFunction): number;
	static GetNumMaterialExpressions(Material: Material): number;
	static GetMaterialSelectedNodes(Material: Material): Set<UObject>;
	static GetMaterialPropertyInputNodeOutputName(Material: Material,Property: EMaterialProperty): string;
	static GetMaterialPropertyInputNode(Material: Material,Property: EMaterialProperty): MaterialExpression;
	static GetMaterialInstanceVectorParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): LinearColor;
	static GetMaterialInstanceTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): Texture;
	static GetMaterialInstanceStaticSwitchParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): boolean;
	static GetMaterialInstanceScalarParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): number;
	static GetMaterialInstanceRuntimeVirtualTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): RuntimeVirtualTexture;
	static GetMaterialExpressionNodePosition(MaterialExpression: MaterialExpression,NodePosX?: number,NodePosY?: number): {NodePosX: number, NodePosY: number};
	static GetMaterialDefaultVectorParameterValue(Material: Material,ParameterName: string): LinearColor;
	static GetMaterialDefaultTextureParameterValue(Material: Material,ParameterName: string): Texture;
	static GetMaterialDefaultStaticSwitchParameterValue(Material: Material,ParameterName: string): boolean;
	static GetMaterialDefaultScalarParameterValue(Material: Material,ParameterName: string): number;
	static GetInputsForMaterialExpression(Material: Material,MaterialExpression: MaterialExpression): MaterialExpression[];
	static GetInputNodeOutputNameForMaterialExpression(MaterialExpression: MaterialExpression,InputNode: MaterialExpression,OutputName?: string): {OutputName: string, $: boolean};
	static GetChildInstances(Parent: MaterialInterface,ChildInstances?: AssetData[]): {ChildInstances: AssetData[]};
	static DuplicateMaterialExpression(Material: Material,MaterialFunction: MaterialFunction,Expression: MaterialExpression): MaterialExpression;
	static DeleteMaterialExpressionInFunction(MaterialFunction: MaterialFunction,Expression: MaterialExpression): void;
	static DeleteMaterialExpression(Material: Material,Expression: MaterialExpression): void;
	static DeleteAllMaterialExpressionsInFunction(MaterialFunction: MaterialFunction): void;
	static DeleteAllMaterialExpressions(Material: Material): void;
	static CreateMaterialExpressionInFunction(MaterialFunction: MaterialFunction,ExpressionClass: UnrealEngineClass,NodePosX: number,NodePosY: number): MaterialExpression;
	static CreateMaterialExpression(Material: Material,ExpressionClass: UnrealEngineClass,NodePosX: number,NodePosY: number): MaterialExpression;
	static ConnectMaterialProperty(FromExpression: MaterialExpression,FromOutputName: string,Property: EMaterialProperty): boolean;
	static ConnectMaterialExpressions(FromExpression: MaterialExpression,FromOutputName: string,ToExpression: MaterialExpression,ToInputName: string): boolean;
	static ClearAllMaterialInstanceParameters(Instance: MaterialInstanceConstant): void;
	static C(Other: UObject | any): MaterialEditingLibrary;
}

declare class MaterialEditorMenuContext extends UObject { 
	static Load(ResourceName: string): MaterialEditorMenuContext;
	static Find(Outer: UObject, ResourceName: string): MaterialEditorMenuContext;
	static GetDefaultObject(): MaterialEditorMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialEditorMenuContext;
	static C(Other: UObject | any): MaterialEditorMenuContext;
}

declare type EBackgroundType = 'SolidColor' | 'Checkered' | 'EBackgroundType_MAX';
declare var EBackgroundType : { SolidColor:'SolidColor',Checkered:'Checkered',EBackgroundType_MAX:'EBackgroundType_MAX', };
declare class CheckerboardSettings { 
	ColorOne: Color;
	ColorTwo: Color;
	Size: number;
	clone() : CheckerboardSettings;
	static C(Other: UObject | any): CheckerboardSettings;
}

declare class PreviewBackgroundSettings { 
	bShowBorder: boolean;
	BorderColor: Color;
	BackgroundType: EBackgroundType;
	BackgroundColor: Color;
	Checkerboard: CheckerboardSettings;
	clone() : PreviewBackgroundSettings;
	static C(Other: UObject | any): PreviewBackgroundSettings;
}

declare class MaterialEditorSettings extends UObject { 
	MaliOfflineCompilerPath: FilePath;
	DefaultPreviewWidth: number;
	DefaultPreviewHeight: number;
	PreviewBackground: PreviewBackgroundSettings;
	static Load(ResourceName: string): MaterialEditorSettings;
	static Find(Outer: UObject, ResourceName: string): MaterialEditorSettings;
	static GetDefaultObject(): MaterialEditorSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialEditorSettings;
	static C(Other: UObject | any): MaterialEditorSettings;
}

declare class AdvancedCopyMap { 
	ClassToCopy: SoftClassPath;
	AdvancedCopyCustomization: SoftClassPath;
	clone() : AdvancedCopyMap;
	static C(Other: UObject | any): AdvancedCopyMap;
}

declare class AssetToolsSettings extends DeveloperSettings { 
	AdvancedCopyCustomizations: AdvancedCopyMap[];
	static Load(ResourceName: string): AssetToolsSettings;
	static Find(Outer: UObject, ResourceName: string): AssetToolsSettings;
	static GetDefaultObject(): AssetToolsSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetToolsSettings;
	static C(Other: UObject | any): AssetToolsSettings;
}

declare class AssetRenameData { 
	Asset: UObject;
	NewPackagePath: string;
	NewName: string;
	OldObjectPath: SoftObjectPath;
	NewObjectPath: SoftObjectPath;
	bOnlyFixSoftReferences: boolean;
	clone() : AssetRenameData;
	static C(Other: UObject | any): AssetRenameData;
}

declare type EAssetRenameResult = 'Failure' | 'Success' | 'Pending' | 'EAssetRenameResult_MAX';
declare var EAssetRenameResult : { Failure:'Failure',Success:'Success',Pending:'Pending',EAssetRenameResult_MAX:'EAssetRenameResult_MAX', };
declare type EAssetMigrationConflict = 'Skip' | 'Overwrite' | 'Cancel' | 'EAssetMigrationConflict_MAX';
declare var EAssetMigrationConflict : { Skip:'Skip',Overwrite:'Overwrite',Cancel:'Cancel',EAssetMigrationConflict_MAX:'EAssetMigrationConflict_MAX', };
declare class MigrationOptions { 
	AssetConflict: EAssetMigrationConflict;
	OrphanFolder: string;
	clone() : MigrationOptions;
	static C(Other: UObject | any): MigrationOptions;
}

declare class RevisionInfo { 
	Revision: string;
	Changelist: number;
	Date: DateTime;
	clone() : RevisionInfo;
	static C(Other: UObject | any): RevisionInfo;
}

declare class AssetTools extends Interface { 
	static Load(ResourceName: string): AssetTools;
	static Find(Outer: UObject, ResourceName: string): AssetTools;
	static GetDefaultObject(): AssetTools;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetTools;
	RenameReferencingSoftObjectPaths(PackagesToCheck: Package[],AssetRedirectorMap: Map<SoftObjectPath, SoftObjectPath>): void;
	RenameAssetsWithDialog(AssetsAndNames: AssetRenameData[],bAutoCheckout: boolean): EAssetRenameResult;
	RenameAssets(AssetsAndNames: AssetRenameData[]): boolean;
	OpenEditorForAssets(Assets: UObject[]): void;
	MigratePackages(PackageNamesToMigrate: string[],DestinationPath: string,Options: MigrationOptions): void;
	ImportAssetTasks(ImportTasks: AssetImportTask[]): void;
	ImportAssetsWithDialog(DestinationPath: string): UObject[];
	ImportAssetsAutomated(ImportData: AutomatedAssetImportData): UObject[];
	FindSoftReferencesToObject(TargetObject: SoftObjectPath,ReferencingObjects?: UObject[]): {ReferencingObjects: UObject[]};
	ExportAssetsWithDialog(AssetsToExport: string[],bPromptForIndividualFilenames: boolean): void;
	ExportAssets(AssetsToExport: string[],ExportPath: string): void;
	DuplicateAssetWithDialogAndTitle(AssetName: string,PackagePath: string,OriginalObject: UObject,DialogTitle: string): UObject;
	DuplicateAssetWithDialog(AssetName: string,PackagePath: string,OriginalObject: UObject): UObject;
	DuplicateAsset(AssetName: string,PackagePath: string,OriginalObject: UObject): UObject;
	DiffAssets(OldAsset: UObject,NewAsset: UObject,OldRevision: RevisionInfo,NewRevision: RevisionInfo): void;
	DiffAgainstDepot(InObject: UObject,InPackagePath: string,InPackageName: string): void;
	CreateUniqueAssetName(InBasePackageName: string,InSuffix: string,OutPackageName?: string,OutAssetName?: string): {OutPackageName: string, OutAssetName: string};
	CreateAssetWithDialog(AssetName: string,PackagePath: string,AssetClass: UnrealEngineClass,Factory: Factory,CallingContext: string,bCallConfigureProperties: boolean): UObject;
	CreateAsset(AssetName: string,PackagePath: string,AssetClass: UnrealEngineClass,Factory: Factory,CallingContext: string): UObject;
	static C(Other: UObject | any): AssetTools;
}

declare class AssetToolsHelpers extends UObject { 
	static Load(ResourceName: string): AssetToolsHelpers;
	static Find(Outer: UObject, ResourceName: string): AssetToolsHelpers;
	static GetDefaultObject(): AssetToolsHelpers;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetToolsHelpers;
	static C(Other: UObject | any): AssetToolsHelpers;
}

declare class AdvancedCopyCustomization extends UObject { 
	static Load(ResourceName: string): AdvancedCopyCustomization;
	static Find(Outer: UObject, ResourceName: string): AdvancedCopyCustomization;
	static GetDefaultObject(): AdvancedCopyCustomization;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AdvancedCopyCustomization;
	static C(Other: UObject | any): AdvancedCopyCustomization;
}

declare class AssetToolsImpl extends UObject { 
	static Load(ResourceName: string): AssetToolsImpl;
	static Find(Outer: UObject, ResourceName: string): AssetToolsImpl;
	static GetDefaultObject(): AssetToolsImpl;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetToolsImpl;
	static C(Other: UObject | any): AssetToolsImpl;
}

declare class BlueprintEditorLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): BlueprintEditorLibrary;
	static Find(Outer: UObject, ResourceName: string): BlueprintEditorLibrary;
	static GetDefaultObject(): BlueprintEditorLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintEditorLibrary;
	static UpgradeOperatorNodes(Blueprint: Blueprint): void;
	static SetBlueprintVariableInstanceEditable(Blueprint: Blueprint,VariableName: string,bInstanceEditable: boolean): void;
	static SetBlueprintVariableExposeToCinematics(Blueprint: Blueprint,VariableName: string,bExposeToCinematics: boolean): void;
	static SetBlueprintVariableExposeOnSpawn(Blueprint: Blueprint,VariableName: string,bExposeOnSpawn: boolean): void;
	static ReplaceVariableReferences(Blueprint: Blueprint,OldVarName: string,NewVarName: string): void;
	static ReparentBlueprint(Blueprint: Blueprint,NewParentClass: UnrealEngineClass): void;
	static RenameGraph(Graph: EdGraph,NewNameStr: string): void;
	static RemoveUnusedVariables(Blueprint: Blueprint): number;
	static RemoveUnusedNodes(Blueprint: Blueprint): void;
	static RemoveGraph(Blueprint: Blueprint,Graph: EdGraph): void;
	static RemoveFunctionGraph(Blueprint: Blueprint,FuncName: string): void;
	static GetBlueprintAsset(UObject: UObject): Blueprint;
	static GeneratedClass(BlueprintObj: Blueprint): UnrealEngineClass;
	static FindGraph(Blueprint: Blueprint,GraphName: string): EdGraph;
	static FindEventGraph(Blueprint: Blueprint): EdGraph;
	static CompileBlueprint(Blueprint: Blueprint): void;
	static AddFunctionGraph(Blueprint: Blueprint,FuncName: string): EdGraph;
	static C(Other: UObject | any): BlueprintEditorLibrary;
}

declare class NotifyFieldValueChanged extends Interface { 
	static Load(ResourceName: string): NotifyFieldValueChanged;
	static Find(Outer: UObject, ResourceName: string): NotifyFieldValueChanged;
	static GetDefaultObject(): NotifyFieldValueChanged;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NotifyFieldValueChanged;
	static C(Other: UObject | any): NotifyFieldValueChanged;
}

declare class UserWidgetPool { 
	ActiveWidgets: UserWidget[];
	InactiveWidgets: UserWidget[];
	clone() : UserWidgetPool;
	static C(Other: UObject | any): UserWidgetPool;
}

declare class ListViewBase extends Widget { 
	BP_OnEntryGenerated: UnrealEngineMulticastDelegate<(Widget: UserWidget) => void>;
	EntryWidgetClass: UnrealEngineClass;
	WheelScrollMultiplier: number;
	bEnableScrollAnimation: boolean;
	AllowOverscroll: boolean;
	bEnableRightClickScrolling: boolean;
	bEnableFixedLineOffset: boolean;
	FixedLineScrollOffset: number;
	bAllowDragging: boolean;
	BP_OnEntryReleased: UnrealEngineMulticastDelegate<(Widget: UserWidget) => void>;
	NumDesignerPreviewEntries: number;
	EntryWidgetPool: UserWidgetPool;
	static Load(ResourceName: string): ListViewBase;
	static Find(Outer: UObject, ResourceName: string): ListViewBase;
	static GetDefaultObject(): ListViewBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ListViewBase;
	SetWheelScrollMultiplier(NewWheelScrollMultiplier: number): void;
	SetScrollOffset(InScrollOffset: number): void;
	SetScrollbarVisibility(InVisibility: ESlateVisibility): void;
	ScrollToTop(): void;
	ScrollToBottom(): void;
	RequestRefresh(): void;
	RegenerateAllEntries(): void;
	GetScrollOffset(): number;
	GetDisplayedEntryWidgets(): UserWidget[];
	static C(Other: UObject | any): ListViewBase;
}

declare class TableViewStyle extends SlateWidgetStyle { 
	BackgroundBrush: SlateBrush;
	clone() : TableViewStyle;
	static C(Other: UObject | any): TableViewStyle;
}

declare type EOrientation = 'Orient_Horizontal' | 'Orient_Vertical' | 'Orient_MAX';
declare var EOrientation : { Orient_Horizontal:'Orient_Horizontal',Orient_Vertical:'Orient_Vertical',Orient_MAX:'Orient_MAX', };
declare type ESelectionMode = 'None' | 'Single' | 'SingleToggle' | 'Multi' | 'ESelectionMode_MAX';
declare var ESelectionMode : { None:'None',Single:'Single',SingleToggle:'SingleToggle',Multi:'Multi',ESelectionMode_MAX:'ESelectionMode_MAX', };
declare type EConsumeMouseWheel = 'WhenScrollingPossible' | 'Always' | 'Never' | 'EConsumeMouseWheel_MAX';
declare var EConsumeMouseWheel : { WhenScrollingPossible:'WhenScrollingPossible',Always:'Always',Never:'Never',EConsumeMouseWheel_MAX:'EConsumeMouseWheel_MAX', };
declare class ListView extends ListViewBase { 
	WidgetStyle: TableViewStyle;
	ScrollBarStyle: ScrollBarStyle;
	Orientation: EOrientation;
	SelectionMode: ESelectionMode;
	ConsumeMouseWheel: EConsumeMouseWheel;
	bClearSelectionOnClick: boolean;
	bIsFocusable: boolean;
	EntrySpacing: number;
	bReturnFocusToSelection: boolean;
	ListItems: UObject[];
	BP_OnEntryInitialized: UnrealEngineMulticastDelegate<(Item: UObject, Widget: UserWidget) => void>;
	BP_OnItemClicked: UnrealEngineMulticastDelegate<(Item: UObject) => void>;
	BP_OnItemDoubleClicked: UnrealEngineMulticastDelegate<(Item: UObject) => void>;
	BP_OnItemIsHoveredChanged: UnrealEngineMulticastDelegate<(Item: UObject, bIsHovered: boolean) => void>;
	BP_OnItemSelectionChanged: UnrealEngineMulticastDelegate<(Item: UObject, bIsSelected: boolean) => void>;
	BP_OnItemScrolledIntoView: UnrealEngineMulticastDelegate<(Item: UObject, Widget: UserWidget) => void>;
	static Load(ResourceName: string): ListView;
	static Find(Outer: UObject, ResourceName: string): ListView;
	static GetDefaultObject(): ListView;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ListView;
	SetSelectionMode(SelectionMode: ESelectionMode): void;
	SetSelectedIndex(Index: number): void;
	ScrollIndexIntoView(Index: number): void;
	RemoveItem(Item: UObject): void;
	OnListItemOuterEndPlayed(ItemOuter: Actor,EndPlayReason: EEndPlayReason): void;
	OnListItemEndPlayed(Item: Actor,EndPlayReason: EEndPlayReason): void;
	NavigateToIndex(Index: number): void;
	IsRefreshPending(): boolean;
	GetNumItems(): number;
	GetListItems(): UObject[];
	GetItemAt(Index: number): UObject;
	GetIndexForItem(Item: UObject): number;
	ClearListItems(): void;
	BP_SetSelectedItem(Item: UObject): void;
	BP_SetListItems(InListItems: UObject[]): void;
	BP_SetItemSelection(Item: UObject,bSelected: boolean): void;
	BP_ScrollItemIntoView(Item: UObject): void;
	BP_NavigateToItem(Item: UObject): void;
	BP_IsItemVisible(Item: UObject): boolean;
	BP_GetSelectedItems(Items?: UObject[]): {Items: UObject[], $: boolean};
	BP_GetSelectedItem(): UObject;
	BP_GetNumItemsSelected(): number;
	BP_ClearSelection(): void;
	BP_CancelScrollIntoView(): void;
	AddItem(Item: UObject): void;
	static C(Other: UObject | any): ListView;
}

declare class ListViewDesignerPreviewItem extends UObject { 
	static Load(ResourceName: string): ListViewDesignerPreviewItem;
	static Find(Outer: UObject, ResourceName: string): ListViewDesignerPreviewItem;
	static GetDefaultObject(): ListViewDesignerPreviewItem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ListViewDesignerPreviewItem;
	static C(Other: UObject | any): ListViewDesignerPreviewItem;
}

declare class UserWidgetBlueprint extends Blueprint { 
	static Load(ResourceName: string): UserWidgetBlueprint;
	static Find(Outer: UObject, ResourceName: string): UserWidgetBlueprint;
	static GetDefaultObject(): UserWidgetBlueprint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserWidgetBlueprint;
	static C(Other: UObject | any): UserWidgetBlueprint;
}

declare class WidgetBlueprintGeneratedClassExtension extends UObject { 
	static Load(ResourceName: string): WidgetBlueprintGeneratedClassExtension;
	static Find(Outer: UObject, ResourceName: string): WidgetBlueprintGeneratedClassExtension;
	static GetDefaultObject(): WidgetBlueprintGeneratedClassExtension;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetBlueprintGeneratedClassExtension;
	static C(Other: UObject | any): WidgetBlueprintGeneratedClassExtension;
}

declare class WidgetFieldNotificationExtension extends UserWidgetExtension { 
	static Load(ResourceName: string): WidgetFieldNotificationExtension;
	static Find(Outer: UObject, ResourceName: string): WidgetFieldNotificationExtension;
	static GetDefaultObject(): WidgetFieldNotificationExtension;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetFieldNotificationExtension;
	static C(Other: UObject | any): WidgetFieldNotificationExtension;
}

declare class MovieScenePropertyInstantiatorSystem extends MovieSceneEntityInstantiatorSystem { 
	static Load(ResourceName: string): MovieScenePropertyInstantiatorSystem;
	static Find(Outer: UObject, ResourceName: string): MovieScenePropertyInstantiatorSystem;
	static GetDefaultObject(): MovieScenePropertyInstantiatorSystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScenePropertyInstantiatorSystem;
	static C(Other: UObject | any): MovieScenePropertyInstantiatorSystem;
}

declare class MovieScenePropertySystem extends MovieSceneEntitySystem { 
	InstantiatorSystem: MovieScenePropertyInstantiatorSystem;
	static Load(ResourceName: string): MovieScenePropertySystem;
	static Find(Outer: UObject, ResourceName: string): MovieScenePropertySystem;
	static GetDefaultObject(): MovieScenePropertySystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScenePropertySystem;
	static C(Other: UObject | any): MovieScenePropertySystem;
}

declare class MovieScene2DTransformPropertySystem extends MovieScenePropertySystem { 
	static Load(ResourceName: string): MovieScene2DTransformPropertySystem;
	static Find(Outer: UObject, ResourceName: string): MovieScene2DTransformPropertySystem;
	static GetDefaultObject(): MovieScene2DTransformPropertySystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScene2DTransformPropertySystem;
	static C(Other: UObject | any): MovieScene2DTransformPropertySystem;
}

declare class MovieScene2DTransformMask { 
	mask: number;
	clone() : MovieScene2DTransformMask;
	static C(Other: UObject | any): MovieScene2DTransformMask;
}

declare class MovieScene2DTransformSection extends MovieSceneSection { 
	TransformMask: MovieScene2DTransformMask;
	Translation: MovieSceneFloatChannel;
	Rotation: MovieSceneFloatChannel;
	Scale: MovieSceneFloatChannel;
	Shear: MovieSceneFloatChannel;
	static Load(ResourceName: string): MovieScene2DTransformSection;
	static Find(Outer: UObject, ResourceName: string): MovieScene2DTransformSection;
	static GetDefaultObject(): MovieScene2DTransformSection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScene2DTransformSection;
	static C(Other: UObject | any): MovieScene2DTransformSection;
}

declare class MovieScenePropertyBinding { 
	PropertyName: string;
	PropertyPath: string;
	bCanUseClassLookup: boolean;
	clone() : MovieScenePropertyBinding;
	static C(Other: UObject | any): MovieScenePropertyBinding;
}

declare class MovieScenePropertyTrack extends MovieSceneNameableTrack { 
	UniqueTrackName: string;
	PropertyName: string;
	PropertyPath: string;
	SectionToKey: MovieSceneSection;
	PropertyBinding: MovieScenePropertyBinding;
	Sections: MovieSceneSection[];
	static Load(ResourceName: string): MovieScenePropertyTrack;
	static Find(Outer: UObject, ResourceName: string): MovieScenePropertyTrack;
	static GetDefaultObject(): MovieScenePropertyTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScenePropertyTrack;
	static C(Other: UObject | any): MovieScenePropertyTrack;
	GetPropertyName(): string;
	GetPropertyPath(): string;
	GetUniqueTrackName(): string;
	SetPropertyNameAndPath(InPropertyName: string,InPropertyPath: string): void;
	static GetPropertyName(Track: MovieScenePropertyTrack): string;
	static GetPropertyPath(Track: MovieScenePropertyTrack): string;
	static GetUniqueTrackName(Track: MovieScenePropertyTrack): string;
	static SetPropertyNameAndPath(Track: MovieScenePropertyTrack,InPropertyName: string,InPropertyPath: string): void;
}

declare class MovieScene2DTransformTrack extends MovieScenePropertyTrack { 
	static Load(ResourceName: string): MovieScene2DTransformTrack;
	static Find(Outer: UObject, ResourceName: string): MovieScene2DTransformTrack;
	static GetDefaultObject(): MovieScene2DTransformTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScene2DTransformTrack;
	static C(Other: UObject | any): MovieScene2DTransformTrack;
}

declare class MovieSceneMarginPropertySystem extends MovieScenePropertySystem { 
	static Load(ResourceName: string): MovieSceneMarginPropertySystem;
	static Find(Outer: UObject, ResourceName: string): MovieSceneMarginPropertySystem;
	static GetDefaultObject(): MovieSceneMarginPropertySystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneMarginPropertySystem;
	static C(Other: UObject | any): MovieSceneMarginPropertySystem;
}

declare class MovieSceneMarginSection extends MovieSceneSection { 
	TopCurve: MovieSceneFloatChannel;
	LeftCurve: MovieSceneFloatChannel;
	RightCurve: MovieSceneFloatChannel;
	BottomCurve: MovieSceneFloatChannel;
	static Load(ResourceName: string): MovieSceneMarginSection;
	static Find(Outer: UObject, ResourceName: string): MovieSceneMarginSection;
	static GetDefaultObject(): MovieSceneMarginSection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneMarginSection;
	static C(Other: UObject | any): MovieSceneMarginSection;
}

declare class MovieSceneMarginTrack extends MovieScenePropertyTrack { 
	static Load(ResourceName: string): MovieSceneMarginTrack;
	static Find(Outer: UObject, ResourceName: string): MovieSceneMarginTrack;
	static GetDefaultObject(): MovieSceneMarginTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneMarginTrack;
	static C(Other: UObject | any): MovieSceneMarginTrack;
}

declare class MovieSceneWidgetMaterialSystem extends MovieSceneEntitySystem { 
	static Load(ResourceName: string): MovieSceneWidgetMaterialSystem;
	static Find(Outer: UObject, ResourceName: string): MovieSceneWidgetMaterialSystem;
	static GetDefaultObject(): MovieSceneWidgetMaterialSystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneWidgetMaterialSystem;
	static C(Other: UObject | any): MovieSceneWidgetMaterialSystem;
}

declare class MovieSceneMaterialTrack extends MovieSceneNameableTrack { 
	Sections: MovieSceneSection[];
	static Load(ResourceName: string): MovieSceneMaterialTrack;
	static Find(Outer: UObject, ResourceName: string): MovieSceneMaterialTrack;
	static GetDefaultObject(): MovieSceneMaterialTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneMaterialTrack;
	static C(Other: UObject | any): MovieSceneMaterialTrack;
}

declare class MovieSceneWidgetMaterialTrack extends MovieSceneMaterialTrack { 
	BrushPropertyNamePath: string[];
	TrackName: string;
	static Load(ResourceName: string): MovieSceneWidgetMaterialTrack;
	static Find(Outer: UObject, ResourceName: string): MovieSceneWidgetMaterialTrack;
	static GetDefaultObject(): MovieSceneWidgetMaterialTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneWidgetMaterialTrack;
	static C(Other: UObject | any): MovieSceneWidgetMaterialTrack;
}

declare class BlueprintWidgetAnimationDelegateBinding { 
	Action: EWidgetAnimationEvent;
	AnimationToBind: string;
	FunctionNameToBind: string;
	UserTag: string;
	clone() : BlueprintWidgetAnimationDelegateBinding;
	static C(Other: UObject | any): BlueprintWidgetAnimationDelegateBinding;
}

declare class WidgetAnimationDelegateBinding extends DynamicBlueprintBinding { 
	WidgetAnimationDelegateBindings: BlueprintWidgetAnimationDelegateBinding[];
	static Load(ResourceName: string): WidgetAnimationDelegateBinding;
	static Find(Outer: UObject, ResourceName: string): WidgetAnimationDelegateBinding;
	static GetDefaultObject(): WidgetAnimationDelegateBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetAnimationDelegateBinding;
	static C(Other: UObject | any): WidgetAnimationDelegateBinding;
}

declare class WidgetAnimationPlayCallbackProxy extends UObject { 
	Finished: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): WidgetAnimationPlayCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): WidgetAnimationPlayCallbackProxy;
	static GetDefaultObject(): WidgetAnimationPlayCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetAnimationPlayCallbackProxy;
	static CreatePlayAnimationTimeRangeProxyObject(result?: UMGSequencePlayer,Widget?: UserWidget,InAnimation?: WidgetAnimation,StartAtTime?: number,EndAtTime?: number,NumLoopsToPlay?: number,PlayMode?: EUMGSequencePlayMode,PlaybackSpeed?: number): {result: UMGSequencePlayer, $: WidgetAnimationPlayCallbackProxy};
	static CreatePlayAnimationProxyObject(result?: UMGSequencePlayer,Widget?: UserWidget,InAnimation?: WidgetAnimation,StartAtTime?: number,NumLoopsToPlay?: number,PlayMode?: EUMGSequencePlayMode,PlaybackSpeed?: number): {result: UMGSequencePlayer, $: WidgetAnimationPlayCallbackProxy};
	static C(Other: UObject | any): WidgetAnimationPlayCallbackProxy;
}

declare class BoolBinding extends PropertyBinding { 
	static Load(ResourceName: string): BoolBinding;
	static Find(Outer: UObject, ResourceName: string): BoolBinding;
	static GetDefaultObject(): BoolBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BoolBinding;
	GetValue(): boolean;
	static C(Other: UObject | any): BoolBinding;
}

declare class BrushBinding extends PropertyBinding { 
	static Load(ResourceName: string): BrushBinding;
	static Find(Outer: UObject, ResourceName: string): BrushBinding;
	static GetDefaultObject(): BrushBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BrushBinding;
	GetValue(): SlateBrush;
	static C(Other: UObject | any): BrushBinding;
}

declare class CheckedStateBinding extends PropertyBinding { 
	static Load(ResourceName: string): CheckedStateBinding;
	static Find(Outer: UObject, ResourceName: string): CheckedStateBinding;
	static GetDefaultObject(): CheckedStateBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CheckedStateBinding;
	GetValue(): ECheckBoxState;
	static C(Other: UObject | any): CheckedStateBinding;
}

declare class ColorBinding extends PropertyBinding { 
	static Load(ResourceName: string): ColorBinding;
	static Find(Outer: UObject, ResourceName: string): ColorBinding;
	static GetDefaultObject(): ColorBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ColorBinding;
	GetSlateValue(): SlateColor;
	GetLinearValue(): LinearColor;
	static C(Other: UObject | any): ColorBinding;
}

declare class FloatBinding extends PropertyBinding { 
	static Load(ResourceName: string): FloatBinding;
	static Find(Outer: UObject, ResourceName: string): FloatBinding;
	static GetDefaultObject(): FloatBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FloatBinding;
	GetValue(): number;
	static C(Other: UObject | any): FloatBinding;
}

declare class Int32Binding extends PropertyBinding { 
	static Load(ResourceName: string): Int32Binding;
	static Find(Outer: UObject, ResourceName: string): Int32Binding;
	static GetDefaultObject(): Int32Binding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Int32Binding;
	GetValue(): number;
	static C(Other: UObject | any): Int32Binding;
}

declare class MouseCursorBinding extends PropertyBinding { 
	static Load(ResourceName: string): MouseCursorBinding;
	static Find(Outer: UObject, ResourceName: string): MouseCursorBinding;
	static GetDefaultObject(): MouseCursorBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MouseCursorBinding;
	GetValue(): EMouseCursor;
	static C(Other: UObject | any): MouseCursorBinding;
}

declare class TextBinding extends PropertyBinding { 
	static Load(ResourceName: string): TextBinding;
	static Find(Outer: UObject, ResourceName: string): TextBinding;
	static GetDefaultObject(): TextBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextBinding;
	GetTextValue(): string;
	GetStringValue(): string;
	static C(Other: UObject | any): TextBinding;
}

declare class VisibilityBinding extends PropertyBinding { 
	static Load(ResourceName: string): VisibilityBinding;
	static Find(Outer: UObject, ResourceName: string): VisibilityBinding;
	static GetDefaultObject(): VisibilityBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VisibilityBinding;
	GetValue(): ESlateVisibility;
	static C(Other: UObject | any): VisibilityBinding;
}

declare class WidgetBinding extends PropertyBinding { 
	static Load(ResourceName: string): WidgetBinding;
	static Find(Outer: UObject, ResourceName: string): WidgetBinding;
	static GetDefaultObject(): WidgetBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetBinding;
	GetValue(): Widget;
	static C(Other: UObject | any): WidgetBinding;
}

declare class Texture2DDynamic extends Texture { 
	Format: EPixelFormat;
	static Load(ResourceName: string): Texture2DDynamic;
	static Find(Outer: UObject, ResourceName: string): Texture2DDynamic;
	static GetDefaultObject(): Texture2DDynamic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Texture2DDynamic;
	static C(Other: UObject | any): Texture2DDynamic;
}

declare class AsyncTaskDownloadImage extends BlueprintAsyncActionBase { 
	OnSuccess: UnrealEngineMulticastDelegate<(Texture: Texture2DDynamic) => void>;
	OnFail: UnrealEngineMulticastDelegate<(Texture: Texture2DDynamic) => void>;
	static Load(ResourceName: string): AsyncTaskDownloadImage;
	static Find(Outer: UObject, ResourceName: string): AsyncTaskDownloadImage;
	static GetDefaultObject(): AsyncTaskDownloadImage;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AsyncTaskDownloadImage;
	static DownloadImage(URL: string): AsyncTaskDownloadImage;
	static C(Other: UObject | any): AsyncTaskDownloadImage;
}

declare class GameViewportWidgetSlot { 
	Anchors: Anchors;
	Offsets: Margin;
	Alignment: Vector2D;
	ZOrder: number;
	clone() : GameViewportWidgetSlot;
	static C(Other: UObject | any): GameViewportWidgetSlot;
}

declare class GameViewportSubsystem extends GameInstanceSubsystem { 
	static Load(ResourceName: string): GameViewportSubsystem;
	static Find(Outer: UObject, ResourceName: string): GameViewportSubsystem;
	static GetDefaultObject(): GameViewportSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameViewportSubsystem;
	static SetWidgetSlotPosition(Slot: GameViewportWidgetSlot,Widget: Widget,Position: Vector2D,bRemoveDPIScale: boolean): GameViewportWidgetSlot;
	static SetWidgetSlotDesiredSize(Slot: GameViewportWidgetSlot,Size: Vector2D): GameViewportWidgetSlot;
	SetWidgetSlot(Widget: Widget,Slot: GameViewportWidgetSlot): void;
	RemoveWidget(Widget: Widget): void;
	IsWidgetAdded(Widget: Widget): boolean;
	GetWidgetSlot(Widget: Widget): GameViewportWidgetSlot;
	AddWidgetForPlayer(Widget: Widget,Player: LocalPlayer,Slot: GameViewportWidgetSlot): void;
	AddWidget(Widget: Widget,Slot: GameViewportWidgetSlot): void;
	static C(Other: UObject | any): GameViewportSubsystem;
}

declare class UserListEntry extends Interface { 
	static Load(ResourceName: string): UserListEntry;
	static Find(Outer: UObject, ResourceName: string): UserListEntry;
	static GetDefaultObject(): UserListEntry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserListEntry;
	BP_OnItemSelectionChanged(bIsSelected: boolean): void;
	BP_OnItemExpansionChanged(bIsExpanded: boolean): void;
	BP_OnEntryReleased(): void;
	static C(Other: UObject | any): UserListEntry;
}

declare class UserListEntryLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): UserListEntryLibrary;
	static Find(Outer: UObject, ResourceName: string): UserListEntryLibrary;
	static GetDefaultObject(): UserListEntryLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserListEntryLibrary;
	static C(Other: UObject | any): UserListEntryLibrary;
}

declare class UserObjectListEntry extends UserListEntry { 
	static Load(ResourceName: string): UserObjectListEntry;
	static Find(Outer: UObject, ResourceName: string): UserObjectListEntry;
	static GetDefaultObject(): UserObjectListEntry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserObjectListEntry;
	OnListItemObjectSet(ListItemObject: UObject): void;
	static C(Other: UObject | any): UserObjectListEntry;
}

declare class UserObjectListEntryLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): UserObjectListEntryLibrary;
	static Find(Outer: UObject, ResourceName: string): UserObjectListEntryLibrary;
	static GetDefaultObject(): UserObjectListEntryLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserObjectListEntryLibrary;
	static C(Other: UObject | any): UserObjectListEntryLibrary;
}

declare class ContentWidget extends PanelWidget { 
	static Load(ResourceName: string): ContentWidget;
	static Find(Outer: UObject, ResourceName: string): ContentWidget;
	static GetDefaultObject(): ContentWidget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentWidget;
	SetContent(Content: Widget): PanelSlot;
	GetContentSlot(): PanelSlot;
	GetContent(): Widget;
	static C(Other: UObject | any): ContentWidget;
}

declare class BackgroundBlur extends ContentWidget { 
	Padding: Margin;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	bApplyAlphaToBlur: boolean;
	BlurStrength: number;
	bOverrideAutoRadiusCalculation: boolean;
	BlurRadius: number;
	CornerRadius: Vector4;
	LowQualityFallbackBrush: SlateBrush;
	static Load(ResourceName: string): BackgroundBlur;
	static Find(Outer: UObject, ResourceName: string): BackgroundBlur;
	static GetDefaultObject(): BackgroundBlur;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BackgroundBlur;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetPadding(InPadding: Margin): void;
	SetLowQualityFallbackBrush(InBrush: SlateBrush): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	SetCornerRadius(InCornerRadius: Vector4): void;
	SetBlurStrength(InStrength: number): void;
	SetBlurRadius(InBlurRadius: number): void;
	SetApplyAlphaToBlur(bInApplyAlphaToBlur: boolean): void;
	static C(Other: UObject | any): BackgroundBlur;
}

declare class BackgroundBlurSlot extends PanelSlot { 
	Padding: Margin;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	static Load(ResourceName: string): BackgroundBlurSlot;
	static Find(Outer: UObject, ResourceName: string): BackgroundBlurSlot;
	static GetDefaultObject(): BackgroundBlurSlot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BackgroundBlurSlot;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	static C(Other: UObject | any): BackgroundBlurSlot;
}

declare class Border extends ContentWidget { 
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	bShowEffectWhenDisabled: boolean;
	ContentColorAndOpacity: LinearColor;
	ContentColorAndOpacityDelegate: UnrealEngineDelegate<() => LinearColor>;
	Padding: Margin;
	Background: SlateBrush;
	BackgroundDelegate: UnrealEngineDelegate<() => SlateBrush>;
	BrushColor: LinearColor;
	BrushColorDelegate: UnrealEngineDelegate<() => LinearColor>;
	DesiredSizeScale: Vector2D;
	bFlipForRightToLeftFlowDirection: boolean;
	OnMouseButtonDownEvent: UnrealEngineDelegate<(MyGeometry: Geometry, MouseEvent: UPointerEvent) => EventReply>;
	OnMouseButtonUpEvent: UnrealEngineDelegate<(MyGeometry: Geometry, MouseEvent: UPointerEvent) => EventReply>;
	OnMouseMoveEvent: UnrealEngineDelegate<(MyGeometry: Geometry, MouseEvent: UPointerEvent) => EventReply>;
	OnMouseDoubleClickEvent: UnrealEngineDelegate<(MyGeometry: Geometry, MouseEvent: UPointerEvent) => EventReply>;
	static Load(ResourceName: string): Border;
	static Find(Outer: UObject, ResourceName: string): Border;
	static GetDefaultObject(): Border;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Border;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetShowEffectWhenDisabled(bInShowEffectWhenDisabled: boolean): void;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	SetDesiredSizeScale(InScale: Vector2D): void;
	SetContentColorAndOpacity(InContentColorAndOpacity: LinearColor): void;
	SetBrushFromTexture(Texture: Texture2D): void;
	SetBrushFromMaterial(Material: MaterialInterface): void;
	SetBrushFromAsset(Asset: SlateBrushAsset): void;
	SetBrushColor(InBrushColor: LinearColor): void;
	SetBrush(InBrush: SlateBrush): void;
	GetDynamicMaterial(): MaterialInstanceDynamic;
	static C(Other: UObject | any): Border;
}

declare type EButtonClickMethod = 'DownAndUp' | 'MouseDown' | 'MouseUp' | 'PreciseClick' | 'EButtonClickMethod_MAX';
declare var EButtonClickMethod : { DownAndUp:'DownAndUp',MouseDown:'MouseDown',MouseUp:'MouseUp',PreciseClick:'PreciseClick',EButtonClickMethod_MAX:'EButtonClickMethod_MAX', };
declare type EButtonTouchMethod = 'DownAndUp' | 'Down' | 'PreciseTap' | 'EButtonTouchMethod_MAX';
declare var EButtonTouchMethod : { DownAndUp:'DownAndUp',Down:'Down',PreciseTap:'PreciseTap',EButtonTouchMethod_MAX:'EButtonTouchMethod_MAX', };
declare type EButtonPressMethod = 'DownAndUp' | 'ButtonPress' | 'ButtonRelease' | 'EButtonPressMethod_MAX';
declare var EButtonPressMethod : { DownAndUp:'DownAndUp',ButtonPress:'ButtonPress',ButtonRelease:'ButtonRelease',EButtonPressMethod_MAX:'EButtonPressMethod_MAX', };
declare class Button extends ContentWidget { 
	WidgetStyle: ButtonStyle;
	ColorAndOpacity: LinearColor;
	BackgroundColor: LinearColor;
	ClickMethod: EButtonClickMethod;
	TouchMethod: EButtonTouchMethod;
	PressMethod: EButtonPressMethod;
	IsFocusable: boolean;
	OnClicked: UnrealEngineMulticastDelegate<() => void>;
	OnPressed: UnrealEngineMulticastDelegate<() => void>;
	OnReleased: UnrealEngineMulticastDelegate<() => void>;
	OnHovered: UnrealEngineMulticastDelegate<() => void>;
	OnUnhovered: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): Button;
	static Find(Outer: UObject, ResourceName: string): Button;
	static GetDefaultObject(): Button;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Button;
	SetTouchMethod(InTouchMethod: EButtonTouchMethod): void;
	SetStyle(InStyle: ButtonStyle): void;
	SetPressMethod(InPressMethod: EButtonPressMethod): void;
	SetColorAndOpacity(InColorAndOpacity: LinearColor): void;
	SetClickMethod(InClickMethod: EButtonClickMethod): void;
	SetBackgroundColor(InBackgroundColor: LinearColor): void;
	IsPressed(): boolean;
	static C(Other: UObject | any): Button;
}

declare class ButtonSlot extends PanelSlot { 
	Padding: Margin;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	static Load(ResourceName: string): ButtonSlot;
	static Find(Outer: UObject, ResourceName: string): ButtonSlot;
	static GetDefaultObject(): ButtonSlot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ButtonSlot;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	static C(Other: UObject | any): ButtonSlot;
}

declare class CanvasPanel extends PanelWidget { 
	static Load(ResourceName: string): CanvasPanel;
	static Find(Outer: UObject, ResourceName: string): CanvasPanel;
	static GetDefaultObject(): CanvasPanel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CanvasPanel;
	AddChildToCanvas(Content: Widget): CanvasPanelSlot;
	static C(Other: UObject | any): CanvasPanel;
}

declare class CheckBox extends ContentWidget { 
	CheckedState: ECheckBoxState;
	CheckedStateDelegate: UnrealEngineDelegate<() => ECheckBoxState>;
	WidgetStyle: CheckBoxStyle;
	HorizontalAlignment: EHorizontalAlignment;
	ClickMethod: EButtonClickMethod;
	TouchMethod: EButtonTouchMethod;
	PressMethod: EButtonPressMethod;
	IsFocusable: boolean;
	OnCheckStateChanged: UnrealEngineMulticastDelegate<(bIsChecked: boolean) => void>;
	static Load(ResourceName: string): CheckBox;
	static Find(Outer: UObject, ResourceName: string): CheckBox;
	static GetDefaultObject(): CheckBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CheckBox;
	SetTouchMethod(InTouchMethod: EButtonTouchMethod): void;
	SetPressMethod(InPressMethod: EButtonPressMethod): void;
	SetIsChecked(InIsChecked: boolean): void;
	SetClickMethod(InClickMethod: EButtonClickMethod): void;
	SetCheckedState(InCheckedState: ECheckBoxState): void;
	IsPressed(): boolean;
	IsChecked(): boolean;
	GetCheckedState(): ECheckBoxState;
	static C(Other: UObject | any): CheckBox;
}

declare class CircularThrobber extends Widget { 
	NumberOfPieces: number;
	Period: number;
	Radius: number;
	UImage: SlateBrush;
	bEnableRadius: boolean;
	static Load(ResourceName: string): CircularThrobber;
	static Find(Outer: UObject, ResourceName: string): CircularThrobber;
	static GetDefaultObject(): CircularThrobber;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CircularThrobber;
	SetRadius(InRadius: number): void;
	SetPeriod(InPeriod: number): void;
	SetNumberOfPieces(InNumberOfPieces: number): void;
	static C(Other: UObject | any): CircularThrobber;
}

declare class ComboBox extends Widget { 
	Items: UObject[];
	OnGenerateWidgetEvent: UnrealEngineDelegate<(Item: UObject) => Widget>;
	bIsFocusable: boolean;
	static Load(ResourceName: string): ComboBox;
	static Find(Outer: UObject, ResourceName: string): ComboBox;
	static GetDefaultObject(): ComboBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ComboBox;
	static C(Other: UObject | any): ComboBox;
}

declare class TableRowStyle extends SlateWidgetStyle { 
	SelectorFocusedBrush: SlateBrush;
	ActiveHoveredBrush: SlateBrush;
	ActiveBrush: SlateBrush;
	InactiveHoveredBrush: SlateBrush;
	InactiveBrush: SlateBrush;
	bUseParentRowBrush: boolean;
	ParentRowBackgroundBrush: SlateBrush;
	ParentRowBackgroundHoveredBrush: SlateBrush;
	EvenRowBackgroundHoveredBrush: SlateBrush;
	EvenRowBackgroundBrush: SlateBrush;
	OddRowBackgroundHoveredBrush: SlateBrush;
	OddRowBackgroundBrush: SlateBrush;
	TextColor: SlateColor;
	SelectedTextColor: SlateColor;
	DropIndicator_Above: SlateBrush;
	DropIndicator_Onto: SlateBrush;
	DropIndicator_Below: SlateBrush;
	ActiveHighlightedBrush: SlateBrush;
	InactiveHighlightedBrush: SlateBrush;
	clone() : TableRowStyle;
	static C(Other: UObject | any): TableRowStyle;
}

declare type ESelectInfo = 'OnKeyPress' | 'OnNavigation' | 'OnMouseClick' | 'Direct' | 'ESelectInfo_MAX';
declare var ESelectInfo : { OnKeyPress:'OnKeyPress',OnNavigation:'OnNavigation',OnMouseClick:'OnMouseClick',Direct:'Direct',ESelectInfo_MAX:'ESelectInfo_MAX', };
declare class ComboBoxKey extends Widget { 
	Options: string[];
	SelectedOption: string;
	WidgetStyle: ComboBoxStyle;
	ItemStyle: TableRowStyle;
	ForegroundColor: SlateColor;
	ContentPadding: Margin;
	MaxListHeight: number;
	bHasDownArrow: boolean;
	bEnableGamepadNavigationMode: boolean;
	bIsFocusable: boolean;
	OnGenerateContentWidget: UnrealEngineDelegate<(Item: string) => Widget>;
	OnGenerateItemWidget: UnrealEngineDelegate<(Item: string) => Widget>;
	OnSelectionChanged: UnrealEngineMulticastDelegate<(SelectedItem: string, SelectionType: ESelectInfo) => void>;
	OnOpening: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): ComboBoxKey;
	static Find(Outer: UObject, ResourceName: string): ComboBoxKey;
	static GetDefaultObject(): ComboBoxKey;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ComboBoxKey;
	SetSelectedOption(Option: string): void;
	RemoveOption(Option: string): boolean;
	IsOpen(): boolean;
	GetSelectedOption(): string;
	ClearSelection(): void;
	ClearOptions(): void;
	AddOption(Option: string): void;
	static C(Other: UObject | any): ComboBoxKey;
}

declare class ComboBoxString extends Widget { 
	DefaultOptions: string[];
	SelectedOption: string;
	WidgetStyle: ComboBoxStyle;
	ItemStyle: TableRowStyle;
	ContentPadding: Margin;
	MaxListHeight: number;
	HasDownArrow: boolean;
	EnableGamepadNavigationMode: boolean;
	Font: SlateFontInfo;
	ForegroundColor: SlateColor;
	bIsFocusable: boolean;
	OnGenerateWidgetEvent: UnrealEngineDelegate<(Item: string) => Widget>;
	OnSelectionChanged: UnrealEngineMulticastDelegate<(SelectedItem: string, SelectionType: ESelectInfo) => void>;
	OnOpening: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): ComboBoxString;
	static Find(Outer: UObject, ResourceName: string): ComboBoxString;
	static GetDefaultObject(): ComboBoxString;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ComboBoxString;
	SetSelectedOption(Option: string): void;
	SetSelectedIndex(Index: number): void;
	RemoveOption(Option: string): boolean;
	RefreshOptions(): void;
	IsOpen(): boolean;
	GetSelectedOption(): string;
	GetSelectedIndex(): number;
	GetOptionCount(): number;
	GetOptionAtIndex(Index: number): string;
	FindOptionIndex(Option: string): number;
	ClearSelection(): void;
	ClearOptions(): void;
	AddOption(Option: string): void;
	static C(Other: UObject | any): ComboBoxString;
}

declare type EDynamicBoxType = 'Horizontal' | 'Vertical' | 'Wrap' | 'VerticalWrap' | 'Radial' | 'Overlay' | 'EDynamicBoxType_MAX';
declare var EDynamicBoxType : { Horizontal:'Horizontal',Vertical:'Vertical',Wrap:'Wrap',VerticalWrap:'VerticalWrap',Radial:'Radial',Overlay:'Overlay',EDynamicBoxType_MAX:'EDynamicBoxType_MAX', };
declare class RadialBoxSettings { 
	StartingAngle: number;
	bDistributeItemsEvenly: boolean;
	AngleBetweenItems: number;
	SectorCentralAngle: number;
	clone() : RadialBoxSettings;
	static C(Other: UObject | any): RadialBoxSettings;
}

declare class DynamicEntryBoxBase extends Widget { 
	EntryBoxType: EDynamicBoxType;
	EntrySpacing: Vector2D;
	SpacingPattern: Vector2D[];
	EntrySizeRule: SlateChildSize;
	EntryHorizontalAlignment: EHorizontalAlignment;
	EntryVerticalAlignment: EVerticalAlignment;
	MaxElementSize: number;
	RadialBoxSettings: RadialBoxSettings;
	EntryWidgetPool: UserWidgetPool;
	static Load(ResourceName: string): DynamicEntryBoxBase;
	static Find(Outer: UObject, ResourceName: string): DynamicEntryBoxBase;
	static GetDefaultObject(): DynamicEntryBoxBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DynamicEntryBoxBase;
	SetRadialSettings(InSettings: RadialBoxSettings): void;
	SetEntrySpacing(InEntrySpacing: Vector2D): void;
	GetNumEntries(): number;
	GetAllEntries(): UserWidget[];
	static C(Other: UObject | any): DynamicEntryBoxBase;
}

declare class DynamicEntryBox extends DynamicEntryBoxBase { 
	NumDesignerPreviewEntries: number;
	EntryWidgetClass: UnrealEngineClass;
	static Load(ResourceName: string): DynamicEntryBox;
	static Find(Outer: UObject, ResourceName: string): DynamicEntryBox;
	static GetDefaultObject(): DynamicEntryBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DynamicEntryBox;
	Reset(bDeleteWidgets: boolean): void;
	RemoveEntry(EntryWidget: UserWidget): void;
	BP_CreateEntryOfClass(EntryClass: UnrealEngineClass): UserWidget;
	BP_CreateEntry(): UserWidget;
	static C(Other: UObject | any): DynamicEntryBox;
}

declare type EVirtualKeyboardType = 'Default' | 'Number' | 'Web' | 'Email' | 'Password' | 'AlphaNumeric' | 'EVirtualKeyboardType_MAX';
declare var EVirtualKeyboardType : { Default:'Default',Number:'Number',Web:'Web',Email:'Email',Password:'Password',AlphaNumeric:'AlphaNumeric',EVirtualKeyboardType_MAX:'EVirtualKeyboardType_MAX', };
declare class VirtualKeyboardOptions { 
	bEnableAutocorrect: boolean;
	clone() : VirtualKeyboardOptions;
	static C(Other: UObject | any): VirtualKeyboardOptions;
}

declare type EVirtualKeyboardTrigger = 'OnFocusByPointer' | 'OnAllFocusEvents' | 'EVirtualKeyboardTrigger_MAX';
declare var EVirtualKeyboardTrigger : { OnFocusByPointer:'OnFocusByPointer',OnAllFocusEvents:'OnAllFocusEvents',EVirtualKeyboardTrigger_MAX:'EVirtualKeyboardTrigger_MAX', };
declare type EVirtualKeyboardDismissAction = 'TextChangeOnDismiss' | 'TextCommitOnAccept' | 'TextCommitOnDismiss' | 'EVirtualKeyboardDismissAction_MAX';
declare var EVirtualKeyboardDismissAction : { TextChangeOnDismiss:'TextChangeOnDismiss',TextCommitOnAccept:'TextCommitOnAccept',TextCommitOnDismiss:'TextCommitOnDismiss',EVirtualKeyboardDismissAction_MAX:'EVirtualKeyboardDismissAction_MAX', };
declare type ETextJustify = 'Left' | 'Center' | 'Right' | 'ETextJustify_MAX';
declare var ETextJustify : { Left:'Left',Center:'Center',Right:'Right',ETextJustify_MAX:'ETextJustify_MAX', };
declare type ETextShapingMethod = 'Auto' | 'KerningOnly' | 'FullShaping' | 'ETextShapingMethod_MAX';
declare var ETextShapingMethod : { Auto:'Auto',KerningOnly:'KerningOnly',FullShaping:'FullShaping',ETextShapingMethod_MAX:'ETextShapingMethod_MAX', };
declare type ETextFlowDirection = 'Auto' | 'LeftToRight' | 'RightToLeft' | 'ETextFlowDirection_MAX';
declare var ETextFlowDirection : { Auto:'Auto',LeftToRight:'LeftToRight',RightToLeft:'RightToLeft',ETextFlowDirection_MAX:'ETextFlowDirection_MAX', };
declare class ShapedTextOptions { 
	bOverride_TextShapingMethod: boolean;
	bOverride_TextFlowDirection: boolean;
	TextShapingMethod: ETextShapingMethod;
	TextFlowDirection: ETextFlowDirection;
	clone() : ShapedTextOptions;
	static C(Other: UObject | any): ShapedTextOptions;
}

declare type ETextCommit = 'Default' | 'OnEnter' | 'OnUserMovedFocus' | 'OnCleared' | 'ETextCommit_MAX';
declare var ETextCommit : { Default:'Default',OnEnter:'OnEnter',OnUserMovedFocus:'OnUserMovedFocus',OnCleared:'OnCleared',ETextCommit_MAX:'ETextCommit_MAX', };
declare class EditableText extends Widget { 
	Text: string;
	TextDelegate: UnrealEngineDelegate<() => string>;
	HintText: string;
	HintTextDelegate: UnrealEngineDelegate<() => string>;
	WidgetStyle: EditableTextStyle;
	IsReadOnly: boolean;
	IsPassword: boolean;
	MinimumDesiredWidth: number;
	IsCaretMovedWhenGainFocus: boolean;
	SelectAllTextWhenFocused: boolean;
	RevertTextOnEscape: boolean;
	ClearKeyboardFocusOnCommit: boolean;
	SelectAllTextOnCommit: boolean;
	AllowContextMenu: boolean;
	KeyboardType: EVirtualKeyboardType;
	VirtualKeyboardOptions: VirtualKeyboardOptions;
	VirtualKeyboardTrigger: EVirtualKeyboardTrigger;
	VirtualKeyboardDismissAction: EVirtualKeyboardDismissAction;
	Justification: ETextJustify;
	OverflowPolicy: ETextOverflowPolicy;
	ShapedTextOptions: ShapedTextOptions;
	OnTextChanged: UnrealEngineMulticastDelegate<(Text: string) => void>;
	OnTextCommitted: UnrealEngineMulticastDelegate<(Text: string, CommitMethod: ETextCommit) => void>;
	static Load(ResourceName: string): EditableText;
	static Find(Outer: UObject, ResourceName: string): EditableText;
	static GetDefaultObject(): EditableText;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableText;
	SetTextOverflowPolicy(InOverflowPolicy: ETextOverflowPolicy): void;
	SetText(InText: string): void;
	SetMinimumDesiredWidth(InMinDesiredWidth: number): void;
	SetJustification(InJustification: ETextJustify): void;
	SetIsReadOnly(InbIsReadyOnly: boolean): void;
	SetIsPassword(InbIsPassword: boolean): void;
	SetHintText(InHintText: string): void;
	SetFontOutlineMaterial(InMaterial: MaterialInterface): void;
	SetFontMaterial(InMaterial: MaterialInterface): void;
	SetFont(InFontInfo: SlateFontInfo): void;
	GetText(): string;
	GetJustification(): ETextJustify;
	GetHintText(): string;
	GetFont(): SlateFontInfo;
	static C(Other: UObject | any): EditableText;
}

declare class EditableTextBox extends Widget { 
	Text: string;
	TextDelegate: UnrealEngineDelegate<() => string>;
	WidgetStyle: EditableTextBoxStyle;
	HintText: string;
	HintTextDelegate: UnrealEngineDelegate<() => string>;
	IsReadOnly: boolean;
	IsPassword: boolean;
	MinimumDesiredWidth: number;
	IsCaretMovedWhenGainFocus: boolean;
	SelectAllTextWhenFocused: boolean;
	RevertTextOnEscape: boolean;
	ClearKeyboardFocusOnCommit: boolean;
	SelectAllTextOnCommit: boolean;
	AllowContextMenu: boolean;
	KeyboardType: EVirtualKeyboardType;
	VirtualKeyboardOptions: VirtualKeyboardOptions;
	VirtualKeyboardTrigger: EVirtualKeyboardTrigger;
	VirtualKeyboardDismissAction: EVirtualKeyboardDismissAction;
	Justification: ETextJustify;
	OverflowPolicy: ETextOverflowPolicy;
	ShapedTextOptions: ShapedTextOptions;
	OnTextChanged: UnrealEngineMulticastDelegate<(Text: string) => void>;
	OnTextCommitted: UnrealEngineMulticastDelegate<(Text: string, CommitMethod: ETextCommit) => void>;
	bIsFontDeprecationDone: boolean;
	static Load(ResourceName: string): EditableTextBox;
	static Find(Outer: UObject, ResourceName: string): EditableTextBox;
	static GetDefaultObject(): EditableTextBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableTextBox;
	SetTextOverflowPolicy(InOverflowPolicy: ETextOverflowPolicy): void;
	SetText(InText: string): void;
	SetJustification(InJustification: ETextJustify): void;
	SetIsReadOnly(bReadOnly: boolean): void;
	SetIsPassword(bIsPassword: boolean): void;
	SetHintText(InText: string): void;
	SetForegroundColor(Color: LinearColor): void;
	SetError(InError: string): void;
	HasError(): boolean;
	GetText(): string;
	ClearError(): void;
	static C(Other: UObject | any): EditableTextBox;
}

declare class ExpandableAreaStyle extends SlateWidgetStyle { 
	CollapsedImage: SlateBrush;
	ExpandedImage: SlateBrush;
	RolloutAnimationSeconds: number;
	clone() : ExpandableAreaStyle;
	static C(Other: UObject | any): ExpandableAreaStyle;
}

declare class ExpandableArea extends Widget { 
	Style: ExpandableAreaStyle;
	BorderBrush: SlateBrush;
	BorderColor: SlateColor;
	bIsExpanded: boolean;
	MaxHeight: number;
	HeaderPadding: Margin;
	AreaPadding: Margin;
	OnExpansionChanged: UnrealEngineMulticastDelegate<(Area: ExpandableArea, bIsExpanded: boolean) => void>;
	HeaderContent: Widget;
	BodyContent: Widget;
	static Load(ResourceName: string): ExpandableArea;
	static Find(Outer: UObject, ResourceName: string): ExpandableArea;
	static GetDefaultObject(): ExpandableArea;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ExpandableArea;
	SetIsExpanded_Animated(IsExpanded: boolean): void;
	SetIsExpanded(IsExpanded: boolean): void;
	GetIsExpanded(): boolean;
	static C(Other: UObject | any): ExpandableArea;
}

declare class GridPanel extends PanelWidget { 
	ColumnFill: number[];
	RowFill: number[];
	static Load(ResourceName: string): GridPanel;
	static Find(Outer: UObject, ResourceName: string): GridPanel;
	static GetDefaultObject(): GridPanel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GridPanel;
	SetRowFill(RowIndex: number,Coefficient: number): void;
	SetColumnFill(ColumnIndex: number,Coefficient: number): void;
	AddChildToGrid(Content: Widget,InRow: number,InColumn: number): GridSlot;
	static C(Other: UObject | any): GridPanel;
}

declare class HorizontalBox extends PanelWidget { 
	static Load(ResourceName: string): HorizontalBox;
	static Find(Outer: UObject, ResourceName: string): HorizontalBox;
	static GetDefaultObject(): HorizontalBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HorizontalBox;
	AddChildToHorizontalBox(Content: Widget): HorizontalBoxSlot;
	static C(Other: UObject | any): HorizontalBox;
}

declare class UImage extends Widget { 
	Brush: SlateBrush;
	BrushDelegate: UnrealEngineDelegate<() => SlateBrush>;
	ColorAndOpacity: LinearColor;
	ColorAndOpacityDelegate: UnrealEngineDelegate<() => LinearColor>;
	bFlipForRightToLeftFlowDirection: boolean;
	OnMouseButtonDownEvent: UnrealEngineDelegate<(MyGeometry: Geometry, MouseEvent: UPointerEvent) => EventReply>;
	static Load(ResourceName: string): UImage;
	static Find(Outer: UObject, ResourceName: string): UImage;
	static GetDefaultObject(): UImage;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UImage;
	SetOpacity(InOpacity: number): void;
	SetDesiredSizeOverride(DesiredSize: Vector2D): void;
	SetColorAndOpacity(InColorAndOpacity: LinearColor): void;
	SetBrushTintColor(TintColor: SlateColor): void;
	SetBrushResourceObject(ResourceObject: UObject): void;
	SetBrushFromTextureDynamic(Texture: Texture2DDynamic,bMatchSize: boolean): void;
	SetBrushFromTexture(Texture: Texture2D,bMatchSize: boolean): void;
	SetBrushFromSoftTexture(SoftTexture: Texture2D,bMatchSize: boolean): void;
	SetBrushFromSoftMaterial(SoftMaterial: MaterialInterface): void;
	SetBrushFromMaterial(Material: MaterialInterface): void;
	SetBrushFromAsset(Asset: SlateBrushAsset): void;
	SetBrush(InBrush: SlateBrush): void;
	GetDynamicMaterial(): MaterialInstanceDynamic;
	static C(Other: UObject | any): UImage;
}

declare class InputChord { 
	Key: Key;
	bShift: boolean;
	bCtrl: boolean;
	bAlt: boolean;
	bCmd: boolean;
	clone() : InputChord;
	static C(Other: UObject | any): InputChord;
	EqualEqual_InputChordInputChord(B: InputChord): boolean;
	InputChord_GetDisplayName(): string;
	static EqualEqual_InputChordInputChord(A: InputChord,B: InputChord): boolean;
	static InputChord_GetDisplayName(Key: InputChord): string;
}

declare class InputKeySelector extends Widget { 
	WidgetStyle: ButtonStyle;
	TextStyle: TextBlockStyle;
	SelectedKey: InputChord;
	Margin: Margin;
	KeySelectionText: string;
	NoKeySpecifiedText: string;
	bAllowModifierKeys: boolean;
	bAllowGamepadKeys: boolean;
	EscapeKeys: Key[];
	OnKeySelected: UnrealEngineMulticastDelegate<(SelectedKey: InputChord) => void>;
	OnIsSelectingKeyChanged: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): InputKeySelector;
	static Find(Outer: UObject, ResourceName: string): InputKeySelector;
	static GetDefaultObject(): InputKeySelector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputKeySelector;
	SetTextBlockVisibility(InVisibility: ESlateVisibility): void;
	SetSelectedKey(InSelectedKey: InputChord): void;
	SetNoKeySpecifiedText(InNoKeySpecifiedText: string): void;
	SetKeySelectionText(InKeySelectionText: string): void;
	SetEscapeKeys(InKeys: Key[]): void;
	SetAllowModifierKeys(bInAllowModifierKeys: boolean): void;
	SetAllowGamepadKeys(bInAllowGamepadKeys: boolean): void;
	GetIsSelectingKey(): boolean;
	static C(Other: UObject | any): InputKeySelector;
}

declare class InvalidationBox extends ContentWidget { 
	bCanCache: boolean;
	CacheRelativeTransforms: boolean;
	static Load(ResourceName: string): InvalidationBox;
	static Find(Outer: UObject, ResourceName: string): InvalidationBox;
	static GetDefaultObject(): InvalidationBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InvalidationBox;
	SetCanCache(CanCache: boolean): void;
	InvalidateCache(): void;
	GetCanCache(): boolean;
	static C(Other: UObject | any): InvalidationBox;
}

declare type EMenuPlacement = 'MenuPlacement_BelowAnchor' | 'MenuPlacement_CenteredBelowAnchor' | 'MenuPlacement_BelowRightAnchor' | 'MenuPlacement_ComboBox' | 'MenuPlacement_ComboBoxRight' | 'MenuPlacement_MenuRight' | 'MenuPlacement_AboveAnchor' | 'MenuPlacement_CenteredAboveAnchor' | 'MenuPlacement_AboveRightAnchor' | 'MenuPlacement_MenuLeft' | 'MenuPlacement_Center' | 'MenuPlacement_RightLeftCenter' | 'MenuPlacement_MatchBottomLeft' | 'MenuPlacement_MAX';
declare var EMenuPlacement : { MenuPlacement_BelowAnchor:'MenuPlacement_BelowAnchor',MenuPlacement_CenteredBelowAnchor:'MenuPlacement_CenteredBelowAnchor',MenuPlacement_BelowRightAnchor:'MenuPlacement_BelowRightAnchor',MenuPlacement_ComboBox:'MenuPlacement_ComboBox',MenuPlacement_ComboBoxRight:'MenuPlacement_ComboBoxRight',MenuPlacement_MenuRight:'MenuPlacement_MenuRight',MenuPlacement_AboveAnchor:'MenuPlacement_AboveAnchor',MenuPlacement_CenteredAboveAnchor:'MenuPlacement_CenteredAboveAnchor',MenuPlacement_AboveRightAnchor:'MenuPlacement_AboveRightAnchor',MenuPlacement_MenuLeft:'MenuPlacement_MenuLeft',MenuPlacement_Center:'MenuPlacement_Center',MenuPlacement_RightLeftCenter:'MenuPlacement_RightLeftCenter',MenuPlacement_MatchBottomLeft:'MenuPlacement_MatchBottomLeft',MenuPlacement_MAX:'MenuPlacement_MAX', };
declare class MenuAnchor extends ContentWidget { 
	MenuClass: UnrealEngineClass;
	OnGetMenuContentEvent: UnrealEngineDelegate<() => Widget>;
	OnGetUserMenuContentEvent: UnrealEngineDelegate<() => UserWidget>;
	PLACEMENT: EMenuPlacement;
	bFitInWindow: boolean;
	ShouldDeferPaintingAfterWindowContent: boolean;
	UseApplicationMenuStack: boolean;
	OnMenuOpenChanged: UnrealEngineMulticastDelegate<(bIsOpen: boolean) => void>;
	static Load(ResourceName: string): MenuAnchor;
	static Find(Outer: UObject, ResourceName: string): MenuAnchor;
	static GetDefaultObject(): MenuAnchor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MenuAnchor;
	ToggleOpen(bFocusOnOpen: boolean): void;
	ShouldOpenDueToClick(): boolean;
	SetPlacement(InPlacement: EMenuPlacement): void;
	Open(bFocusMenu: boolean): void;
	IsOpen(): boolean;
	HasOpenSubMenus(): boolean;
	GetMenuPosition(): Vector2D;
	FitInWindow(bFit: boolean): void;
	Close(): void;
	static C(Other: UObject | any): MenuAnchor;
}

declare type ETextWrappingPolicy = 'DefaultWrapping' | 'AllowPerCharacterWrapping' | 'ETextWrappingPolicy_MAX';
declare var ETextWrappingPolicy : { DefaultWrapping:'DefaultWrapping',AllowPerCharacterWrapping:'AllowPerCharacterWrapping',ETextWrappingPolicy_MAX:'ETextWrappingPolicy_MAX', };
declare class TextLayoutWidget extends Widget { 
	ShapedTextOptions: ShapedTextOptions;
	Justification: ETextJustify;
	WrappingPolicy: ETextWrappingPolicy;
	AutoWrapText: boolean;
	WrapTextAt: number;
	Margin: Margin;
	LineHeightPercentage: number;
	static Load(ResourceName: string): TextLayoutWidget;
	static Find(Outer: UObject, ResourceName: string): TextLayoutWidget;
	static GetDefaultObject(): TextLayoutWidget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextLayoutWidget;
	SetJustification(InJustification: ETextJustify): void;
	static C(Other: UObject | any): TextLayoutWidget;
}

declare class MultiLineEditableText extends TextLayoutWidget { 
	Text: string;
	HintText: string;
	HintTextDelegate: UnrealEngineDelegate<() => string>;
	WidgetStyle: TextBlockStyle;
	bIsReadOnly: boolean;
	SelectAllTextWhenFocused: boolean;
	ClearTextSelectionOnFocusLoss: boolean;
	RevertTextOnEscape: boolean;
	ClearKeyboardFocusOnCommit: boolean;
	AllowContextMenu: boolean;
	VirtualKeyboardOptions: VirtualKeyboardOptions;
	VirtualKeyboardDismissAction: EVirtualKeyboardDismissAction;
	OnTextChanged: UnrealEngineMulticastDelegate<(Text: string) => void>;
	OnTextCommitted: UnrealEngineMulticastDelegate<(Text: string, CommitMethod: ETextCommit) => void>;
	static Load(ResourceName: string): MultiLineEditableText;
	static Find(Outer: UObject, ResourceName: string): MultiLineEditableText;
	static GetDefaultObject(): MultiLineEditableText;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MultiLineEditableText;
	SetWidgetStyle(InWidgetStyle: TextBlockStyle): void;
	SetText(InText: string): void;
	SetIsReadOnly(bReadOnly: boolean): void;
	SetHintText(InHintText: string): void;
	SetFontOutlineMaterial(InMaterial: MaterialInterface): void;
	SetFontMaterial(InMaterial: MaterialInterface): void;
	SetFont(InFontInfo: SlateFontInfo): void;
	GetText(): string;
	GetHintText(): string;
	GetFont(): SlateFontInfo;
	static C(Other: UObject | any): MultiLineEditableText;
}

declare class MultiLineEditableTextBox extends TextLayoutWidget { 
	Text: string;
	HintText: string;
	HintTextDelegate: UnrealEngineDelegate<() => string>;
	WidgetStyle: EditableTextBoxStyle;
	TextStyle: TextBlockStyle;
	bIsReadOnly: boolean;
	AllowContextMenu: boolean;
	VirtualKeyboardOptions: VirtualKeyboardOptions;
	VirtualKeyboardDismissAction: EVirtualKeyboardDismissAction;
	OnTextChanged: UnrealEngineMulticastDelegate<(Text: string) => void>;
	OnTextCommitted: UnrealEngineMulticastDelegate<(Text: string, CommitMethod: ETextCommit) => void>;
	bIsFontDeprecationDone: boolean;
	static Load(ResourceName: string): MultiLineEditableTextBox;
	static Find(Outer: UObject, ResourceName: string): MultiLineEditableTextBox;
	static GetDefaultObject(): MultiLineEditableTextBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MultiLineEditableTextBox;
	SetTextStyle(InTextStyle: TextBlockStyle): void;
	SetText(InText: string): void;
	SetIsReadOnly(bReadOnly: boolean): void;
	SetHintText(InHintText: string): void;
	SetForegroundColor(Color: LinearColor): void;
	SetError(InError: string): void;
	GetText(): string;
	GetHintText(): string;
	static C(Other: UObject | any): MultiLineEditableTextBox;
}

declare class NamedSlot extends ContentWidget { 
	bExposeOnInstanceOnly: boolean;
	static Load(ResourceName: string): NamedSlot;
	static Find(Outer: UObject, ResourceName: string): NamedSlot;
	static GetDefaultObject(): NamedSlot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NamedSlot;
	static C(Other: UObject | any): NamedSlot;
}

declare class NamedSlotInterface extends Interface { 
	static Load(ResourceName: string): NamedSlotInterface;
	static Find(Outer: UObject, ResourceName: string): NamedSlotInterface;
	static GetDefaultObject(): NamedSlotInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NamedSlotInterface;
	static C(Other: UObject | any): NamedSlotInterface;
}

declare class NativeWidgetHost extends Widget { 
	static Load(ResourceName: string): NativeWidgetHost;
	static Find(Outer: UObject, ResourceName: string): NativeWidgetHost;
	static GetDefaultObject(): NativeWidgetHost;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NativeWidgetHost;
	static C(Other: UObject | any): NativeWidgetHost;
	SetContent(SlateWidget: JavascriptSlateWidget): Widget;
	static SetContent(TargetWidget: NativeWidgetHost,SlateWidget: JavascriptSlateWidget): Widget;
}

